<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeline-Test - Deterministische Pipeline-Validierung</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a; color: #e2e8f0; padding: 20px; min-height: 100vh;
        }
        h1 { text-align: center; margin-bottom: 8px; color: #38bdf8; font-size: 28px; }
        .subtitle { text-align: center; color: #64748b; margin-bottom: 30px; font-size: 14px; }
        .config-panel {
            background: #1e293b; border-radius: 12px; padding: 20px; margin-bottom: 20px;
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;
        }
        .config-group { display: flex; flex-direction: column; gap: 6px; }
        .config-group label { font-size: 12px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; }
        input, select {
            padding: 10px 14px; border-radius: 6px; border: 1px solid #334155;
            background: #0f172a; color: #e2e8f0; font-size: 14px;
        }
        input:focus, select:focus { outline: none; border-color: #38bdf8; }
        button {
            padding: 12px 24px; border-radius: 8px; border: none;
            font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, #38bdf8, #0ea5e9); color: #0f172a; }
        .btn-primary:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(56, 189, 248, 0.4); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-secondary { background: #334155; color: #e2e8f0; }
        .btn-danger { background: #dc2626; color: white; }
        .test-controls { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 30px; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 30px; }
        .stat-card { background: #1e293b; border-radius: 10px; padding: 15px; text-align: center; }
        .stat-value { font-size: 28px; font-weight: 700; color: #38bdf8; }
        .stat-value.success { color: #22c55e; }
        .stat-value.warning { color: #eab308; }
        .stat-value.error { color: #ef4444; }
        .stat-label { font-size: 11px; color: #64748b; text-transform: uppercase; margin-top: 4px; }
        .phase-tabs {
            display: flex; gap: 4px; margin-bottom: 20px;
            background: #1e293b; padding: 4px; border-radius: 10px;
        }
        .phase-tab {
            flex: 1; padding: 12px; background: transparent; border: none;
            color: #64748b; font-size: 13px; font-weight: 500; cursor: pointer;
            border-radius: 8px; transition: all 0.2s;
        }
        .phase-tab.active { background: #334155; color: #38bdf8; }
        .phase-tab:hover:not(.active) { color: #e2e8f0; }
        .phase-tab .badge {
            display: inline-block; padding: 2px 6px; border-radius: 10px;
            font-size: 10px; margin-left: 6px; background: #334155;
        }
        .phase-tab.active .badge { background: #38bdf8; color: #0f172a; }
        .results-container { background: #1e293b; border-radius: 12px; overflow: hidden; }
        .results-header {
            padding: 15px 20px; background: #334155;
            display: flex; justify-content: space-between; align-items: center;
        }
        .results-title { font-weight: 600; color: #e2e8f0; }
        .results-body { max-height: 500px; overflow-y: auto; }
        .test-row {
            display: grid; grid-template-columns: 40px 1fr 120px 100px 80px 100px;
            gap: 10px; padding: 12px 20px; align-items: center;
            border-bottom: 1px solid #334155; font-size: 13px;
        }
        .test-row:hover { background: #334155; }
        .test-index { color: #64748b; font-weight: 500; }
        .test-file { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .test-status {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 4px 10px; border-radius: 20px; font-size: 11px; font-weight: 600;
        }
        .test-status.pending { background: #334155; color: #94a3b8; }
        .test-status.running { background: #1e3a5f; color: #38bdf8; }
        .test-status.success { background: #14532d; color: #22c55e; }
        .test-status.passed { background: #14532d; color: #22c55e; }
        .test-status.warning { background: #422006; color: #eab308; }
        .test-status.error { background: #450a0a; color: #ef4444; }
        .test-checks { font-size: 11px; }
        .test-checks .passed { color: #22c55e; }
        .test-checks .failed { color: #ef4444; }
        .btn-details {
            padding: 4px 10px; font-size: 11px; background: #334155;
            color: #94a3b8; border: none; border-radius: 4px; cursor: pointer;
        }
        .btn-details:hover { background: #475569; color: #e2e8f0; }
        .validation-panel { margin-top: 20px; background: #1e293b; border-radius: 12px; padding: 20px; }
        .validation-title { font-size: 14px; font-weight: 600; margin-bottom: 15px; color: #94a3b8; }
        .check-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; }
        .check-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px; background: #0f172a; border-radius: 6px;
        }
        .check-icon {
            width: 20px; height: 20px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 12px;
        }
        .check-icon.pass { background: #14532d; color: #22c55e; }
        .check-icon.fail { background: #450a0a; color: #ef4444; }
        .check-icon.pending { background: #334155; color: #64748b; }
        .check-name { flex: 1; font-size: 12px; }
        .check-value { font-size: 11px; color: #64748b; font-family: monospace; }
        .log-panel { margin-top: 20px; background: #0f172a; border-radius: 8px; border: 1px solid #334155; }
        .log-header {
            padding: 10px 15px; background: #1e293b;
            display: flex; justify-content: space-between; align-items: center; border-radius: 8px 8px 0 0;
        }
        .log-body {
            padding: 15px; max-height: 300px; overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; line-height: 1.6;
        }
        .log-entry { padding: 4px 0; }
        .log-entry.info { color: #94a3b8; }
        .log-entry.success { color: #22c55e; }
        .log-entry.warning { color: #eab308; }
        .log-entry.error { color: #ef4444; }
        .log-time { color: #475569; margin-right: 10px; }
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8); z-index: 1000; justify-content: center; align-items: center;
        }
        .modal-overlay.visible { display: flex; }
        .modal { background: #1e293b; border-radius: 12px; width: 90%; max-width: 900px; max-height: 80vh; overflow: hidden; }
        .modal-header {
            padding: 20px; background: #334155;
            display: flex; justify-content: space-between; align-items: center;
        }
        .modal-title { font-size: 16px; font-weight: 600; }
        .modal-close { background: none; border: none; color: #94a3b8; font-size: 24px; cursor: pointer; }
        .modal-body { padding: 20px; max-height: calc(80vh - 70px); overflow-y: auto; }
        .json-viewer {
            background: #0f172a; border-radius: 8px; padding: 15px;
            font-family: monospace; font-size: 12px; white-space: pre-wrap;
            word-break: break-all; max-height: 400px; overflow-y: auto;
        }
        .progress-container { margin: 20px 0; }
        .progress-bar { height: 8px; background: #334155; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #38bdf8, #22c55e); border-radius: 4px; transition: width 0.3s; }
        .progress-text { display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #64748b; }
        @media (max-width: 768px) {
            .stats-grid { grid-template-columns: repeat(3, 1fr); }
            .test-row { grid-template-columns: 30px 1fr 80px; }
            .test-row > *:nth-child(n+4) { display: none; }
        }
        .feature-bar-row { display: grid; grid-template-columns: 140px 1fr 60px; gap: 10px; align-items: center; padding: 6px 0; }
        .feature-bar-name { font-size: 13px; color: #e2e8f0; }
        .feature-bar-track { height: 24px; background: #334155; border-radius: 4px; overflow: hidden; }
        .feature-bar-fill {
            height: 100%; border-radius: 4px; transition: width 0.5s ease;
            display: flex; align-items: center; padding-left: 8px;
            font-size: 11px; color: #0f172a; font-weight: 600;
        }
        .feature-bar-rate { font-size: 13px; color: #94a3b8; text-align: right; font-family: monospace; }
        .heatmap-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .heatmap-table th { padding: 6px 8px; text-align: center; color: #94a3b8; font-weight: 500; border-bottom: 1px solid #334155; }
        .heatmap-table th:first-child { text-align: left; }
        .heatmap-table td { padding: 6px 8px; text-align: center; border-bottom: 1px solid #1e293b; }
        .heatmap-cell { display: inline-block; width: 28px; height: 28px; border-radius: 4px; line-height: 28px; font-size: 11px; font-weight: 600; }
        .heatmap-cell.active { background: #166534; color: #22c55e; }
        .heatmap-cell.inactive { background: #1e293b; color: #475569; }
        .heatmap-cell.unavailable { background: #0f172a; color: #334155; }
        .conflict-item {
            padding: 8px 12px; background: #0f172a; border-radius: 6px;
            margin-bottom: 8px; font-size: 12px; display: flex; align-items: center; gap: 8px;
        }
        .conflict-icon { color: #eab308; font-size: 14px; }
        .bracket-mode-item { display: flex; align-items: center; gap: 10px; padding: 6px 0; }
        .bracket-mode-bar { flex: 1; height: 20px; background: #334155; border-radius: 4px; overflow: hidden; }
        .bracket-mode-fill { height: 100%; background: #38bdf8; border-radius: 4px; }
        .bracket-mode-label { width: 80px; font-size: 12px; color: #e2e8f0; }
        .bracket-mode-count { width: 40px; font-size: 12px; color: #94a3b8; text-align: right; }
    </style>
</head>
<body>
    <h1>Pipeline-Test Suite</h1>
    <p class="subtitle">Deterministische Pipeline: PROMPT-1 (KI) + PROMPT-2 (KI) + DeterministicConfigGenerator (JS) + JS-Renderer | 6 Phasen</p>

    <!-- Config Panel -->
    <div class="config-panel">
        <div class="config-group">
            <label>API Provider</label>
            <select id="providerSelect">
                <option value="anthropic">Anthropic (Claude)</option>
                <option value="openai">OpenAI (GPT-4)</option>
            </select>
        </div>
        <div class="config-group">
            <label>API Key</label>
            <input type="password" id="apiKeyInput" placeholder="sk-... oder anthropic-key">
        </div>
        <div class="config-group">
            <label>Testdaten-Set</label>
            <select id="testDataSelect">
                <option value="testdaten_1" selected>Testdaten_1 (Basis, 50 Dateien)</option>
                <option value="testdaten_2">Testdaten_2 (51 Dateien)</option>
                <option value="testdaten_3">Testdaten_3 (Multi-Szenario, 78 Dateien)</option>
            </select>
        </div>
        <div class="config-group">
            <label>Test-Modus</label>
            <select id="testModeSelect">
                <option value="quick" selected>Quick (10 Dateien, Phase 1-5)</option>
                <option value="full">Full (alle Dateien, Phase 1-5)</option>
                <option value="phase1">Nur Phase 1 (Analyzer) - 1 API-Call</option>
                <option value="phase2">Phase 1-2 (+ Variants) - 2+ API-Calls</option>
                <option value="phase3">Phase 1-3 (+ Config, kein Render)</option>
            </select>
        </div>
        <div class="config-group">
            <label>Chart-Typ Filter</label>
            <select id="chartTypeFilter">
                <option value="all">Alle Typen</option>
                <option value="waterfall">Nur Waterfall</option>
                <option value="bar">Nur Bar Chart</option>
                <option value="stacked-bar">Nur Stacked Bar</option>
            </select>
        </div>
    </div>

    <!-- Test Controls -->
    <div class="test-controls">
        <button class="btn-primary" id="btnStartTests" onclick="startTests()">Tests starten</button>
        <button class="btn-secondary" onclick="stopTests()">Abbrechen</button>
        <button class="btn-secondary" onclick="exportResults()">Ergebnisse exportieren</button>
        <button class="btn-danger" onclick="clearResults()">Zurücksetzen</button>
        <button class="btn-secondary" onclick="runEdgeCaseTests()" title="Kein API-Key nötig">Phase 6: Edge-Cases</button>
    </div>

    <!-- Progress -->
    <div class="progress-container" id="progressContainer" style="display: none;">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <div class="progress-text">
            <span id="progressLabel">0 von 0 Tests</span>
            <span id="progressPercent">0%</span>
        </div>
    </div>

    <!-- Stats Grid -->
    <div class="stats-grid">
        <div class="stat-card"><div class="stat-value" id="statTotal">0</div><div class="stat-label">Tests gesamt</div></div>
        <div class="stat-card"><div class="stat-value success" id="statPassed">0</div><div class="stat-label">Bestanden</div></div>
        <div class="stat-card"><div class="stat-value warning" id="statWarnings">0</div><div class="stat-label">Warnungen</div></div>
        <div class="stat-card"><div class="stat-value error" id="statFailed">0</div><div class="stat-label">Fehlgeschlagen</div></div>
        <div class="stat-card"><div class="stat-value" id="statDuration">0s</div><div class="stat-label">Laufzeit</div></div>
        <div class="stat-card"><div class="stat-value" id="statApiCalls">0</div><div class="stat-label">API Calls</div></div>
        <div class="stat-card"><div class="stat-value" id="statFeatureRate">-</div><div class="stat-label">Ø Features/Config</div></div>
        <div class="stat-card"><div class="stat-value" id="statIntegrity">-</div><div class="stat-label">Feature-Integrität</div></div>
    </div>

    <!-- Phase Tabs -->
    <div class="phase-tabs">
        <button class="phase-tab active" onclick="showPhase(1)" data-phase="1">
            Phase 1: Analyzer <span class="badge" id="phase1Count">0</span>
        </button>
        <button class="phase-tab" onclick="showPhase(2)" data-phase="2">
            Phase 2: Variants <span class="badge" id="phase2Count">0</span>
        </button>
        <button class="phase-tab" onclick="showPhase(3)" data-phase="3">
            Phase 3: Config (JS) <span class="badge" id="phase3Count">0</span>
        </button>
        <button class="phase-tab" onclick="showPhase(4)" data-phase="4">
            Phase 4: Render (JS) <span class="badge" id="phase4Count">0</span>
        </button>
        <button class="phase-tab" onclick="showPhase(5)" data-phase="5">
            Phase 5: Features <span class="badge" id="phase5Count">0</span>
        </button>
        <button class="phase-tab" onclick="showPhase(6)" data-phase="6">
            Phase 6: Edge-Cases <span class="badge" id="phase6Count">0</span>
        </button>
    </div>

    <!-- Results Container -->
    <div class="results-container">
        <div class="results-header">
            <span class="results-title" id="resultsTitle">Phase 1: Universal Analyzer</span>
            <span id="resultsCount">0 Tests</span>
        </div>
        <div class="results-body" id="resultsBody">
            <div style="padding: 40px; text-align: center; color: #64748b;">
                Keine Tests ausgeführt. Klicke "Tests starten" um zu beginnen.
            </div>
        </div>
    </div>

    <!-- Feature Dashboard (only visible in Phase 5) -->
    <div id="featureDashboard" style="display: none; margin-top: 20px;">
        <div style="background: #1e293b; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #38bdf8; margin-bottom: 15px; font-size: 16px;">Feature-Aktivierungsraten</h3>
            <div id="featureActivationBars"></div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div style="background: #1e293b; border-radius: 12px; padding: 20px;">
                <h3 style="color: #38bdf8; margin-bottom: 15px; font-size: 16px;">Bracket-Modi Verteilung</h3>
                <div id="bracketModeChart"></div>
            </div>
            <div style="background: #1e293b; border-radius: 12px; padding: 20px;">
                <h3 style="color: #38bdf8; margin-bottom: 15px; font-size: 16px;">Aufgelöste Konflikte</h3>
                <div id="conflictsLog"></div>
            </div>
        </div>
        <div style="background: #1e293b; border-radius: 12px; padding: 20px; margin-top: 20px;">
            <h3 style="color: #38bdf8; margin-bottom: 15px; font-size: 16px;">Template x Feature Heatmap</h3>
            <div id="templateHeatmap" style="overflow-x: auto;"></div>
        </div>
    </div>

    <!-- Validation Checks Panel -->
    <div class="validation-panel">
        <div class="validation-title">Validierungs-Checks (Phase 1)</div>
        <div class="check-grid" id="checkGrid">
            <div class="check-item"><div class="check-icon pending">?</div><span class="check-name">JSON-Schema valide</span><span class="check-value">-</span></div>
            <div class="check-item"><div class="check-icon pending">?</div><span class="check-name">Spracherhaltung (Labels)</span><span class="check-value">-</span></div>
            <div class="check-item"><div class="check-icon pending">?</div><span class="check-name">Szenarien erkannt</span><span class="check-value">-</span></div>
            <div class="check-item"><div class="check-icon pending">?</div><span class="check-name">Perioden extrahiert</span><span class="check-value">-</span></div>
            <div class="check-item"><div class="check-icon pending">?</div><span class="check-name">Report-Typ plausibel</span><span class="check-value">-</span></div>
            <div class="check-item"><div class="check-icon pending">?</div><span class="check-name">Datenwerte vorhanden</span><span class="check-value">-</span></div>
        </div>
    </div>

    <!-- Log Panel -->
    <div class="log-panel">
        <div class="log-header">
            <span>Execution Log</span>
            <button class="btn-details" onclick="clearLog()">Log löschen</button>
        </div>
        <div class="log-body" id="logBody">
            <div class="log-entry info">
                <span class="log-time">[--:--:--]</span>
                Pipeline-Test Suite bereit (Deterministische Architektur v3.1). Warte auf Start...
            </div>
        </div>
    </div>

    <!-- Detail Modal -->
    <div class="modal-overlay" id="modalOverlay" onclick="closeModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <span class="modal-title" id="modalTitle">Test-Details</span>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <div class="json-viewer" id="jsonViewer"></div>
            </div>
        </div>
    </div>

    <!-- Externe JS-Module (gleiche wie charts.html) -->
    <script src="js/template-loader.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/prompt-loader.js"></script>
    <script src="js/data-profiler.js"></script>
    <script src="js/deterministic-config.js"></script>
    <script src="js/normalize-config.js"></script>
    <script src="js/ui-helpers.js"></script>
    <script src="js/renderer-waterfall.js"></script>
    <script src="js/renderer-bar.js"></script>
    <script src="js/renderer-stacked.js"></script>

    <script>
        // =====================================================
        // KONFIGURATION
        // =====================================================
        const CONFIG = {
            testFilesPath: '../5.%20Datenbeispiele/',
            promptsPath: '../4.%20Prompts/',
            templatesPath: '../6.%20Bibliotheken/templates.json',
            colorSchemesPath: '../6.%20Bibliotheken/color-schemes.json',

            testDataSets: {
                testdaten_1: {
                    folder: 'Testdaten_1/',
                    quickFiles: [
                        '01_GuV_Monatssicht_IST_FC_BUD.xlsx',
                        '09_Bilanz_Jahresvergleich.xlsx',
                        '15_Cashflow_Statement_Annual.xlsx',
                        '20_Segment_Revenue_by_Region.xlsx',
                        '29_Revenue_by_Customer_Top20.csv',
                        '33_OpEx_Breakdown_Monthly.xlsx',
                        '42_EBITDA_Bridge_PY_to_CY.xlsx',
                        '44_KPI_Dashboard_Monthly.xlsx',
                        '47_Financials_Long_Format.csv',
                        '50_Multi_Currency_Report.xlsx'
                    ],
                    allFiles: [
                        '01_GuV_Monatssicht_IST_FC_BUD.xlsx', '02_GuV_Faktentabelle_SEL_CUM.csv',
                        '03_PL_Quartalssicht_YoY.csv', '04_IFRS_PL_FC_Iterationen.xlsx',
                        '05_GuV_SEL_CUM_Abweichungen.xlsx', '06_PL_Rolling_Forecast.csv',
                        '07_GuV_Konzern_vs_Einzelgesellschaft.xlsx', '08_PL_3Year_Comparison.csv',
                        '09_Bilanz_Jahresvergleich.xlsx', '10_Balance_Sheet_Quarterly.csv',
                        '11_Bilanz_Aktiva_Passiva_Detail.xlsx', '12_Balance_Sheet_IST_vs_PY.csv',
                        '13_Bilanz_Kurzfristig_Langfristig.xlsx', '14_Balance_Sheet_Faktentabelle.csv',
                        '15_Cashflow_Statement_Annual.xlsx', '16_Cashflow_Indirect_Method.csv',
                        '17_Cashflow_Direct_Method.xlsx', '18_Cashflow_Quarterly_Trend.csv',
                        '19_Free_Cashflow_Bridge.xlsx', '20_Segment_Revenue_by_Region.xlsx',
                        '21_Segment_EBIT_by_BU.csv', '22_Segment_Margin_by_Product.xlsx',
                        '23_Segment_Revenue_by_Country.csv', '24_Segment_Cost_Allocation.xlsx',
                        '25_Segment_Profitability_Matrix.csv', '26_Segment_YoY_Growth_Rates.xlsx',
                        '27_Sales_Monthly_by_Channel.csv', '28_Sales_YTD_vs_Target.xlsx',
                        '29_Revenue_by_Customer_Top20.csv', '30_Sales_Pipeline_Stages.xlsx',
                        '31_Revenue_New_vs_Recurring.csv', '32_Sales_by_Product_Category.xlsx',
                        '33_OpEx_Breakdown_Monthly.xlsx', '34_Cost_Center_Actual_vs_Budget.csv',
                        '35_CapEx_Projektübersicht.xlsx', '36_Cost_by_Category_Trend.csv',
                        '37_Fixed_vs_Variable_Costs.xlsx', '38_Overhead_Allocation.csv',
                        '39_Headcount_FTE_Monthly.csv', '40_Personnel_Cost_by_Dept.xlsx',
                        '41_Salary_Bands_Analysis.csv', '42_EBITDA_Bridge_PY_to_CY.xlsx',
                        '43_Working_Capital_Trend.csv', '44_KPI_Dashboard_Monthly.xlsx',
                        '45_Budget_Variance_Analysis.csv', '46_Revenue_Bridge_Waterfall.xlsx',
                        '47_Financials_Long_Format.csv', '48_Financials_Wide_Pivoted.xlsx',
                        '49_Sparse_Data_with_Gaps.csv', '50_Multi_Currency_Report.xlsx'
                    ]
                },
                testdaten_2: {
                    folder: 'Testdaten_2/',
                    quickFiles: [
                        'NEW_01_GuV_Monat_IST_BUD_FC.csv',
                        'NEW_10_GuV_YTD_IST_FC_VJ.csv',
                        'NEW_15_Segment_Kunden_IST_BUD_FC.csv',
                        'NEW_22_Sales_YTD_IST_BUD_VJ.csv',
                        'NEW_29_Kosten_OPEX_IST_BUD.csv',
                        'NEW_35_Bilanz_Aktiva_IST_VJ.csv',
                        'NEW_41_Cashflow_IST_FC.csv',
                        'NEW_45_Personal_FTE_IST_BUD.csv',
                        'NEW_48_KPI_Dashboard_IST_BUD_FC_VJ.csv',
                        'NEW_50_Margin_Analysis_IST_BUD_FC.csv'
                    ],
                    allFiles: [
                        'NEW_01_GuV_Monat_IST_BUD_FC.csv', 'NEW_02_GuV_Monat_IST_VJ.csv',
                        'NEW_03_GuV_YTD_IST_BUD_VJ.csv', 'NEW_04_GuV_Q1-Q4_IST_VJ.csv',
                        'NEW_05_GuV_H1_IST_BUD_FC_VJ.csv', 'NEW_06_GuV_Detail_IST_BUD.csv',
                        'NEW_07_GuV_Summary_IST_FC.csv', 'NEW_08_GuV_Monatstrend_12M.csv',
                        'NEW_09_GuV_Quartale_IST_BUD_FC.csv', 'NEW_10_GuV_YTD_IST_FC_VJ.csv',
                        'NEW_11_GuV_H1H2_IST_BUD_VJ.csv', 'NEW_12_GuV_Annual_IST_BUD_FC_VJ.csv',
                        'NEW_13_Segment_DACH_EMEA_US_IST_BUD.csv', 'NEW_14_Segment_Produkte_IST_VJ.csv',
                        'NEW_15_Segment_Kunden_IST_BUD_FC.csv', 'NEW_16_Region_Q1-Q4_IST_VJ.csv',
                        'NEW_17_Segment_Business_Units_IST_BUD_FC_VJ.csv', 'NEW_18_Division_Revenue_IST_FC.csv',
                        'NEW_19_Markt_Anteile_IST_VJ.csv', 'NEW_20_Channel_Mix_IST_BUD.csv',
                        'NEW_21_Sales_Monthly_IST_FC.csv', 'NEW_22_Sales_YTD_IST_BUD_VJ.csv',
                        'NEW_23_Sales_Produkte_Top10_IST.csv', 'NEW_24_Sales_Quartale_IST_VJ.csv',
                        'NEW_25_Revenue_Mix_IST_BUD_FC.csv', 'NEW_26_Sales_H1_IST_BUD_FC_VJ.csv',
                        'NEW_27_Revenue_Trend_12M_IST.csv', 'NEW_28_Sales_Kunden_Top15_IST_VJ.csv',
                        'NEW_29_Kosten_OPEX_IST_BUD.csv', 'NEW_30_Kosten_Detail_IST_BUD_FC.csv',
                        'NEW_31_OPEX_YTD_IST_VJ.csv', 'NEW_32_Kosten_Quartale_IST_BUD.csv',
                        'NEW_33_Kosten_Abteilungen_LangeNamen.csv', 'NEW_34_OPEX_Kategorie_IST_FC_VJ.csv',
                        'NEW_35_Bilanz_Aktiva_IST_VJ.csv', 'NEW_36_Bilanz_Passiva_IST_BUD.csv',
                        'NEW_37_Working_Capital_IST_BUD_FC.csv', 'NEW_38_Balance_Sheet_IST_FC.csv',
                        'NEW_39_Assets_Liabilities_IST_VJ.csv', 'NEW_40_Cashflow_Operating_IST.csv',
                        'NEW_41_Cashflow_IST_FC.csv', 'NEW_42_Cashflow_Quartale_IST_VJ.csv',
                        'NEW_43_Cashflow_Direct_IST_BUD.csv', 'NEW_44_Cashflow_FCF_IST_BUD_FC.csv',
                        'NEW_45_Personal_FTE_IST_BUD.csv', 'NEW_46_HR_Kosten_IST_VJ.csv',
                        'NEW_47_Personal_Abteilungen_Lang.csv', 'NEW_48_KPI_Dashboard_IST_BUD_FC_VJ.csv',
                        'NEW_49_EBITDA_Bridge_IST_VJ.csv', 'NEW_50_Margin_Analysis_IST_BUD_FC.csv'
                    ]
                },
                testdaten_3: {
                    folder: 'Testdaten_3/',
                    quickFiles: [
                        '51_PL_PY_IST_vs_FC_vs_BUD_Monthly.csv',
                        '55_GuV_BUD_vs_Target_vs_Stretch.csv',
                        '61_GuV_SaaS_ARR_MRR_Scenarios.csv',
                        '67_Bilanz_Konzern_PY_IST_FC_BUD.csv',
                        '74_Segment_Revenue_PY_FC_BUD_Region.csv',
                        '79_OpEx_PY_IST_vs_FC_vs_BUD_Monthly.csv',
                        '85_KPI_Dashboard_PY_IST_vs_CY_IST.csv',
                        '90_Headcount_PY_IST_vs_FC_vs_BUD.csv',
                        '94_Revenue_BUD_FC1_FC2_Target.csv',
                        '99_DSO_DPO_DIO_Scenarios.csv'
                    ],
                    allFiles: [
                        '51_PL_PY_IST_vs_FC_vs_BUD_Monthly.csv', '52_GuV_FC1_vs_FC2_vs_BUD_Quarterly.csv',
                        '53_IFRS_PL_FC1_IT1_IT2_IT3.csv', '54_PL_PY_IST_vs_CY_IST_YoY.csv',
                        '55_GuV_BUD_vs_Target_vs_Stretch.csv', '56_PL_Rolling_FC_Q1_Q2_Q3_Q4.csv',
                        '57_GuV_PY_IST_FC1_FC2_BUD_Halbjahr.csv', '58_PL_Actual_LY_PY_CY_Trend.csv',
                        '59_GuV_BUD_vs_FC_MidYear_Update.csv', '60_PL_Multi_Iteration_Tracking.csv',
                        '61_GuV_SaaS_ARR_MRR_Scenarios.csv', '62_PL_Retail_PY_IST_vs_FC_vs_BUD.csv',
                        '63_Bilanz_PY_vs_CY_IST_Quartale.csv', '64_Balance_Sheet_BUD_FC1_FC2.csv',
                        '65_Bilanz_Opening_vs_Closing_vs_FC.csv', '66_BS_Working_Capital_3Scenarios.csv',
                        '67_Bilanz_Konzern_PY_IST_FC_BUD.csv', '68_Balance_Sheet_IT1_IT2_IT3.csv',
                        '69_Cashflow_PY_IST_vs_CY_IST_Annual.csv', '70_CF_BUD_vs_FC1_vs_FC2_Quarterly.csv',
                        '71_Cashflow_Direct_Indirect_3FC.csv', '72_FCF_Bridge_PY_to_CY_to_NY.csv',
                        '73_Cashflow_Iterations_Monthly.csv', '74_Segment_Revenue_PY_FC_BUD_Region.csv',
                        '75_Segment_EBIT_BUD_FC1_FC2_BU.csv', '76_Segment_Margin_FC_Iterations.csv',
                        '77_Segment_PY_CY_IST_by_Product.csv', '78_Segment_Multi_Dim_Scenarios.csv',
                        '79_OpEx_PY_IST_vs_FC_vs_BUD_Monthly.csv', '80_CapEx_Project_BUD_FC1_FC2.csv',
                        '81_Cost_Center_IT1_IT2_IT3.csv', '82_Fixed_Variable_PY_CY_IST.csv',
                        '83_OpEx_by_Department_4Scenarios.csv', '84_Manufacturing_Cost_FC_Versions.csv',
                        '85_KPI_Dashboard_PY_IST_vs_CY_IST.csv', '86_KPI_BUD_vs_FC_vs_Actual_Halbjahr.csv',
                        '87_Financial_Ratios_3Year_Trend.csv', '88_KPI_Target_vs_Forecast_vs_Stretch.csv',
                        '89_Operational_KPIs_FC_Iterations.csv', '90_Headcount_PY_IST_vs_FC_vs_BUD.csv',
                        '91_Personnel_Cost_IT1_IT2_IT3.csv', '92_Salary_Budget_vs_FC_vs_Actual.csv',
                        '93_Sales_PY_CY_IST_by_Channel.csv', '94_Revenue_BUD_FC1_FC2_Target.csv',
                        '95_Pipeline_FC_Quarterly_Versions.csv', '96_Order_Intake_PY_IST_FC_BUD.csv',
                        '97_Working_Capital_BUD_vs_FC_Monthly.csv', '98_Liquidity_PY_IST_vs_CY_IST_vs_FC.csv',
                        '99_DSO_DPO_DIO_Scenarios.csv', '100_Treasury_FC1_FC2_FC3_Weekly.csv'
                    ]
                }
            }
        };

        // Feature-Konstanten
        const TEMPLATE_CATEGORIES = {
            'WF-01': 'structure', 'WF-02': 'structure', 'WF-05': 'structure',
            'WF-06': 'structure', 'WF-07': 'structure', 'WF-10': 'structure',
            'WF-03': 'variance', 'WF-04': 'variance', 'WF-08': 'variance',
            'WF-09': 'variance', 'WF-12': 'variance',
            'WF-11': 'trend', 'WF-13': 'trend',
            'WF-14': 'compare_bars', 'WF-15': 'compare_bars', 'WF-16': 'compare_bars',
            'WF-17': 'compare_bars', 'WF-18': 'compare_bars', 'WF-19': 'compare_bars'
        };

        const FEATURE_CONFLICTS = [
            { a: 'bracket', b: 'arrows', winner: 'bracket' },
            { a: 'scaleBreak', b: 'negativeBridges', winner: 'negativeBridges' }
        ];

        const ALL_FEATURE_IDS = [
            'bracket', 'scaleBreak', 'categoryBrackets',
            'arrows', 'benchmarkLines', 'negativeBridges', 'grouping'
        ];

        // State
        let state = {
            isRunning: false,
            aborted: false,
            currentPhase: 1,
            results: { phase1: [], phase2: [], phase3: [], phase4: [], phase5: [], phase6: [] },
            featureStats: null,
            stats: { total: 0, passed: 0, warnings: 0, failed: 0, duration: 0, apiCalls: 0 },
            startTime: null,
            templates: null,
            colorScheme: null,
            analyzerPrompt: null
        };

        // =====================================================
        // FORMELAUFLÖSUNG (aus upload.html)
        // =====================================================
        function resolveFormulas(ws) {
            if (!ws || !ws['!ref']) return;
            const range = XLSX.utils.decode_range(ws['!ref']);
            let resolved = 0;
            for (let pass = 0; pass < 5; pass++) {
                let changedInPass = 0;
                for (let r = range.s.r; r <= range.e.r; r++) {
                    for (let c = range.s.c; c <= range.e.c; c++) {
                        const addr = XLSX.utils.encode_cell({ r, c });
                        const cell = ws[addr];
                        if (!cell || !cell.f) continue;
                        if (cell.t !== 'z' && cell.v !== undefined && cell.v !== null && cell.v !== 0) continue;
                        const result = evaluateSimpleFormula(cell.f, ws);
                        if (result !== null) {
                            cell.t = 'n'; cell.v = result; cell.w = String(result);
                            resolved++; changedInPass++;
                        }
                    }
                }
                if (changedInPass === 0) break;
            }
            if (resolved > 0) log('info', `  resolveFormulas: ${resolved} Formel-Zellen berechnet`);
        }

        function evaluateSimpleFormula(formula, ws) {
            // SUM(range)
            const sumMatch = formula.match(/^SUM\(([A-Z]+\d+):([A-Z]+\d+)\)$/i);
            if (sumMatch) {
                const startCell = XLSX.utils.decode_cell(sumMatch[1]);
                const endCell = XLSX.utils.decode_cell(sumMatch[2]);
                let sum = 0;
                for (let r = startCell.r; r <= endCell.r; r++) {
                    for (let c = startCell.c; c <= endCell.c; c++) {
                        const addr = XLSX.utils.encode_cell({ r, c });
                        const cell = ws[addr];
                        if (cell && cell.t === 'n') sum += cell.v;
                    }
                }
                return sum;
            }

            // IF(condition, trueVal, falseVal)
            const ifMatch = formula.match(/^IF\((.+),(.+),(.+)\)$/i);
            if (ifMatch) {
                const condExpr = evaluateExpression(ifMatch[1].trim(), ws);
                const trueVal = evaluateExpression(ifMatch[2].trim(), ws);
                const falseVal = evaluateExpression(ifMatch[3].trim(), ws);
                if (condExpr !== null) return condExpr ? trueVal : falseVal;
                return null;
            }

            // Arithmetik: REF+REF, REF-REF, etc.
            const parts = formula.split(/([+\-])/);
            if (parts.length >= 3) {
                let result = evaluateExpression(parts[0].trim(), ws);
                if (result === null) return null;
                for (let i = 1; i < parts.length; i += 2) {
                    const op = parts[i];
                    const val = evaluateExpression(parts[i + 1]?.trim(), ws);
                    if (val === null) return null;
                    result = op === '+' ? result + val : result - val;
                }
                return result;
            }

            // Einzelne Zellreferenz
            return evaluateExpression(formula.trim(), ws);
        }

        function evaluateExpression(expr, ws) {
            if (!expr) return null;
            const num = parseFloat(expr);
            if (!isNaN(num) && expr.match(/^-?\d+(\.\d+)?$/)) return num;

            // -REF*factor
            const negRefMatch = expr.match(/^-([A-Z]+\d+)\*(\d+(\.\d+)?)$/i);
            if (negRefMatch) {
                const cell = ws[negRefMatch[1]];
                if (cell && cell.t === 'n') return -cell.v * parseFloat(negRefMatch[2]);
                return null;
            }

            // Einzelne Zellreferenz
            if (expr.match(/^[A-Z]+\d+$/i)) {
                const cell = ws[expr];
                if (cell && cell.t === 'n') return cell.v;
                return null;
            }
            return null;
        }

        // =====================================================
        // FILE LOADER (mit Formelauflösung)
        // =====================================================
        const FileLoader = {
            async loadFile(filename, testDataFolder) {
                const path = CONFIG.testFilesPath + testDataFolder + filename;
                const isExcel = filename.endsWith('.xlsx');

                const response = await fetch(path);
                if (!response.ok) throw new Error(`HTTP ${response.status} - ${filename}`);

                if (isExcel) {
                    const arrayBuffer = await response.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array', cellFormula: true, sheetStubs: true });
                    // Formeln auflösen
                    workbook.SheetNames.forEach(name => resolveFormulas(workbook.Sheets[name]));
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    return XLSX.utils.sheet_to_csv(firstSheet);
                } else {
                    return await response.text();
                }
            }
        };

        // =====================================================
        // VALIDATOREN
        // =====================================================
        const Validators = {
            // Phase 1: Universal Analyzer
            validatePhase1(result, sourceData) {
                const checks = {
                    jsonSchema: { passed: false, message: '', value: '' },
                    languagePreservation: { passed: false, message: '', value: '' },
                    scenariosDetected: { passed: false, message: '', value: '' },
                    periodsExtracted: { passed: false, message: '', value: '' },
                    reportTypePlausible: { passed: false, message: '', value: '' },
                    dataValuesPresent: { passed: false, message: '', value: '' }
                };

                try {
                    const hasAnalysis = result.analysis && typeof result.analysis === 'object';
                    const hasExtractedData = result.extractedData && typeof result.extractedData === 'object';
                    checks.jsonSchema.passed = hasAnalysis && hasExtractedData;
                    checks.jsonSchema.value = `analysis: ${hasAnalysis}, extractedData: ${hasExtractedData}`;
                } catch (e) { checks.jsonSchema.message = e.message; }

                try {
                    const sourceLabels = this._extractLabelsFromCSV(sourceData);
                    const resultLabels = this._extractLabelsFromResult(result);
                    const preserved = this._checkLabelPreservation(sourceLabels, resultLabels);
                    checks.languagePreservation.passed = preserved.ratio >= 0.8;
                    checks.languagePreservation.value = `${Math.round(preserved.ratio * 100)}% erhalten`;
                } catch (e) { checks.languagePreservation.value = 'Nicht prüfbar'; }

                try {
                    const scenarios = result.analysis?.scenarios || [];
                    checks.scenariosDetected.passed = Array.isArray(scenarios) && scenarios.length > 0;
                    checks.scenariosDetected.value = scenarios.join(', ') || 'Keine';
                } catch (e) { checks.scenariosDetected.value = 'Fehler'; }

                try {
                    const periods = result.analysis?.timeRange?.periods || result.analysis?.periods || [];
                    const hasPeriods = (Array.isArray(periods) && periods.length > 0) || result.analysis?.timeRange?.year;
                    checks.periodsExtracted.passed = hasPeriods;
                    checks.periodsExtracted.value = Array.isArray(periods) ? periods.slice(0, 3).join(', ') : (result.analysis?.timeRange?.year || 'Keine');
                } catch (e) { checks.periodsExtracted.value = 'Fehler'; }

                try {
                    const reportType = (result.analysis?.reportType || '').toLowerCase();
                    checks.reportTypePlausible.passed = reportType.length > 0;
                    checks.reportTypePlausible.value = result.analysis?.reportType || 'Nicht erkannt';
                } catch (e) { checks.reportTypePlausible.value = 'Fehler'; }

                try {
                    const hasData = result.extractedData?.normalized?.length > 0;
                    checks.dataValuesPresent.passed = hasData;
                    checks.dataValuesPresent.value = `${result.extractedData?.normalized?.length || 0} Positionen`;
                } catch (e) { checks.dataValuesPresent.value = 'Fehler'; }

                return checks;
            },

            // Phase 2: Variant Generator
            validatePhase2(result, templates) {
                const checks = {
                    variantCount: { passed: false, message: '', value: '' },
                    templateIdsValid: { passed: false, message: '', value: '' },
                    noDuplicates: { passed: false, message: '', value: '' },
                    dataFilterValid: { passed: false, message: '', value: '' },
                    uniqueValuePresent: { passed: false, message: '', value: '' }
                };

                const variants = result.variants || [];
                checks.variantCount.passed = variants.length >= 1 && variants.length <= 10;
                checks.variantCount.value = `${variants.length} Varianten`;

                const templateIds = new Set();
                if (templates) {
                    Object.values(templates.templates || {}).forEach(arr => arr.forEach(t => templateIds.add(t.template_id)));
                }
                const invalidIds = variants.map(v => v.templateId).filter(id => id && !templateIds.has(id));
                checks.templateIdsValid.passed = invalidIds.length === 0;
                checks.templateIdsValid.value = invalidIds.length === 0 ? 'Alle valide' : `Ungültig: ${invalidIds.join(', ')}`;

                const fingerprints = variants.map(v => `${v.templateId}:${v.dataFilter?.scenario || ''}:${v.dataFilter?.period || ''}`);
                const uniqueFingerprints = new Set(fingerprints);
                checks.noDuplicates.passed = fingerprints.length === uniqueFingerprints.size;
                checks.noDuplicates.value = fingerprints.length === uniqueFingerprints.size ? 'Keine Duplikate' : `${fingerprints.length - uniqueFingerprints.size} Duplikate`;

                const hasValidFilters = variants.every(v => v.dataFilter && typeof v.dataFilter === 'object');
                checks.dataFilterValid.passed = hasValidFilters;
                checks.dataFilterValid.value = hasValidFilters ? 'Alle valide' : 'Fehlerhafte Filter';

                const hasUniqueValues = variants.every(v => v.uniqueValue && v.uniqueValue.length > 0);
                checks.uniqueValuePresent.passed = hasUniqueValues;
                checks.uniqueValuePresent.value = hasUniqueValues ? 'Alle vorhanden' : 'Fehlende uniqueValues';

                return checks;
            },

            // Phase 3: DeterministicConfigGenerator (NEU — kein API-Call)
            validatePhase3(config, variant) {
                const checks = {
                    configGenerated: { passed: false, message: '', value: '' },
                    hasBars: { passed: false, message: '', value: '' },
                    labelsPreserved: { passed: false, message: '', value: '' },
                    layoutIdMatches: { passed: false, message: '', value: '' },
                    generatedByDeterministic: { passed: false, message: '', value: '' },
                    mathConsistent: { passed: false, message: '', value: '' }
                };

                // 1. Config wurde generiert
                checks.configGenerated.passed = config && typeof config === 'object';
                checks.configGenerated.value = config ? 'OK' : 'Fehlt';
                if (!config) return checks;

                // 2. Hat Bars/Segments/Categories
                const barCount = config.bars?.length || config.segments?.length || config.categories?.length || 0;
                checks.hasBars.passed = barCount > 0;
                checks.hasBars.value = `${barCount} Elemente`;

                // 3. Labels nicht leer
                const bars = config.bars || config.segments || config.categories || [];
                const labels = bars.map(b => b.label || b.name || '').filter(Boolean);
                checks.labelsPreserved.passed = labels.length > 0;
                checks.labelsPreserved.value = labels.length > 0 ? `${labels.length} Labels` : 'Keine Labels';

                // 4. Layout-ID stimmt
                checks.layoutIdMatches.passed = config._layoutId === variant?.templateId;
                checks.layoutIdMatches.value = config._layoutId || 'Fehlt';

                // 5. Generiert von Deterministic
                checks.generatedByDeterministic.passed = config._generatedBy === 'deterministic';
                checks.generatedByDeterministic.value = config._generatedBy || 'Unbekannt';

                // 6. Mathematische Konsistenz (Waterfall)
                if (config.bars && config.bars.length > 0 && config.bars[0]?.type) {
                    const mathResult = this._checkWaterfallMath(config.bars);
                    checks.mathConsistent.passed = mathResult.passed;
                    checks.mathConsistent.value = mathResult.value;
                } else {
                    checks.mathConsistent.passed = true;
                    checks.mathConsistent.value = 'N/A';
                }

                return checks;
            },

            // Phase 4: JS-Renderer (NEU — kein API-Call)
            validatePhase4(svgHtml, config) {
                const checks = {
                    svgGenerated: { passed: false, message: '', value: '' },
                    hasSvgElement: { passed: false, message: '', value: '' },
                    hasRects: { passed: false, message: '', value: '' },
                    hasLabels: { passed: false, message: '', value: '' },
                    noErrors: { passed: true, message: '', value: 'OK' }
                };

                checks.svgGenerated.passed = svgHtml && svgHtml.length > 0;
                checks.svgGenerated.value = svgHtml ? `${svgHtml.length} Zeichen` : 'Leer';

                if (!svgHtml) return checks;

                checks.hasSvgElement.passed = svgHtml.includes('<svg');
                checks.hasSvgElement.value = svgHtml.includes('<svg') ? 'OK' : 'Kein <svg>';

                const rectCount = (svgHtml.match(/<rect/g) || []).length;
                checks.hasRects.passed = rectCount > 0;
                checks.hasRects.value = `${rectCount} Rechtecke`;

                const textCount = (svgHtml.match(/<text/g) || []).length;
                checks.hasLabels.passed = textCount > 0;
                checks.hasLabels.value = `${textCount} Texte`;

                return checks;
            },

            // Phase 5: Feature-Integrität
            validateFeatures(config, templateDef) {
                const checks = {
                    featureBlockExists: { passed: false, message: '', value: '' },
                    allFeaturesDocumented: { passed: false, message: '', value: '' },
                    availabilityRespected: { passed: false, message: '', value: '' },
                    conflictsResolved: { passed: false, message: '', value: '' },
                    reasonFieldPresent: { passed: false, message: '', value: '' },
                    categoryConstraints: { passed: false, message: '', value: '' }
                };

                const features = config?.features;
                const available = templateDef?.availableFeatures || [];

                checks.featureBlockExists.passed = features && typeof features === 'object';
                checks.featureBlockExists.value = features ? 'Vorhanden' : 'Fehlt';
                if (!features) return checks;

                const featureIds = Object.keys(features);
                const missingFeatures = ALL_FEATURE_IDS.filter(id => !featureIds.includes(id));
                checks.allFeaturesDocumented.passed = missingFeatures.length === 0;
                checks.allFeaturesDocumented.value = missingFeatures.length === 0 ? `Alle ${ALL_FEATURE_IDS.length} dokumentiert` : `Fehlt: ${missingFeatures.join(', ')}`;

                const violatingFeatures = featureIds.filter(id => features[id]?.enabled && !available.includes(id));
                checks.availabilityRespected.passed = violatingFeatures.length === 0;
                checks.availabilityRespected.value = violatingFeatures.length === 0 ? 'Alle Features verfügbar' : `Nicht erlaubt: ${violatingFeatures.join(', ')}`;

                const conflictViolations = [];
                FEATURE_CONFLICTS.forEach(conflict => {
                    if (features[conflict.a]?.enabled && features[conflict.b]?.enabled) {
                        conflictViolations.push(`${conflict.a} + ${conflict.b}`);
                    }
                });
                checks.conflictsResolved.passed = conflictViolations.length === 0;
                checks.conflictsResolved.value = conflictViolations.length === 0 ? 'Keine Konflikte' : `Konflikte: ${conflictViolations.join(', ')}`;

                const missingReasons = featureIds.filter(id => features[id] && typeof features[id]._reason !== 'string');
                checks.reasonFieldPresent.passed = missingReasons.length === 0;
                checks.reasonFieldPresent.value = missingReasons.length === 0 ? 'Alle vorhanden' : `Fehlt bei: ${missingReasons.join(', ')}`;

                // Category-Constraints
                const templateId = config._layoutId;
                const category = TEMPLATE_CATEGORIES[templateId] || 'unknown';
                checks.categoryConstraints.passed = true;
                checks.categoryConstraints.value = `Kategorie: ${category}`;

                return checks;
            },

            _checkWaterfallMath(bars) {
                const startBars = bars.filter(b => b.type === 'start');
                const endBars = bars.filter(b => b.type === 'end' || b.type === 'subtotal');
                if (startBars.length === 0 || endBars.length === 0) return { passed: true, value: 'Keine Prüfung möglich' };

                const startVal = startBars.reduce((s, b) => s + (b.value || 0), 0);
                const increases = bars.filter(b => b.type === 'increase').reduce((s, b) => s + Math.abs(b.value || 0), 0);
                const decreases = bars.filter(b => b.type === 'decrease').reduce((s, b) => s + Math.abs(b.value || 0), 0);
                const endVal = endBars[endBars.length - 1]?.value || 0;
                const calculated = startVal + increases - decreases;
                const diff = Math.abs(calculated - endVal);
                const tolerance = Math.max(5, Math.abs(endVal) * 0.001);
                const passed = diff <= tolerance;

                return {
                    passed,
                    value: passed ? `Δ=${diff.toFixed(1)} (OK)` : `Δ=${diff.toFixed(1)} > ±${tolerance.toFixed(1)}`
                };
            },

            collectFeatureStatistics(phase5Results) {
                const stats = {
                    total: phase5Results.length,
                    activationRates: {},
                    bracketModes: {},
                    templateCoverage: {},
                    resolvedConflicts: [],
                    avgActiveFeatures: 0
                };
                let totalActive = 0;

                ALL_FEATURE_IDS.forEach(id => { stats.activationRates[id] = { enabled: 0, disabled: 0, rate: 0 }; });

                phase5Results.forEach(result => {
                    const features = result.features;
                    if (!features) return;
                    const templateId = result.templateId;
                    if (!stats.templateCoverage[templateId]) {
                        stats.templateCoverage[templateId] = {};
                        ALL_FEATURE_IDS.forEach(id => stats.templateCoverage[templateId][id] = 0);
                    }
                    let activeCount = 0;
                    ALL_FEATURE_IDS.forEach(id => {
                        if (features[id]?.enabled) {
                            stats.activationRates[id].enabled++;
                            stats.templateCoverage[templateId][id]++;
                            activeCount++;
                            if (id === 'bracket' && features[id].mode) {
                                stats.bracketModes[features[id].mode] = (stats.bracketModes[features[id].mode] || 0) + 1;
                            }
                        } else if (features[id]) {
                            stats.activationRates[id].disabled++;
                        }
                        if (features[id]?._reason && features[id]._reason.includes('Priorität')) {
                            stats.resolvedConflicts.push({ templateId, feature: id, reason: features[id]._reason });
                        }
                    });
                    totalActive += activeCount;
                });

                ALL_FEATURE_IDS.forEach(id => {
                    const total = stats.activationRates[id].enabled + stats.activationRates[id].disabled;
                    stats.activationRates[id].rate = total > 0 ? Math.round(stats.activationRates[id].enabled / total * 100) : 0;
                });
                stats.avgActiveFeatures = stats.total > 0 ? (totalActive / stats.total).toFixed(1) : 0;
                return stats;
            },

            _extractLabelsFromCSV(csvData) {
                const lines = csvData.split('\n');
                const labels = [];
                for (let i = 0; i < Math.min(lines.length, 30); i++) {
                    const cols = lines[i].split(/[,;]/);
                    if (cols[0] && isNaN(parseFloat(cols[0].replace(/[^0-9.-]/g, '')))) {
                        labels.push(cols[0].trim().replace(/"/g, ''));
                    }
                }
                return labels;
            },

            _extractLabelsFromResult(result) {
                const labels = [];
                const data = result.extractedData?.normalized || [];
                data.forEach(d => { if (d.label) labels.push(d.label); if (d.position) labels.push(d.position); });
                return labels;
            },

            _checkLabelPreservation(sourceLabels, resultLabels) {
                if (sourceLabels.length === 0 || resultLabels.length === 0) return { ratio: 1, changed: [] };
                const sourceLower = sourceLabels.map(l => l.toLowerCase());
                const preserved = resultLabels.filter(l =>
                    sourceLower.some(s => s.includes(l.toLowerCase()) || l.toLowerCase().includes(s))
                );
                return {
                    ratio: preserved.length / resultLabels.length,
                    changed: resultLabels.filter(l => !sourceLower.some(s => s.includes(l.toLowerCase()) || l.toLowerCase().includes(s)))
                };
            },

            // Phase 6: Edge-Case Tests (kein API-Call, rein client-seitig)
            validateEdgeCases() {
                const results = [];

                // ── Test 6.1: Extremwerte ──
                try {
                    const extremeConfig = {
                        title: 'Edge-Case: Extreme Values',
                        _chartType: 'waterfall',
                        bars: [
                            { label: 'Start', value: 1500000000, type: 'total' },
                            { label: 'Zero', value: 0, type: 'bridge' },
                            { label: 'Negative', value: -999999, type: 'bridge' },
                            { label: 'Tiny', value: 0.001, type: 'bridge' },
                            { label: 'End', value: 1499000001.001, type: 'total' }
                        ],
                        colors: { start: '#1B3A5C', end: '#1B3A5C', positive: '#2E7D32', negative: '#C62828', connector: '#CCCCCC' }
                    };
                    const normalized = normalizeConfigForRenderer(extremeConfig);
                    let renderOk = 'Nur Normalize';
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.style.cssText = 'position:absolute;left:-9999px;width:800px;height:500px;';
                        document.body.appendChild(tempDiv);
                        const svg = renderWaterfallChart(normalized, 800, 500, ['#2B5EA7', '#E63946']);
                        renderOk = svg && svg.includes('<svg') ? 'Normalize + Render OK' : 'Render leer';
                        document.body.removeChild(tempDiv);
                    } catch (re) { renderOk = 'Render-Fehler: ' + re.message; }
                    results.push({
                        testId: '6.1', testName: 'Extremwerte (1.5 Mrd, 0, negativ, 0.001)',
                        status: 'success',
                        checks: { extremeValues: { passed: true, value: renderOk } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.1', testName: 'Extremwerte',
                        status: 'error',
                        checks: { extremeValues: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                // ── Test 6.2: Lange Labels ──
                try {
                    const longLabelConfig = {
                        title: 'Edge-Case: Lange Labels',
                        _chartType: 'waterfall',
                        bars: [
                            { label: 'A'.repeat(120), value: 100, type: 'total' },
                            { label: 'Sonstige betriebliche Aufwendungen und Erträge aus Konsolidierung', value: -30, type: 'bridge' },
                            { label: 'End', value: 70, type: 'total' }
                        ],
                        colors: { start: '#1B3A5C', end: '#1B3A5C', positive: '#2E7D32', negative: '#C62828', connector: '#CCCCCC' }
                    };
                    const normalized = normalizeConfigForRenderer(longLabelConfig);
                    results.push({
                        testId: '6.2', testName: 'Lange Labels (120 Zeichen, langer Fachbegriff)',
                        status: 'success',
                        checks: { longLabels: { passed: true, value: 'Normalize OK, max Label: 120 Zeichen' } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.2', testName: 'Lange Labels',
                        status: 'error',
                        checks: { longLabels: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                // ── Test 6.3: Viele Balken (55) ──
                try {
                    const manyBars = [{ label: 'Start', value: 1000, type: 'total' }];
                    for (let i = 1; i <= 53; i++) {
                        manyBars.push({ label: 'Position ' + i, value: Math.round(Math.random() * 200 - 100), type: 'bridge' });
                    }
                    manyBars.push({ label: 'End', value: 0, type: 'total' });
                    const manyBarsConfig = {
                        title: 'Edge-Case: 55 Balken',
                        _chartType: 'waterfall',
                        bars: manyBars,
                        colors: { start: '#1B3A5C', end: '#1B3A5C', positive: '#2E7D32', negative: '#C62828', connector: '#CCCCCC' }
                    };
                    const normalized = normalizeConfigForRenderer(manyBarsConfig);
                    const barCount = normalized.bars ? normalized.bars.length : 0;
                    results.push({
                        testId: '6.3', testName: 'Viele Balken (55 Bars)',
                        status: 'success',
                        checks: { manyBars: { passed: true, value: barCount + ' Balken normalisiert' } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.3', testName: 'Viele Balken (55)',
                        status: 'error',
                        checks: { manyBars: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                // ── Test 6.4: Leere Daten ──
                try {
                    const emptyConfig = { title: 'Edge-Case: Empty', _chartType: 'waterfall', bars: [], colors: {} };
                    let emptyResult = 'Kein Crash';
                    try {
                        const normalized = normalizeConfigForRenderer(emptyConfig);
                        emptyResult = 'Normalize OK (bars: ' + (normalized.bars ? normalized.bars.length : 0) + ')';
                    } catch (ne) {
                        emptyResult = 'Normalize wirft Fehler (erwartet): ' + ne.message;
                    }
                    results.push({
                        testId: '6.4', testName: 'Leere Daten (0 Bars, leere Colors)',
                        status: 'success',
                        checks: { emptyData: { passed: true, value: emptyResult } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.4', testName: 'Leere Daten',
                        status: 'error',
                        checks: { emptyData: { passed: false, value: 'Unerwarteter Crash: ' + e.message } }
                    });
                }

                // ── Test 6.5: Feature-Konflikte ──
                try {
                    const conflictConfig = {
                        title: 'Edge-Case: Feature Conflicts',
                        _chartType: 'waterfall',
                        bars: [
                            { label: 'Start', value: 1000, type: 'total' },
                            { label: 'Delta', value: -200, type: 'bridge' },
                            { label: 'End', value: 800, type: 'total' }
                        ],
                        features: {
                            bracket: { enabled: true, fromIndex: 0, toIndex: 2, label: '+10%' },
                            arrows: { enabled: true }
                        },
                        colors: { start: '#1B3A5C', end: '#1B3A5C', positive: '#2E7D32', negative: '#C62828', connector: '#CCCCCC' }
                    };
                    const normalized = normalizeConfigForRenderer(conflictConfig);
                    const bracketActive = normalized.features?.bracket?.enabled || normalized.bracket?.enabled || false;
                    const arrowsActive = normalized.features?.arrows?.enabled || normalized.arrows?.enabled || false;
                    const bothActive = bracketActive && arrowsActive;
                    results.push({
                        testId: '6.5', testName: 'Feature-Konflikte (bracket + arrows)',
                        status: bothActive ? 'warning' : 'success',
                        checks: { featureConflicts: { passed: !bothActive, value: 'bracket=' + bracketActive + ', arrows=' + arrowsActive + (bothActive ? ' (Konflikt nicht aufgelöst)' : ' (OK)') } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.5', testName: 'Feature-Konflikte',
                        status: 'error',
                        checks: { featureConflicts: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                // ── Test 6.6: Unbekannter Template-Typ ──
                try {
                    const unknownResult = generateConfigFingerprint({ title: 'Test' }, 'unknown_type');
                    const isString = typeof unknownResult === 'string' && unknownResult.length > 0;
                    results.push({
                        testId: '6.6', testName: 'Unbekannter Template-Typ (generateConfigFingerprint)',
                        status: isString ? 'success' : 'warning',
                        checks: { unknownTemplate: { passed: isString, value: 'Fingerprint: ' + (unknownResult || '(leer)').substring(0, 60) } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.6', testName: 'Unbekannter Template-Typ',
                        status: 'error',
                        checks: { unknownTemplate: { passed: false, value: 'Crash: ' + e.message } }
                    });
                }

                // ── Test 6.7: Template-Abdeckung ──
                try {
                    let waterfallCount = 0, barCount = 0, stackedCount = 0;
                    if (typeof TemplateLoader !== 'undefined') {
                        const allTemplates = TemplateLoader.getAll ? TemplateLoader.getAll() : null;
                        if (allTemplates) {
                            waterfallCount = (allTemplates.waterfall || []).length;
                            barCount = (allTemplates.bar || []).length;
                            stackedCount = (allTemplates.stacked_bar || []).length;
                        } else if (TemplateLoader.templates && Array.isArray(TemplateLoader.templates)) {
                            TemplateLoader.templates.forEach(function(t) {
                                if (t.chart_type === 'waterfall') waterfallCount++;
                                else if (t.chart_type === 'bar') barCount++;
                                else if (t.chart_type === 'stacked_bar') stackedCount++;
                            });
                        }
                    }
                    if (waterfallCount === 0 && state.templates) {
                        waterfallCount = (state.templates.templates?.waterfall || []).length;
                        barCount = (state.templates.templates?.bar || []).length;
                        stackedCount = (state.templates.templates?.stacked_bar || []).length;
                    }
                    const total = waterfallCount + barCount + stackedCount;
                    const hasAll = waterfallCount > 0 && barCount > 0 && stackedCount > 0;
                    results.push({
                        testId: '6.7', testName: 'Template-Abdeckung (alle Typen)',
                        status: hasAll ? 'success' : (total > 0 ? 'warning' : 'error'),
                        checks: { templateCoverage: { passed: hasAll, value: 'WF=' + waterfallCount + ', Bar=' + barCount + ', SB=' + stackedCount + ' (Gesamt: ' + total + ')' } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.7', testName: 'Template-Abdeckung',
                        status: 'error',
                        checks: { templateCoverage: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                // ── Test 6.8: normalizeConfigForRenderer mit leeren features ──
                try {
                    const noFeaturesConfig = {
                        title: 'Edge-Case: Leere Features',
                        _chartType: 'waterfall',
                        bars: [
                            { label: 'Start', value: 500, type: 'total' },
                            { label: 'Delta', value: -100, type: 'bridge' },
                            { label: 'End', value: 400, type: 'total' }
                        ],
                        features: {},
                        colors: { start: '#1B3A5C', end: '#1B3A5C', positive: '#2E7D32', negative: '#C62828', connector: '#CCCCCC' }
                    };
                    const normalized = normalizeConfigForRenderer(noFeaturesConfig);
                    const hasNoBracket = !normalized.bracket;
                    results.push({
                        testId: '6.8', testName: 'normalizeConfig: Leere features{}',
                        status: hasNoBracket ? 'success' : 'warning',
                        checks: { emptyFeatures: { passed: hasNoBracket, value: 'bracket=' + !!normalized.bracket + ', bars=' + (normalized.bars?.length || 0) } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.8', testName: 'normalizeConfig: Leere features',
                        status: 'error',
                        checks: { emptyFeatures: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                // ── Test 6.9: normalizeConfig mit unbekanntem Feature ──
                try {
                    const unknownFeatureConfig = {
                        title: 'Edge-Case: Unknown Feature',
                        _chartType: 'waterfall',
                        bars: [
                            { label: 'Start', value: 1000, type: 'total' },
                            { label: 'End', value: 800, type: 'total' }
                        ],
                        features: { unknownFeature: { enabled: true, foo: 'bar' } },
                        colors: { start: '#1B3A5C', end: '#1B3A5C', positive: '#2E7D32', negative: '#C62828', connector: '#CCCCCC' }
                    };
                    const normalized = normalizeConfigForRenderer(unknownFeatureConfig);
                    results.push({
                        testId: '6.9', testName: 'normalizeConfig: Unbekanntes Feature (ignoriert)',
                        status: 'success',
                        checks: { unknownFeature: { passed: true, value: 'Kein Crash, bars=' + (normalized.bars?.length || 0) } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.9', testName: 'normalizeConfig: Unbekanntes Feature',
                        status: 'error',
                        checks: { unknownFeature: { passed: false, value: 'Crash: ' + e.message } }
                    });
                }

                // ── Test 6.10: Bar Chart Edge-Case (leere categories) ──
                try {
                    const emptyBarConfig = {
                        title: 'Edge-Case: Bar ohne Categories',
                        _chartType: 'bar',
                        periods: [{ label: '2025', color: '#333' }],
                        categories: []
                    };
                    let renderResult = 'Kein Crash';
                    try {
                        const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        tempSvg.id = 'edgeTest_bar_empty';
                        tempSvg.setAttribute('viewBox', '0 0 1200 500');
                        tempSvg.style.cssText = 'position:absolute;left:-9999px';
                        document.body.appendChild(tempSvg);
                        renderBarChart('edgeTest_bar_empty', emptyBarConfig);
                        renderResult = tempSvg.innerHTML.length > 0 ? 'Renderer gab Fehlermeldung aus' : 'Leer (erwartet)';
                        document.body.removeChild(tempSvg);
                    } catch (re) {
                        renderResult = 'Render-Fehler (akzeptabel): ' + re.message.substring(0, 80);
                    }
                    results.push({
                        testId: '6.10', testName: 'Bar Chart: Leere categories[]',
                        status: 'success',
                        checks: { emptyBarCategories: { passed: true, value: renderResult } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.10', testName: 'Bar Chart: Leere categories',
                        status: 'error',
                        checks: { emptyBarCategories: { passed: false, value: 'Crash: ' + e.message } }
                    });
                }

                // ── Test 6.11: Stacked Bar Edge-Case (leere segments) ──
                try {
                    const emptyStackedConfig = {
                        title: 'Edge-Case: Stacked Bar ohne Segments',
                        _chartType: 'stacked-bar',
                        categories: [{ label: 'Q1' }, { label: 'Q2' }],
                        segments: []
                    };
                    let renderResult = 'Kein Crash';
                    try {
                        const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        tempSvg.id = 'edgeTest_stacked_empty';
                        tempSvg.setAttribute('viewBox', '0 0 1200 500');
                        tempSvg.style.cssText = 'position:absolute;left:-9999px';
                        document.body.appendChild(tempSvg);
                        renderStackedBarChart('edgeTest_stacked_empty', emptyStackedConfig);
                        renderResult = tempSvg.innerHTML.length > 0 ? 'Renderer gab Fehlermeldung aus' : 'Leer (erwartet)';
                        document.body.removeChild(tempSvg);
                    } catch (re) {
                        renderResult = 'Render-Fehler (akzeptabel): ' + re.message.substring(0, 80);
                    }
                    results.push({
                        testId: '6.11', testName: 'Stacked Bar: Leere segments[]',
                        status: 'success',
                        checks: { emptyStackedSegments: { passed: true, value: renderResult } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.11', testName: 'Stacked Bar: Leere segments',
                        status: 'error',
                        checks: { emptyStackedSegments: { passed: false, value: 'Crash: ' + e.message } }
                    });
                }

                // ── Test 6.12: Bar Chart mit extremen Periodenzahl ──
                try {
                    const manyPeriodsConfig = {
                        title: 'Edge-Case: 20 Perioden',
                        _chartType: 'bar',
                        periods: Array.from({length: 20}, (_, i) => ({ label: 'M' + (i+1), color: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0') })),
                        categories: [{ name: 'Revenue', values: Array.from({length: 20}, () => Math.round(Math.random() * 5000)) }]
                    };
                    let renderResult = 'Kein Crash';
                    try {
                        const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        tempSvg.id = 'edgeTest_bar_many';
                        tempSvg.setAttribute('viewBox', '0 0 1200 500');
                        tempSvg.style.cssText = 'position:absolute;left:-9999px';
                        document.body.appendChild(tempSvg);
                        renderBarChart('edgeTest_bar_many', manyPeriodsConfig);
                        const hasContent = tempSvg.innerHTML.includes('<rect');
                        renderResult = hasContent ? 'SVG mit Balken generiert' : 'SVG leer';
                        document.body.removeChild(tempSvg);
                    } catch (re) {
                        renderResult = 'Render-Fehler: ' + re.message.substring(0, 80);
                    }
                    results.push({
                        testId: '6.12', testName: 'Bar Chart: 20 Perioden (Überlappungstest)',
                        status: renderResult.includes('generiert') ? 'success' : 'warning',
                        checks: { manyPeriods: { passed: renderResult.includes('generiert'), value: renderResult } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.12', testName: 'Bar Chart: 20 Perioden',
                        status: 'error',
                        checks: { manyPeriods: { passed: false, value: 'Crash: ' + e.message } }
                    });
                }

                // ── Test 6.13: Fingerprint-Kollision (gleicher Fingerprint = Dedup) ──
                try {
                    const configA = { title: 'Test Config', _chartType: 'waterfall', _perspectiveName: 'structure',
                        bars: [{ label: 'Start', value: 100 }, { label: 'Delta', value: -20 }, { label: 'End', value: 80 }] };
                    const configB = { title: 'Test Config', _chartType: 'waterfall', _perspectiveName: 'structure',
                        bars: [{ label: 'Start', value: 100 }, { label: 'Delta', value: -20 }, { label: 'End', value: 80 }] };
                    const configC = { title: 'Andere Config', _chartType: 'waterfall', _perspectiveName: 'variance',
                        bars: [{ label: 'Start', value: 500 }, { label: 'End', value: 400 }] };
                    const fpA = generateConfigFingerprint(configA, 'waterfall');
                    const fpB = generateConfigFingerprint(configB, 'waterfall');
                    const fpC = generateConfigFingerprint(configC, 'waterfall');
                    const dupDetected = fpA === fpB;
                    const uniqueDetected = fpA !== fpC;
                    results.push({
                        testId: '6.13', testName: 'Fingerprint: Duplikat-Erkennung',
                        status: (dupDetected && uniqueDetected) ? 'success' : 'warning',
                        checks: { fingerprint: { passed: dupDetected && uniqueDetected, value: 'A==B: ' + dupDetected + ', A!=C: ' + uniqueDetected } }
                    });
                } catch (e) {
                    results.push({
                        testId: '6.13', testName: 'Fingerprint-Erkennung',
                        status: 'error',
                        checks: { fingerprint: { passed: false, value: 'Fehler: ' + e.message } }
                    });
                }

                return results;
            }
        };

        // =====================================================
        // PHASE 6: EDGE-CASE TEST RUNNER (Standalone, kein API-Key nötig)
        // =====================================================
        async function runEdgeCaseTests() {
            log('info', 'Starte Phase 6: Edge-Case Tests (kein API-Key benötigt)...');

            // Lade Templates falls noch nicht vorhanden
            if (!state.templates) {
                try {
                    const templatesResponse = await fetch(CONFIG.templatesPath);
                    state.templates = await templatesResponse.json();
                    if (typeof TemplateLoader !== 'undefined' && !TemplateLoader.templates) {
                        TemplateLoader.templates = [];
                        Object.values(state.templates.templates || {}).forEach(function(arr) {
                            arr.forEach(function(t) { TemplateLoader.templates.push(t); });
                        });
                    }
                    log('success', 'Templates geladen (' + state.templates.total_templates + ' Templates)');
                } catch (e) {
                    log('warning', 'Templates konnten nicht geladen werden: ' + e.message);
                }
            }

            const startTime = Date.now();
            const edgeCaseResults = Validators.validateEdgeCases();

            // Ergebnisse in State speichern
            state.results.phase6 = [];
            let passed = 0, warnings = 0, failed = 0;

            edgeCaseResults.forEach(function(result, idx) {
                state.results.phase6.push({
                    index: idx + 1,
                    filename: result.testId,
                    title: result.testName,
                    status: result.status,
                    checks: result.checks,
                    result: result
                });

                if (result.status === 'success') { passed++; state.stats.passed++; }
                else if (result.status === 'warning') { warnings++; state.stats.warnings++; }
                else { failed++; state.stats.failed++; }
                state.stats.total++;
            });

            state.stats.duration = Math.round((Date.now() - (state.startTime || startTime)) / 1000);
            updateStats();

            // Zeige Phase 6
            showPhase(6);

            log('success', 'Phase 6 abgeschlossen: ' + passed + ' bestanden, ' + warnings + ' Warnungen, ' + failed + ' fehlgeschlagen (' + edgeCaseResults.length + ' Tests, 0 API Calls)');
        }

        // =====================================================
        // INITIALISIERUNG
        // =====================================================
        async function init() {
            log('info', 'Initialisiere Test-Suite (Deterministische Architektur v3.1)...');

            const savedKey = localStorage.getItem('test_api_key');
            if (savedKey) document.getElementById('apiKeyInput').value = savedKey;

            const savedProvider = localStorage.getItem('test_provider');
            if (savedProvider) document.getElementById('providerSelect').value = savedProvider;

            const totalFiles = Object.values(CONFIG.testDataSets).reduce((sum, s) => sum + s.allFiles.length, 0);
            log('success', `${totalFiles} Testdateien verfügbar (3 Sets: Testdaten_1/2/3)`);
            log('info', 'Pipeline: PROMPT-1 (KI) → PROMPT-2 (KI) → DeterministicConfigGenerator (JS) → JS-Renderer (SVG)');
        }

        function getTestFiles(testDataSet, testMode) {
            const setConfig = CONFIG.testDataSets[testDataSet];
            if (!setConfig) throw new Error(`Unbekanntes Testdaten-Set: ${testDataSet}`);
            return testMode === 'quick' ? setConfig.quickFiles : setConfig.allFiles;
        }

        function getTestDataFolder(testDataSet) {
            return CONFIG.testDataSets[testDataSet]?.folder || 'Testdaten_1/';
        }

        // =====================================================
        // TEST RUNNER
        // =====================================================
        async function startTests() {
            const apiKey = document.getElementById('apiKeyInput').value;
            const provider = document.getElementById('providerSelect').value;
            const testMode = document.getElementById('testModeSelect').value;
            const chartTypeFilter = document.getElementById('chartTypeFilter').value;
            const testDataSet = document.getElementById('testDataSelect').value;
            const testDataFolder = getTestDataFolder(testDataSet);

            if (!apiKey) {
                log('error', 'Bitte API Key eingeben!');
                return;
            }

            localStorage.setItem('test_api_key', apiKey);
            localStorage.setItem('test_provider', provider);

            // Nutze den globalen APIClient aus api-client.js
            APIClient.apiKey = apiKey;
            APIClient.provider = provider;

            state.isRunning = true;
            state.aborted = false;
            state.startTime = Date.now();
            state.stats = { total: 0, passed: 0, warnings: 0, failed: 0, duration: 0, apiCalls: 0 };
            state.results = { phase1: [], phase2: [], phase3: [], phase4: [], phase5: [], phase6: [] };

            document.getElementById('btnStartTests').disabled = true;
            document.getElementById('progressContainer').style.display = 'block';

            let testFiles = getTestFiles(testDataSet, testMode);

            log('info', `Starte ${testMode} mit ${testFiles.length} Dateien (${testDataSet}, Provider: ${provider})`);

            try {
                // Lade Templates + Farbschema über globale Loader
                const templatesResponse = await fetch(CONFIG.templatesPath);
                state.templates = await templatesResponse.json();
                // Stelle sicher, dass TemplateLoader die Templates hat
                if (typeof TemplateLoader !== 'undefined' && TemplateLoader.templates) {
                    // Bereits geladen
                } else if (typeof TemplateLoader !== 'undefined') {
                    TemplateLoader.templates = [];
                    Object.values(state.templates.templates || {}).forEach(arr => {
                        arr.forEach(t => TemplateLoader.templates.push(t));
                    });
                }
                log('success', `Templates geladen (${state.templates.total_templates} Templates)`);

                // Lade Farbschema
                try {
                    const csResp = await fetch(CONFIG.colorSchemesPath);
                    const csData = await csResp.json();
                    state.colorScheme = csData.schemes?.[0]?.colors || ['#2B5EA7', '#E63946', '#457B9D', '#F4A261', '#2A9D8F', '#264653'];
                } catch (e) {
                    state.colorScheme = ['#2B5EA7', '#E63946', '#457B9D', '#F4A261', '#2A9D8F', '#264653'];
                }

                // Lade PROMPT-1 direkt per Fetch (nicht im PromptLoader registriert)
                const p1Response = await fetch(CONFIG.promptsPath + 'PROMPT-1-UNIVERSAL-ANALYZER.md');
                if (!p1Response.ok) throw new Error(`PROMPT-1 nicht gefunden (${p1Response.status})`);
                state.analyzerPrompt = await p1Response.text();
                log('success', `PROMPT-1 geladen (${state.analyzerPrompt.length} Zeichen)`);

                // Lade PROMPT-2 über PromptLoader (dort registriert)
                if (testMode !== 'phase1') {
                    await PromptLoader.load('variant_generator');
                    log('success', `PROMPT-2 geladen (${PromptLoader.cache['variant_generator']?.size || '?'} Zeichen)`);
                }

                for (let i = 0; i < testFiles.length; i++) {
                    if (state.aborted) break;
                    const file = testFiles[i];
                    updateProgress(i + 1, testFiles.length);
                    await runTestForFile(file, i + 1, testMode, chartTypeFilter, testDataFolder);
                }

                // Phase 5: Feature-Statistiken berechnen
                if (state.results.phase5.length > 0) {
                    state.featureStats = Validators.collectFeatureStatistics(state.results.phase5);
                    log('success', `Phase 5: ${state.results.phase5.length} Feature-Validierungen (Ø ${state.featureStats.avgActiveFeatures} Features/Config)`);
                }

            } catch (error) {
                log('error', `Test-Fehler: ${error.message}`);
            }

            state.isRunning = false;
            state.stats.duration = Math.round((Date.now() - state.startTime) / 1000);
            updateStats();
            renderResults();
            document.getElementById('btnStartTests').disabled = false;

            log('success', `Tests abgeschlossen: ${state.stats.passed} bestanden, ${state.stats.warnings} Warnungen, ${state.stats.failed} fehlgeschlagen (${state.stats.apiCalls} API Calls, ${state.stats.duration}s)`);
        }

        async function runTestForFile(filename, index, testMode, chartTypeFilter, testDataFolder) {
            const startTime = Date.now();

            try {
                log('info', `[${index}] Lade ${filename}...`);
                const csvData = await FileLoader.loadFile(filename, testDataFolder);

                // ── Phase 1: Universal Analyzer (API-Call) ──
                log('info', `[${index}] Phase 1: Universal Analyzer...`);
                const analyzerPrompt = state.analyzerPrompt;
                const analyzerResponse = await APIClient.call(analyzerPrompt, `Analysiere diese Finanzdaten:\n\n${csvData}`);
                state.stats.apiCalls++;
                const analyzerResult = APIClient.parseJSON(analyzerResponse);

                const phase1Checks = Validators.validatePhase1(analyzerResult, csvData);
                const phase1Status = getStatusFromChecks(phase1Checks);
                state.results.phase1.push({ index, filename, status: phase1Status, checks: phase1Checks, result: analyzerResult });
                updateResultStats(phase1Status);

                if (testMode === 'phase1') { renderResults(); return; }

                // ── Phase 2: Variant Generator (API-Call, pro Chart-Typ) ──
                const chartTypes = chartTypeFilter === 'all' ? ['waterfall', 'bar', 'stacked-bar'] : [chartTypeFilter];
                const analysisResult = { parsed: analyzerResult };

                for (const chartType of chartTypes) {
                    if (state.aborted) break;

                    log('info', `[${index}] Phase 2: Variant Generator (${chartType})...`);
                    const variantPrompt = PromptLoader.cache['variant_generator']?.content || PromptLoader.cache['variant_generator'];
                    const variantInput = JSON.stringify({
                        analysisResult: analyzerResult,
                        selectedChartType: chartType,
                        templateLibrary: state.templates
                    }, null, 2);

                    const variantResponse = await APIClient.call(variantPrompt, variantInput);
                    state.stats.apiCalls++;
                    const variantResult = APIClient.parseJSON(variantResponse);

                    const phase2Checks = Validators.validatePhase2(variantResult, state.templates);
                    const phase2Status = getStatusFromChecks(phase2Checks);
                    state.results.phase2.push({ index, filename, chartType, status: phase2Status, checks: phase2Checks, result: variantResult });
                    updateResultStats(phase2Status);

                    if (testMode === 'phase2') continue;

                    // ── Phase 3: DeterministicConfigGenerator (KEIN API-Call) ──
                    const variants = variantResult.variants || [];
                    for (const variant of variants.slice(0, 5)) {
                        if (state.aborted) break;

                        log('info', `[${index}] Phase 3: DeterministicConfig (${variant.templateId})...`);

                        let config;
                        try {
                            config = DeterministicConfigGenerator.generateConfig(variant, analysisResult, state.colorScheme);
                        } catch (e) {
                            log('error', `[${index}] Config-Fehler (${variant.templateId}): ${e.message}`);
                            state.results.phase3.push({
                                index, filename, chartType, templateId: variant.templateId,
                                title: variant.title, status: 'error',
                                checks: { configGenerated: { passed: false, value: e.message } },
                                config: null
                            });
                            updateResultStats('error');
                            continue;
                        }

                        // Normalize
                        let normalizedConfig;
                        try {
                            normalizedConfig = normalizeConfigForRenderer(config);
                        } catch (e) {
                            normalizedConfig = config;
                        }

                        const phase3Checks = Validators.validatePhase3(normalizedConfig, variant);
                        const phase3Status = getStatusFromChecks(phase3Checks);
                        state.results.phase3.push({
                            index, filename, chartType, templateId: variant.templateId,
                            title: variant.title, status: phase3Status,
                            checks: phase3Checks, config: normalizedConfig
                        });
                        updateResultStats(phase3Status);

                        // ── Phase 4: JS-Renderer (KEIN API-Call) ──
                        if (testMode === 'phase3') continue;

                        log('info', `[${index}] Phase 4: JS-Render (${variant.templateId})...`);
                        let svgHtml = '';
                        try {
                            const tempDiv = document.createElement('div');
                            tempDiv.style.cssText = 'position:absolute;left:-9999px;width:800px;height:500px;';
                            document.body.appendChild(tempDiv);

                            const templateDef = findTemplate(variant.templateId);
                            const renderChartType = (templateDef?.chart_type || chartType).replace('-', '_');

                            if (renderChartType === 'waterfall') {
                                svgHtml = renderWaterfallChart(normalizedConfig, tempDiv.clientWidth, tempDiv.clientHeight, state.colorScheme);
                            } else if (renderChartType === 'bar') {
                                svgHtml = renderBarChart(normalizedConfig, tempDiv.clientWidth, tempDiv.clientHeight, state.colorScheme);
                            } else if (renderChartType === 'stacked_bar' || renderChartType === 'stacked-bar') {
                                svgHtml = renderStackedBarChart(normalizedConfig, tempDiv.clientWidth, tempDiv.clientHeight, state.colorScheme);
                            }

                            document.body.removeChild(tempDiv);
                        } catch (e) {
                            log('warning', `[${index}] Render-Fehler (${variant.templateId}): ${e.message}`);
                        }

                        const phase4Checks = Validators.validatePhase4(svgHtml, normalizedConfig);
                        const phase4Status = getStatusFromChecks(phase4Checks);
                        state.results.phase4.push({
                            index, filename, chartType, templateId: variant.templateId,
                            title: variant.title, status: phase4Status,
                            checks: phase4Checks, svgLength: svgHtml.length
                        });
                        updateResultStats(phase4Status);

                        // ── Phase 5: Feature-Integrität (nur Waterfall) ──
                        if (variant.templateId?.startsWith('WF-') && normalizedConfig?.features) {
                            const templateDef = findTemplate(variant.templateId);
                            const featureChecks = Validators.validateFeatures(normalizedConfig, templateDef);
                            const featureStatus = getStatusFromChecks(featureChecks);
                            state.results.phase5.push({
                                index, filename, templateId: variant.templateId,
                                title: variant.title, status: featureStatus,
                                checks: featureChecks, features: normalizedConfig.features
                            });
                        }
                    }
                }

            } catch (error) {
                log('error', `[${index}] Fehler: ${error.message}`);
                updateResultStats('error');
            }

            renderResults();
        }

        function findTemplate(templateId) {
            if (!state.templates) return null;
            for (const [type, templates] of Object.entries(state.templates.templates || {})) {
                const found = templates.find(t => t.template_id === templateId);
                if (found) return found;
            }
            return null;
        }

        function getStatusFromChecks(checks) {
            const values = Object.values(checks);
            const failed = values.filter(c => !c.passed).length;
            if (failed === 0) return 'success';
            if (failed <= 2) return 'warning';
            return 'error';
        }

        function updateResultStats(status) {
            state.stats.total++;
            if (status === 'success') state.stats.passed++;
            else if (status === 'warning') state.stats.warnings++;
            else state.stats.failed++;
            updateStats();
        }

        // =====================================================
        // UI UPDATES
        // =====================================================
        function updateStats() {
            document.getElementById('statTotal').textContent = state.stats.total;
            document.getElementById('statPassed').textContent = state.stats.passed;
            document.getElementById('statWarnings').textContent = state.stats.warnings;
            document.getElementById('statFailed').textContent = state.stats.failed;
            document.getElementById('statDuration').textContent = state.stats.duration + 's';
            document.getElementById('statApiCalls').textContent = state.stats.apiCalls;
        }

        function updateProgress(current, total) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressLabel').textContent = `${current} von ${total} Dateien`;
            document.getElementById('progressPercent').textContent = percent + '%';
        }

        function showPhase(phase) {
            state.currentPhase = phase;
            document.querySelectorAll('.phase-tab').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.phase) === phase);
            });
            const titles = {
                1: 'Phase 1: Universal Analyzer (KI)',
                2: 'Phase 2: Variant Generator (KI)',
                3: 'Phase 3: DeterministicConfigGenerator (JS)',
                4: 'Phase 4: JS-Renderer (SVG)',
                5: 'Phase 5: Feature-Integrität',
                6: 'Phase 6: Edge-Cases'
            };
            document.getElementById('resultsTitle').textContent = titles[phase];
            document.querySelector('.validation-title').textContent = `Validierungs-Checks (${titles[phase]})`;
            renderResults();

            const dashboard = document.getElementById('featureDashboard');
            if (dashboard) {
                dashboard.style.display = (phase === 5) ? 'block' : 'none';
                if (phase === 5 && state.featureStats) renderFeatureDashboard(state.featureStats);
            }
        }

        function renderResults() {
            const results = state.results[`phase${state.currentPhase}`] || [];
            const body = document.getElementById('resultsBody');

            document.getElementById('resultsCount').textContent = `${results.length} Tests`;
            for (let p = 1; p <= 6; p++) {
                document.getElementById(`phase${p}Count`).textContent = state.results[`phase${p}`].length;
            }

            if (results.length === 0) {
                body.innerHTML = `<div style="padding: 40px; text-align: center; color: #64748b;">Keine Tests in Phase ${state.currentPhase}.</div>`;
                return;
            }

            body.innerHTML = results.map((r, idx) => {
                let passed = 0, failed = 0;
                if (r.checks && typeof r.checks === 'object') {
                    const values = Object.values(r.checks);
                    passed = values.filter(c => c.passed).length;
                    failed = values.length - passed;
                }

                let extraInfo = '';
                if (state.currentPhase === 2) extraInfo = r.chartType || '';
                if (state.currentPhase >= 3) extraInfo = r.templateId || '';

                return `
                    <div class="test-row">
                        <span class="test-index">#${r.index}</span>
                        <span class="test-file" title="${r.filename}${r.title ? ' - ' + r.title : ''}">${r.title || r.filename}</span>
                        <span class="test-status ${r.status}">
                            ${r.status === 'success' ? '✓' : r.status === 'warning' ? '⚠' : '✗'} ${r.status}
                        </span>
                        <span style="color: #64748b; font-size: 12px;">${extraInfo}</span>
                        <span class="test-checks"><span class="passed">${passed}✓</span> / <span class="failed">${failed}✗</span></span>
                        <button class="btn-details" onclick="showDetails(${state.currentPhase}, ${idx})">Details</button>
                    </div>
                `;
            }).join('');

            if (results.length > 0 && results[0].checks) renderValidationChecks(results[0].checks);
        }

        function renderValidationChecks(checks) {
            const grid = document.getElementById('checkGrid');
            grid.innerHTML = Object.entries(checks).map(([name, check]) => `
                <div class="check-item">
                    <div class="check-icon ${check.passed ? 'pass' : 'fail'}">${check.passed ? '✓' : '✗'}</div>
                    <span class="check-name">${formatCheckName(name)}</span>
                    <span class="check-value">${check.value}</span>
                </div>
            `).join('');
        }

        function renderFeatureDashboard(stats) {
            const barsEl = document.getElementById('featureActivationBars');
            if (barsEl) {
                const featureColors = {
                    bracket: '#22c55e', scaleBreak: '#eab308', categoryBrackets: '#38bdf8',
                    arrows: '#ef4444', benchmarkLines: '#a855f7', negativeBridges: '#f97316', grouping: '#06b6d4'
                };
                barsEl.innerHTML = ALL_FEATURE_IDS.map(id => {
                    const rate = stats.activationRates[id]?.rate || 0;
                    const enabled = stats.activationRates[id]?.enabled || 0;
                    const total = enabled + (stats.activationRates[id]?.disabled || 0);
                    const color = featureColors[id] || '#38bdf8';
                    return `
                        <div class="feature-bar-row">
                            <span class="feature-bar-name">${id}</span>
                            <div class="feature-bar-track">
                                <div class="feature-bar-fill" style="width: ${rate}%; background: ${color};">${rate > 15 ? `${enabled}/${total}` : ''}</div>
                            </div>
                            <span class="feature-bar-rate">${rate}%</span>
                        </div>
                    `;
                }).join('');
            }

            const bracketEl = document.getElementById('bracketModeChart');
            if (bracketEl && stats.bracketModes) {
                const modes = Object.entries(stats.bracketModes).sort((a, b) => b[1] - a[1]);
                const maxCount = modes.length > 0 ? modes[0][1] : 1;
                bracketEl.innerHTML = modes.length > 0 ? modes.map(([mode, count]) => `
                    <div class="bracket-mode-item">
                        <span class="bracket-mode-label">${mode}</span>
                        <div class="bracket-mode-bar"><div class="bracket-mode-fill" style="width: ${(count / maxCount * 100)}%;"></div></div>
                        <span class="bracket-mode-count">${count}</span>
                    </div>
                `).join('') : '<div style="color: #64748b; font-size: 13px;">Keine Bracket-Daten</div>';
            }

            const conflictsEl = document.getElementById('conflictsLog');
            if (conflictsEl) {
                const uniqueConflicts = [];
                const seen = new Set();
                (stats.resolvedConflicts || []).forEach(c => {
                    const key = `${c.feature}:${c.reason}`;
                    if (!seen.has(key)) { seen.add(key); uniqueConflicts.push(c); }
                });
                conflictsEl.innerHTML = uniqueConflicts.length > 0 ? uniqueConflicts.map(c => `
                    <div class="conflict-item">
                        <span class="conflict-icon">⚡</span>
                        <span><strong>${c.feature}</strong> deaktiviert bei ${c.templateId}: ${c.reason}</span>
                    </div>
                `).join('') : '<div style="color: #64748b; font-size: 13px;">Keine Konflikte aufgelöst</div>';
            }

            const heatmapEl = document.getElementById('templateHeatmap');
            if (heatmapEl && stats.templateCoverage) {
                const templates = Object.keys(stats.templateCoverage).sort();
                const shortNames = { bracket: 'BRK', scaleBreak: 'SB', categoryBrackets: 'CB', arrows: 'ARR', benchmarkLines: 'BL', negativeBridges: 'NB', grouping: 'GRP' };
                let html = '<table class="heatmap-table"><thead><tr><th>Template</th>';
                ALL_FEATURE_IDS.forEach(id => { html += `<th>${shortNames[id] || id}</th>`; });
                html += '</tr></thead><tbody>';
                templates.forEach(tid => {
                    const category = TEMPLATE_CATEGORIES[tid] || '';
                    html += `<tr><td style="text-align:left;color:#e2e8f0;font-weight:500;">${tid} <span style="color:#64748b;font-size:10px;">${category}</span></td>`;
                    ALL_FEATURE_IDS.forEach(id => {
                        const count = stats.templateCoverage[tid][id] || 0;
                        const templateDef = findTemplate(tid);
                        const available = templateDef?.availableFeatures || [];
                        const isAvailable = available.includes(id);
                        if (!isAvailable) html += `<td><span class="heatmap-cell unavailable">—</span></td>`;
                        else if (count > 0) html += `<td><span class="heatmap-cell active">${count}</span></td>`;
                        else html += `<td><span class="heatmap-cell inactive">0</span></td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table>';
                heatmapEl.innerHTML = html;
            }

            const featureRateEl = document.getElementById('statFeatureRate');
            if (featureRateEl) featureRateEl.textContent = stats.avgActiveFeatures;

            const integrityEl = document.getElementById('statIntegrity');
            if (integrityEl && state.results.phase5.length > 0) {
                const passed = state.results.phase5.filter(r => r.status === 'success').length;
                const total = state.results.phase5.length;
                const rate = Math.round(passed / total * 100);
                integrityEl.textContent = `${rate}%`;
                integrityEl.className = `stat-value ${rate === 100 ? 'success' : rate >= 80 ? 'warning' : 'error'}`;
            }
        }

        function formatCheckName(name) {
            const names = {
                jsonSchema: 'JSON-Schema valide', languagePreservation: 'Spracherhaltung',
                scenariosDetected: 'Szenarien erkannt', periodsExtracted: 'Perioden extrahiert',
                reportTypePlausible: 'Report-Typ plausibel', dataValuesPresent: 'Datenwerte vorhanden',
                variantCount: 'Varianten-Anzahl (1-10)', templateIdsValid: 'Template-IDs valide',
                noDuplicates: 'Keine Duplikate', dataFilterValid: 'dataFilter valide',
                uniqueValuePresent: 'uniqueValue vorhanden',
                configGenerated: 'Config generiert', hasBars: 'Daten-Elemente vorhanden',
                labelsPreserved: 'Labels vorhanden', layoutIdMatches: 'Layout-ID korrekt',
                generatedByDeterministic: 'Deterministisch generiert', mathConsistent: 'Mathematisch konsistent',
                svgGenerated: 'SVG generiert', hasSvgElement: '<svg> Element', hasRects: 'Rechtecke vorhanden',
                hasLabels: 'Text-Labels vorhanden', noErrors: 'Keine Fehler',
                featureBlockExists: 'Feature-Block vorhanden', allFeaturesDocumented: 'Alle 7 Features dokumentiert',
                availabilityRespected: 'Verfügbarkeit eingehalten', conflictsResolved: 'Konflikte aufgelöst',
                reasonFieldPresent: 'Begründungen vorhanden', categoryConstraints: 'Kategorie-Einschränkungen',
                extremeValues: 'Extremwerte verarbeitet', longLabels: 'Lange Labels verarbeitet',
                manyBars: 'Viele Balken (50+)', emptyData: 'Leere Daten behandelt',
                featureConflicts: 'Feature-Konflikte behandelt', unknownTemplate: 'Unbekannter Template-Typ',
                templateCoverage: 'Template-Abdeckung'
            };
            return names[name] || name;
        }

        function showDetails(phase, index) {
            const results = state.results[`phase${phase}`];
            const result = results[index];
            document.getElementById('modalTitle').textContent = `${result.filename} - Phase ${phase}${result.templateId ? ' (' + result.templateId + ')' : ''}`;
            document.getElementById('jsonViewer').textContent = JSON.stringify(result, null, 2);
            document.getElementById('modalOverlay').classList.add('visible');
        }

        function closeModal(event) {
            if (!event || event.target === document.getElementById('modalOverlay')) {
                document.getElementById('modalOverlay').classList.remove('visible');
            }
        }

        function log(type, message) {
            const body = document.getElementById('logBody');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">[${time}]</span>${message}`;
            body.insertBefore(entry, body.firstChild);
            while (body.children.length > 200) body.removeChild(body.lastChild);
        }

        function clearLog() { document.getElementById('logBody').innerHTML = ''; log('info', 'Log gelöscht'); }

        function stopTests() { state.aborted = true; log('warning', 'Tests werden abgebrochen...'); }

        function clearResults() {
            state.results = { phase1: [], phase2: [], phase3: [], phase4: [], phase5: [], phase6: [] };
            state.featureStats = null;
            state.stats = { total: 0, passed: 0, warnings: 0, failed: 0, duration: 0, apiCalls: 0 };
            updateStats(); renderResults();
            document.getElementById('progressContainer').style.display = 'none';
            log('info', 'Ergebnisse zurückgesetzt');
        }

        function exportResults() {
            const exportData = {
                timestamp: new Date().toISOString(),
                architecture: 'deterministic-v3.1',
                pipeline: 'PROMPT-1 (KI) → PROMPT-2 (KI) → DeterministicConfigGenerator (JS) → JS-Renderer (SVG)',
                stats: state.stats,
                featureStats: state.featureStats,
                results: state.results
            };
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pipeline-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            log('success', 'Ergebnisse exportiert');
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
