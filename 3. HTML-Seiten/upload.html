<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DATA-ANALYZER - Datei Upload</title>
    <!-- SheetJS for Excel file support -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #fafbfc;
            color: #374151;
            line-height: 1.6;
            padding: 40px 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 1px solid #e5e7eb;
        }

        h1 {
            color: #1f2937;
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #6b7280;
            font-size: 0.95rem;
        }

        /* Cards */
        .card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 16px;
        }

        /* API Key Section */
        .api-provider {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        .provider-btn {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6b7280;
        }

        .provider-btn:hover {
            border-color: #d1d5db;
            background: #f9fafb;
        }

        .provider-btn.active {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #1d4ed8;
        }

        .provider-btn .logo {
            width: 20px;
            height: 20px;
        }

        .api-input-group {
            position: relative;
        }

        .api-input {
            width: 100%;
            padding: 12px 16px;
            padding-right: 100px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: 'Monaco', 'Menlo', monospace;
            transition: border-color 0.2s;
        }

        .api-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .api-input::placeholder {
            color: #9ca3af;
        }

        .api-status {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 4px;
        }

        .api-status.valid {
            background: #d1fae5;
            color: #065f46;
        }

        .api-status.invalid {
            background: #fee2e2;
            color: #991b1b;
        }

        .api-status.pending {
            background: #f3f4f6;
            color: #6b7280;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .status-dot.valid { background: #10b981; }
        .status-dot.invalid { background: #ef4444; }
        .status-dot.pending { background: #9ca3af; }

        .api-hint {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 8px;
        }

        .api-hint a {
            color: #3b82f6;
            text-decoration: none;
        }

        .api-hint a:hover {
            text-decoration: underline;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #fafbfc;
        }

        .upload-area:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .upload-area.dragover {
            border-color: #3b82f6;
            background: #eff6ff;
            border-style: solid;
        }

        .upload-area.has-file {
            border-color: #10b981;
            background: #f0fdf4;
            border-style: solid;
        }

        .upload-icon {
            margin-bottom: 16px;
        }

        .upload-icon svg {
            width: 48px;
            height: 48px;
            stroke: #9ca3af;
            stroke-width: 1.5;
            fill: none;
        }

        .upload-text {
            color: #6b7280;
            font-size: 0.95rem;
            margin-bottom: 8px;
        }

        .upload-text strong {
            color: #3b82f6;
        }

        .upload-formats {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .file-input {
            display: none;
        }

        /* File Preview */
        .file-preview {
            display: none;
            margin-top: 16px;
            padding: 16px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }

        .file-preview.visible {
            display: block;
        }

        .file-preview-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .file-icon svg {
            width: 100%;
            height: 100%;
        }

        .file-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-name {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            color: #1f2937;
            background: linear-gradient(to bottom, #fef08a 60%, #fde047 100%);
            padding: 2px 8px;
            border-radius: 3px;
            display: inline-block;
        }

        .file-size {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .file-remove {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 8px;
            font-size: 1.5rem;
            line-height: 1;
            transition: color 0.2s;
            border-radius: 4px;
        }

        .file-remove:hover {
            color: #ef4444;
            background: #fef2f2;
        }

        /* Sheet Selector */
        .sheet-selector {
            display: none;
            margin-top: 16px;
            padding: 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
        }

        .sheet-selector.visible {
            display: block;
        }

        .sheet-selector-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sheet-select {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
            color: #1f2937;
            cursor: pointer;
        }

        .sheet-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .sheet-info {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 8px;
        }

        /* Analyze Button */
        .analyze-btn {
            width: 100%;
            padding: 14px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .analyze-btn:hover:not(:disabled) {
            background: #2563eb;
        }

        .analyze-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .analyze-btn .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: none;
        }

        .analyze-btn.loading .spinner {
            display: block;
        }

        .analyze-btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Demo Button */
        .demo-btn {
            width: 100%;
            padding: 12px 24px;
            margin-top: 12px;
            background: white;
            color: #6b7280;
            border: 2px dashed #d1d5db;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .demo-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            background: #f0f9ff;
        }

        .demo-icon {
            font-size: 0.8rem;
        }

        .demo-hint {
            text-align: center;
            font-size: 0.8rem;
            color: #9ca3af;
            margin-top: 8px;
        }

        /* Info Box */
        .info-box {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 6px;
            padding: 14px 16px;
            font-size: 0.85rem;
            color: #0369a1;
            display: flex;
            gap: 10px;
        }

        .info-box-icon {
            flex-shrink: 0;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
            color: #9ca3af;
            font-size: 0.8rem;
        }

        footer a {
            color: #6b7280;
            text-decoration: none;
        }

        footer a:hover {
            color: #374151;
        }

        /* Error Message */
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 0.85rem;
            color: #991b1b;
            margin-top: 16px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        /* Data Preview */
        .data-preview {
            display: none;
            margin-top: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }

        .data-preview.visible {
            display: block;
        }

        .data-preview-header {
            background: #f9fafb;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
        }

        .data-preview-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .data-preview-stats {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .data-preview-stats span {
            background: #e5e7eb;
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .data-preview-table-wrapper {
            max-height: 280px;
            overflow: auto;
        }

        .data-preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .data-preview-table th {
            background: #f3f4f6;
            position: sticky;
            top: 0;
            font-weight: 600;
            color: #1f2937;
            text-align: left;
            z-index: 1;
        }

        .data-preview-table td,
        .data-preview-table th {
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .data-preview-table tr:nth-child(even) {
            background: #fafbfc;
        }

        .data-preview-table tr:hover {
            background: #f0f9ff;
        }

        .data-preview-table td.number {
            text-align: right;
            color: #0369a1;
        }

        .data-preview-table td.empty {
            color: #9ca3af;
            font-style: italic;
        }

        .data-preview-footer {
            background: #f9fafb;
            padding: 8px 16px;
            border-top: 1px solid #e5e7eb;
            font-size: 0.75rem;
            color: #6b7280;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DATA-ANALYZER</h1>
            <p class="subtitle">Finanzdaten analysieren & Chart-Configs generieren</p>
        </header>

        <!-- API Key Section -->
        <div class="card">
            <div class="card-title">1. API-Verbindung</div>

            <div class="api-provider">
                <button class="provider-btn active" data-provider="anthropic" onclick="selectProvider('anthropic')">
                    <svg class="logo" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M13.827 3.52l5.927 16.96H16.2l-1.28-3.68H8.56l-1.28 3.68H3.746l5.927-16.96h4.154zm-2.14 4.71l-2.32 6.65h4.64l-2.32-6.65z"/>
                    </svg>
                    Claude (Anthropic)
                </button>
                <button class="provider-btn" data-provider="openai" onclick="selectProvider('openai')">
                    <svg class="logo" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M22.282 9.821a5.985 5.985 0 0 0-.516-4.91 6.046 6.046 0 0 0-6.51-2.9A6.065 6.065 0 0 0 4.981 4.18a5.985 5.985 0 0 0-3.998 2.9 6.046 6.046 0 0 0 .743 7.097 5.98 5.98 0 0 0 .51 4.911 6.051 6.051 0 0 0 6.515 2.9A5.985 5.985 0 0 0 13.26 24a6.056 6.056 0 0 0 5.772-4.206 5.99 5.99 0 0 0 3.997-2.9 6.056 6.056 0 0 0-.747-7.073zM13.26 22.43a4.476 4.476 0 0 1-2.876-1.04l.141-.081 4.779-2.758a.795.795 0 0 0 .392-.681v-6.737l2.02 1.168a.071.071 0 0 1 .038.052v5.583a4.504 4.504 0 0 1-4.494 4.494zM3.6 18.304a4.47 4.47 0 0 1-.535-3.014l.142.085 4.783 2.759a.771.771 0 0 0 .78 0l5.843-3.369v2.332a.08.08 0 0 1-.033.062L9.74 19.95a4.5 4.5 0 0 1-6.14-1.646zM2.34 7.896a4.485 4.485 0 0 1 2.366-1.973V11.6a.766.766 0 0 0 .388.676l5.815 3.355-2.02 1.168a.076.076 0 0 1-.071 0l-4.83-2.786A4.504 4.504 0 0 1 2.34 7.872zm16.597 3.855l-5.833-3.387L15.119 7.2a.076.076 0 0 1 .071 0l4.83 2.791a4.494 4.494 0 0 1-.676 8.105v-5.678a.79.79 0 0 0-.407-.667zm2.01-3.023l-.141-.085-4.774-2.782a.776.776 0 0 0-.785 0L9.409 9.23V6.897a.066.066 0 0 1 .028-.061l4.83-2.787a4.5 4.5 0 0 1 6.68 4.66zm-12.64 4.135l-2.02-1.164a.08.08 0 0 1-.038-.057V6.075a4.5 4.5 0 0 1 7.375-3.453l-.142.08-4.778 2.758a.795.795 0 0 0-.393.681zm1.097-2.365l2.602-1.5 2.607 1.5v2.999l-2.597 1.5-2.607-1.5z"/>
                    </svg>
                    OpenAI
                </button>
            </div>

            <div class="api-input-group">
                <input type="password"
                       class="api-input"
                       id="apiKey"
                       placeholder="sk-ant-api03-... oder sk-..."
                       oninput="validateApiKey()">
                <span class="api-status pending" id="apiStatus">
                    <span class="status-dot pending"></span>
                    Eingabe...
                </span>
            </div>
            <p class="api-hint" id="apiHint">
                API-Key von <a href="https://console.anthropic.com/settings/keys" target="_blank">Anthropic Console</a> holen
            </p>
        </div>

        <!-- File Upload Section -->
        <div class="card">
            <div class="card-title">2. Datei hochladen</div>

            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div class="upload-icon">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="4" y="14" width="4" height="6" rx="0.5" fill="#9ca3af"/>
                        <rect x="10" y="10" width="4" height="10" rx="0.5" fill="#9ca3af"/>
                        <rect x="16" y="6" width="4" height="14" rx="0.5" fill="#9ca3af"/>
                        <path d="M3 4v16h18" stroke="#9ca3af" stroke-width="1.5" stroke-linecap="round" fill="none"/>
                    </svg>
                </div>
                <p class="upload-text">
                    Datei hierher ziehen oder <strong>klicken</strong> zum Ausw√§hlen
                </p>
                <p class="upload-formats">CSV, XLSX, XLS (max. 5 MB)</p>
            </div>

            <input type="file" class="file-input" id="fileInput" accept=".csv,.xlsx,.xls" onchange="handleFileSelect(event)">

            <!-- File Preview -->
            <div class="file-preview" id="filePreview">
                <div class="file-preview-header">
                    <div class="file-icon" id="fileIcon"></div>
                    <div class="file-info">
                        <span class="file-name" id="fileName"></span>
                        <span class="file-size" id="fileSize"></span>
                    </div>
                    <button class="file-remove" onclick="removeFile()" title="Datei entfernen">&times;</button>
                </div>
            </div>

            <!-- Sheet Selector (for Excel files with multiple sheets) -->
            <div class="sheet-selector" id="sheetSelector">
                <label class="sheet-selector-label">
                    <span>üìë</span> Sheet ausw√§hlen
                </label>
                <select class="sheet-select" id="sheetSelect" onchange="selectSheet()">
                    <!-- Options will be populated dynamically -->
                </select>
                <div class="sheet-info" id="sheetInfo"></div>
            </div>

            <!-- Data Preview -->
            <div class="data-preview" id="dataPreview">
                <div class="data-preview-header">
                    <div class="data-preview-title">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="3" y1="9" x2="21" y2="9"></line>
                            <line x1="9" y1="21" x2="9" y2="9"></line>
                        </svg>
                        Datenvorschau
                    </div>
                    <div class="data-preview-stats">
                        <span id="previewRowCount">0 Zeilen</span>
                        <span id="previewColCount">0 Spalten</span>
                    </div>
                </div>
                <div class="data-preview-table-wrapper">
                    <table class="data-preview-table" id="previewTable">
                        <!-- Table content will be dynamically generated -->
                    </table>
                </div>
                <div class="data-preview-footer" id="previewFooter">
                    Zeige erste 15 Zeilen
                </div>
            </div>
        </div>

        <!-- Analyze Button -->
        <button class="analyze-btn" id="analyzeBtn" disabled onclick="startAnalysis()">
            <span class="spinner"></span>
            <span class="btn-text">Analyse starten</span>
        </button>

        <!-- Demo Button -->
        <button class="demo-btn" onclick="startDemo()">
            <span class="demo-icon">‚ñ∂</span>
            <span>Demo ansehen</span>
        </button>
        <p class="demo-hint">Keine Datei? Starte eine Demo mit Beispieldaten.</p>

        <div class="error-message" id="errorMessage"></div>

        <!-- Info -->
        <div class="card" style="margin-top: 20px;">
            <div class="info-box">
                <span class="info-box-icon">‚ÑπÔ∏è</span>
                <div>
                    <strong>So funktioniert's:</strong> Der DATA-ANALYZER erkennt automatisch das Datenformat (Matrix/Faktentabelle),
                    klassifiziert Positionen (Summen/Detail/Aufwand/Ertrag) und empfiehlt den optimalen Chart-Typ
                    (Bar, Waterfall, Stacked Bar).
                </div>
            </div>
        </div>

        <footer>
            DATA-ANALYZER &middot; <span id="currentDate"></span>
        </footer>
    </div>

    <script>
        // Set current date
        document.getElementById('currentDate').textContent = new Date().toLocaleDateString('de-DE');

        // DATA-ANALYZER-PROMPT: Analysiert NUR die Datenstruktur und empfiehlt Chart-Typ
        // Die 5 Chart-Configs werden sp√§ter im 2. API-Call in charts.html erstellt
        const DATA_ANALYZER_PROMPT = `Du bist ein spezialisierter Datenanalyst f√ºr Finanz- und Controlling-Daten.

WICHTIG: Du sollst NUR die Daten analysieren und einen Chart-Typ empfehlen.
Du erstellst KEINE Chart-Konfigurationen - das passiert sp√§ter mit einem spezialisierten Prompt.

---

## PHASE 1: STRUKTURERKENNUNG

Analysiere die Daten nach folgenden Dimensionen:

### 1.1 Datenformat-Erkennung

| Format | Erkennungsmerkmal | Beispiel |
|--------|-------------------|----------|
| **Matrix-einfach** | Erste Zeile = Spaltenk√∂pfe, Spalten = Wertarten | Position, IST, FC, BUD |
| **Matrix-komplex** | Mehrzeilige Header, merged cells, Zeitraum + Wertart kombiniert | SEL (DEZ): IST, FC, BUD / CUM (JAN-DEZ): IST, FC, BUD |
| **Faktentabelle** | Eine Zeile = ein Datenpunkt, separate Spalten f√ºr jede Dimension | Position, Zeitraum, Monat, Wertart, Wert |

### 1.2 Positions-Klassifikation

| Typ | Erkennungsmerkmal | Beispiele |
|-----|-------------------|-----------|
| **Summenzeile** | Fettdruck, GROSSBUCHSTABEN, typische Namen | EBIT, EBITDA, Gesamtleistung, Jahres√ºberschuss, Total, Net Income |
| **Detailzeile** | Normale Formatierung, Einzelpositionen | Umsatzerl√∂se, Materialaufwand, Personalaufwand, Revenue, COGS |
| **Zwischensumme** | Aggregiert Teilbereiche | Gross Profit, Finanzergebnis, EBT, Operating Income |

### 1.3 Hierarchie-Erkennung

Pr√ºfe ob die Daten eine hierarchische Struktur haben:

| Struktur | Erkennungsmerkmal | Beispiel |
|----------|-------------------|----------|
| **Cluster ‚Üí Detail** | Spalte 1 enth√§lt Gruppennamen (wiederholt), Spalte 2 enth√§lt Einzelelemente | Cluster: "DACH", Region: "Deutschland", "√ñsterreich", "Schweiz" |
| **Gesamt-Zeilen** | Zeilen mit "Gesamt", "Total", "Summe" am Ende einer Gruppe | "DACH Gesamt" nach DE, AT, CH |
| **Einr√ºckung** | Detail-Zeilen sind einger√ºckt oder haben Leerzeichen-Prefix | "  Deutschland" unter "DACH" |

**Bei erkannter Hierarchie:**
- Identifiziere die Aggregations-Ebene (z.B. Cluster: DACH, Nordics, Southern Europe)
- Identifiziere die Detail-Ebene (z.B. L√§nder: Deutschland, √ñsterreich, Schweiz, etc.)
- Generiere Charts f√ºr BEIDE Ebenen: Aggregiert UND Detail-Elemente einzeln

### 1.4 Vorzeichen-Logik

| Regel | Anwendung |
|-------|-----------|
| Negative Werte = Aufwand/Kosten | Materialaufwand: -1.168.000 |
| Positive Werte = Ertrag/Erl√∂s | Umsatzerl√∂se: 2.195.000 |

---

## PHASE 2: CHART-TYP ERMITTLUNG

Bestimme den optimalen Chart-Typ basierend auf den Daten:

### WATERFALL - wenn:
- GuV-Struktur erkennbar (Gesamtleistung ‚Üí Aufwendungen ‚Üí EBIT)
- Ver√§nderungsrechnung (Start ‚Üí √Ñnderungen ‚Üí Ende)

### BAR CHART - wenn:
- Wenige Kennzahlen (2-5), mehrere Wertarten (IST/FC/BUD)
- Periodenvergleich

### STACKED BAR - wenn:
- Kostenaufschl√ºsselung, Teil-Ganzes-Beziehung
- Mehrere Segmente mit gleicher Kategorieachse

### LINE CHART - wenn:
- Zeitreihe mit >4 Zeitpunkten
- Monatliche/quartalsweise Entwicklung

---

## PHASE 3: DATEN EXTRAHIEREN

Extrahiere die relevanten Daten f√ºr die sp√§tere Chart-Erstellung:

### F√ºr WATERFALL:
Extrahiere die Daten je nach Datentyp:

**Bei GuV-Daten (Kostenarten/Positionen):**
Extrahiere alle Positionen mit Typ und Wert:
- start: Ausgangswert (z.B. Umsatzerl√∂se, Gesamtleistung)
- increase: Positive Ver√§nderungen (z.B. sonstige Ertr√§ge)
- decrease: Negative Ver√§nderungen/Aufwendungen
- end: Ergebniswert (z.B. EBIT, Jahres√ºberschuss)

**Bei Zeitreihen-Daten (Jahre/Monate):**
Extrahiere die Werte pro Zeitpunkt:
- timeseries: Array mit { period: "2020", value: 100 }, { period: "2021", value: 110 }, etc.
- Die Chart-Generierung berechnet dann die Differenzen

**KRITISCH: Erfinde KEINE Kategorien wie "Inflation", "Pricing", "Volume"!**
Verwende NUR die Labels/Namen die tats√§chlich in den Quelldaten stehen.

### F√ºr BAR/STACKED BAR/LINE:
Extrahiere JEDEN EINZELNEN DATENPUNKT aus den Quelldaten:
- Perioden/Zeitpunkte: JEDES Jahr/Quartal/Monat einzeln (z.B. "2020", "2021", "2022", "2023", "2024", "2025", "2026 PLAN", "2026 BUD")
- Kategorien/Kennzahlen
- Werte pro Kategorie und Periode
- Typ pro Periode (IST, PLAN, BUD) - aus Spalte wie "Scenario", "Typ", "Art" extrahieren

**KRITISCH: KEINE Aggregation! Jeder Datenpunkt = eine eigene Periode!**
- FALSCH: periods: ["IST", "PLAN"] (nur 2 aggregierte Werte)
- RICHTIG: periods: ["2020 IST", "2021 IST", "2022 IST", "2023 IST", "2024 IST", "2025 IST", "2026 PLAN", "2026 BUD"] (alle einzelnen Datenpunkte)

---

## AUSGABE-FORMAT

WICHTIG: Antworte NUR mit diesem JSON-Format (keine Markdown-Bl√∂cke, kein Text davor/danach):

{
    "analysis": {
        "dataFormat": "matrix-simple | matrix-complex | fact-table",
        "rowCount": 16,
        "columnCount": 7,
        "detectedUnit": "TEUR",
        "scaleFactor": 1000,
        "timeRange": {
            "type": "single | cumulative | both | multi-period",
            "periods": ["DEZ", "JAN-DEZ"],
            "year": "2025"
        },
        "valueTypes": ["IST", "FC", "BUD"],
        "positions": {
            "summary": ["Gesamtleistung", "EBIT"],
            "detail": ["Umsatzerl√∂se", "Materialaufwand"],
            "expenses": ["Materialaufwand", "Personalaufwand"],
            "income": ["Umsatzerl√∂se"]
        }
    },

    "recommendation": {
        "primaryChart": "waterfall | bar | stacked-bar",
        "alternativeCharts": ["bar", "stacked-bar"],
        "reasoning": "Kurze Begr√ºndung warum dieser Chart-Typ am besten passt"
    },

    "extractedData": {
        "waterfall": {
            "dataType": "guv | timeseries",
            "positions": [
                { "name": "Umsatzerl√∂se", "type": "start", "value": 2195000 },
                { "name": "Bestandsver√§nderungen", "type": "increase", "value": 28000 },
                { "name": "Materialaufwand", "type": "decrease", "value": -1168000 },
                { "name": "Personalaufwand", "type": "decrease", "value": -618000 },
                { "name": "EBIT", "type": "end", "value": 179500 }
            ],
            "timeseries": [
                { "period": "2020", "value": 100, "type": "IST" },
                { "period": "2021", "value": 110, "type": "IST" },
                { "period": "2022", "value": 125, "type": "IST" },
                { "period": "2026", "value": 150, "type": "PLAN" }
            ],
            "compareValue": { "name": "Budget", "value": 190000 }
        },
        "bar": {
            "periods": [
                { "label": "2020", "type": "IST" },
                { "label": "2021", "type": "IST" },
                { "label": "2022", "type": "IST" },
                { "label": "2023", "type": "IST" },
                { "label": "2024", "type": "IST" },
                { "label": "2025", "type": "IST" },
                { "label": "2026 PLAN", "type": "PLAN" },
                { "label": "2026 BUD", "type": "BUD" }
            ],
            "categories": [
                { "name": "Umsatzerl√∂se", "values": [1800000, 1900000, 2000000, 2050000, 2100000, 2195000, 2250000, 2160000] },
                { "name": "EBIT", "values": [140000, 150000, 160000, 165000, 172000, 179500, 185000, 190000] }
            ]
        }
    },

    "metadata": {
        "suggestedTitle": "GuV Bridge - Gesch√§ftsjahr 2025",
        "suggestedSubtitle": "in TEUR, kumuliert JAN-DEZ",
        "dataSource": "filename",
        "generatedAt": "2025-01-19"
    },

    "hierarchy": {
        "detected": true,
        "aggregationLevel": {
            "columnName": "Cluster",
            "values": ["DACH", "Nordics", "Southern Europe", "Benelux"]
        },
        "detailLevel": {
            "columnName": "Region",
            "values": ["Deutschland", "√ñsterreich", "Schweiz", "Schweden", "Norwegen", "D√§nemark", "Finnland", "Italien", "Spanien", "Niederlande", "Belgien", "Luxemburg"]
        },
        "chartVariations": [
            { "type": "aggregated", "chartType": "bar", "focus": "all-clusters", "description": "Bar Chart: Cluster-Vergleich" },
            { "type": "aggregated", "chartType": "stacked-bar", "focus": "all-clusters", "description": "Stacked Bar: Cluster als Stacks, X=Jahre" },
            { "type": "detail", "chartType": "bar", "focus": "single-elements", "description": "Bar Chart: Einzelne L√§nder" },
            { "type": "detail", "chartType": "stacked-bar", "focus": "all-elements", "description": "Stacked Bar: ALLE L√§nder als Stacks, X=Jahre" },
            { "type": "cluster-detail", "chartType": "stacked-bar", "focus": "DACH", "description": "Stacked Bar: DACH-L√§nder (DE,AT,CH) als Stacks, X=Jahre" },
            { "type": "cluster-detail", "chartType": "stacked-bar", "focus": "Nordics", "description": "Stacked Bar: Nordics-L√§nder als Stacks, X=Jahre" }
        ]
    }
}

---

WICHTIG:
- Antworte NUR mit dem JSON-Objekt
- Keine json-Codebl√∂cke
- Kein Text vor oder nach dem JSON
- KEINE configs/variants erstellen - nur Analyse und Datenextraktion!
- Die extractedData sollen die Rohdaten f√ºr die sp√§tere Chart-Generierung enthalten

## HIERARCHISCHE DATEN - CHART-VIELFALT

KRITISCH: Bei Daten mit hierarchischer Struktur (z.B. Cluster zu L√§nder, Kategorie zu Produkte):

1. Erkenne BEIDE Ebenen und f√ºlle das hierarchy-Objekt aus
2. Generiere Chart-Variationen f√ºr BEIDE Ebenen:
   - Aggregierte Ebene: Vergleich aller Cluster/Kategorien
   - Detail-Ebene: Einzelne Elemente (L√§nder, Produkte, etc.)
   - Gefilterte Detail-Ansichten: z.B. nur L√§nder eines Clusters

3. Beispiel sales_performance.xlsx - CHART-VARIATIONEN:

   BAR CHARTS:
   - Aggregiert: Revenue nach Cluster 2022-2025 (DACH vs Nordics vs Southern Europe vs Benelux)
   - Detail: Top 5 L√§nder nach Revenue 2024
   - Detail: Deutschland Revenue-Entwicklung 2022-2025
   - Gefiltert: DACH-L√§nder Revenue-Vergleich 2024

   STACKED BAR CHARTS - WICHTIG!
   - Cluster-Level: Stacks = Cluster (DACH, Nordics, etc.), X-Achse = Jahre
   - Detail-Level: Stacks = Einzelne L√§nder (DE, AT, CH, SE, NO, etc.), X-Achse = Jahre
   - Gefiltert: Stacks = nur DACH-L√§nder (DE, AT, CH), X-Achse = Jahre
   - CLUSTER-DETAIL: Stacks = L√§nder INNERHALB eines Clusters, X-Achse = Jahre (NEU!)

   BAR CHARTS (normale S√§ulendiagramme) - WICHTIG!
   - Cluster-Level: Kategorien (X-Achse) = Cluster (DACH, Nordics, etc.), Perioden = Jahre
   - Detail-Level: Kategorien (X-Achse) = Einzelne L√§nder, Perioden = Jahre
   - CLUSTER-DETAIL: Kategorien (X-Achse) = L√§nder INNERHALB eines Clusters, nebeneinander (NEU!)

   BAR CHART - CLUSTER-DETAIL IST PFLICHT bei hierarchischen Daten!
   Bei 3 Clustern (DACH, APAC, Americas) erstelle:
   - Variante 1: DACH Regionen-Vergleich (DE, AT, CH als Kategorien nebeneinander)
   - Variante 2: APAC Regionen-Vergleich (JP, CN, etc. als Kategorien nebeneinander)
   - Variante 3: Americas Regionen-Vergleich (USA, CA, etc. als Kategorien nebeneinander)
   So sieht man die einzelnen Regionen eines Clusters direkt vergleichbar!

4. Datenextraktion f√ºr Detail-Level:
   Extrahiere auch Daten f√ºr einzelne Elemente der Detail-Ebene im detailData-Objekt.

ZIEL: Bei 10 generierten Chart-Beispielen sollten ca. 50% Cluster-Ebene und 50% Detail-Ebene (Einzell√§nder) sein!

STACKED BAR - CLUSTER-DETAIL IST PFLICHT!
Bei hierarchischen Daten MUSS mindestens ein Stacked Bar Chart erstellt werden, der zeigt:
- Einen einzelnen Cluster (z.B. nur DACH)
- Die L√§nder dieses Clusters als Stacks (Deutschland, √ñsterreich, Schweiz)
- X-Achse = Jahre/Perioden

Beispiel: "DACH Revenue nach L√§ndern 2022-2025"
- 2022: Stack aus [DE: 450, AT: 120, CH: 80] = 650 Gesamt
- 2023: Stack aus [DE: 480, AT: 130, CH: 85] = 695 Gesamt
- 2024: Stack aus [DE: 510, AT: 140, CH: 90] = 740 Gesamt
- 2025: Stack aus [DE: 540, AT: 150, CH: 95] = 785 Gesamt

So sieht man die Zusammensetzung eines Clusters aus seinen Detail-Elementen!
`;

        let selectedProvider = 'anthropic';
        let selectedFile = null;  // Single file object
        let workbook = null;      // Parsed workbook (for Excel)
        let selectedSheet = null; // Selected sheet name
        let previewData = null;   // Parsed data for preview
        const PREVIEW_MAX_ROWS = 15; // Maximum rows to show in preview

        // Provider Selection
        function selectProvider(provider) {
            selectedProvider = provider;
            document.querySelectorAll('.provider-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.provider === provider);
            });

            const hint = document.getElementById('apiHint');
            if (provider === 'anthropic') {
                hint.innerHTML = 'API-Key von <a href="https://console.anthropic.com/settings/keys" target="_blank">Anthropic Console</a> holen';
                document.getElementById('apiKey').placeholder = 'sk-ant-api03-...';
            } else {
                hint.innerHTML = 'API-Key von <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Platform</a> holen';
                document.getElementById('apiKey').placeholder = 'sk-...';
            }

            validateApiKey();
        }

        // API Key Validation
        function validateApiKey() {
            const input = document.getElementById('apiKey');
            const status = document.getElementById('apiStatus');
            const key = input.value.trim();

            if (!key) {
                status.className = 'api-status pending';
                status.innerHTML = '<span class="status-dot pending"></span> Eingabe...';
                updateAnalyzeButton();
                return;
            }

            let isValid = false;
            if (selectedProvider === 'anthropic') {
                isValid = key.startsWith('sk-ant-');
            } else {
                isValid = key.startsWith('sk-') && !key.startsWith('sk-ant-');
            }

            if (isValid) {
                status.className = 'api-status valid';
                status.innerHTML = '<span class="status-dot valid"></span> G√ºltig';
            } else {
                status.className = 'api-status invalid';
                status.innerHTML = '<span class="status-dot invalid"></span> Ung√ºltig';
            }

            updateAnalyzeButton();
        }

        // Drag & Drop
        const uploadArea = document.getElementById('uploadArea');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        // File Selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        // Process single file
        async function handleFile(file) {
            hideError();

            const validTypes = ['.csv', '.xlsx', '.xls'];
            const extension = '.' + file.name.split('.').pop().toLowerCase();

            if (!validTypes.includes(extension)) {
                showError('Nur CSV oder Excel-Dateien erlaubt.');
                return;
            }

            if (file.size > 5 * 1024 * 1024) {
                showError('Datei zu gross (max. 5 MB).');
                return;
            }

            selectedFile = file;
            workbook = null;
            selectedSheet = null;

            // Update UI
            uploadArea.classList.add('has-file');
            showFilePreview(file);

            // For Excel files, parse and show sheet selector
            if (extension === '.xlsx' || extension === '.xls') {
                try {
                    workbook = await parseExcelFile(file);

                    if (workbook.SheetNames.length > 1) {
                        showSheetSelector(workbook);
                    } else {
                        selectedSheet = workbook.SheetNames[0];
                        hideSheetSelector();
                    }

                    // Show preview for Excel
                    updatePreviewFromWorkbook();
                } catch (err) {
                    showError('Excel konnte nicht gelesen werden.');
                    removeFile();
                    return;
                }
            } else {
                // CSV file - show preview
                hideSheetSelector();
                try {
                    await showPreviewFromCSV(file);
                } catch (err) {
                    console.error('Preview error:', err);
                    // Don't block upload if preview fails
                }
            }

            updateAnalyzeButton();
        }

        // Parse Excel file
        function parseExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onerror = () => reject(new Error('Datei konnte nicht gelesen werden'));
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const wb = XLSX.read(data, { type: 'array' });
                        resolve(wb);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // Show file preview
        function showFilePreview(file) {
            const preview = document.getElementById('filePreview');
            const nameEl = document.getElementById('fileName');
            const sizeEl = document.getElementById('fileSize');
            const iconEl = document.getElementById('fileIcon');

            const isExcel = file.name.endsWith('.xlsx') || file.name.endsWith('.xls');

            iconEl.innerHTML = isExcel ?
                `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect x="3" y="2" width="18" height="20" rx="2" fill="#10b981" opacity="0.15"/>
                    <rect x="3" y="2" width="18" height="20" rx="2" stroke="#10b981" stroke-width="1.5"/>
                    <path d="M8 8L12 12L8 16" stroke="#10b981" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M16 8L12 12L16 16" stroke="#10b981" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>` :
                `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect x="3" y="2" width="18" height="20" rx="2" fill="#6b7280" opacity="0.15"/>
                    <rect x="3" y="2" width="18" height="20" rx="2" stroke="#6b7280" stroke-width="1.5"/>
                    <line x1="7" y1="8" x2="17" y2="8" stroke="#6b7280" stroke-width="1.5" stroke-linecap="round"/>
                    <line x1="7" y1="12" x2="17" y2="12" stroke="#6b7280" stroke-width="1.5" stroke-linecap="round"/>
                    <line x1="7" y1="16" x2="13" y2="16" stroke="#6b7280" stroke-width="1.5" stroke-linecap="round"/>
                </svg>`;

            nameEl.textContent = file.name;
            sizeEl.textContent = formatFileSize(file.size);
            preview.classList.add('visible');
        }

        // Show sheet selector dropdown
        function showSheetSelector(wb) {
            const selector = document.getElementById('sheetSelector');
            const select = document.getElementById('sheetSelect');
            const info = document.getElementById('sheetInfo');

            select.innerHTML = wb.SheetNames.map((name, index) => {
                const worksheet = wb.Sheets[name];
                const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
                const rows = range.e.r - range.s.r + 1;
                const cols = range.e.c - range.s.c + 1;
                return `<option value="${name}">${name} (${rows} Zeilen √ó ${cols} Spalten)</option>`;
            }).join('');

            // Select first sheet by default
            selectedSheet = wb.SheetNames[0];
            info.textContent = `${wb.SheetNames.length} Sheets verf√ºgbar`;

            selector.classList.add('visible');
        }

        // Hide sheet selector
        function hideSheetSelector() {
            document.getElementById('sheetSelector').classList.remove('visible');
        }

        // Handle sheet selection
        function selectSheet() {
            const select = document.getElementById('sheetSelect');
            selectedSheet = select.value;
            updateAnalyzeButton();

            // Update preview when sheet changes
            if (workbook && selectedSheet) {
                updatePreviewFromWorkbook();
            }
        }

        // =====================================================
        // DATA PREVIEW FUNCTIONS
        // =====================================================

        // Parse CSV text to 2D array
        function parseCSVToArray(csvText) {
            const lines = csvText.split(/\r?\n/);
            const result = [];

            for (const line of lines) {
                if (line.trim() === '') continue;

                // Simple CSV parsing (handles semicolon and comma separators)
                const separator = line.includes(';') ? ';' : ',';
                const cells = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === separator && !inQuotes) {
                        cells.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                cells.push(current.trim());
                result.push(cells);
            }

            return result;
        }

        // Update preview from workbook (Excel)
        function updatePreviewFromWorkbook() {
            if (!workbook || !selectedSheet) return;

            try {
                const worksheet = workbook.Sheets[selectedSheet];
                const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                previewData = data;
                showDataPreview(data);
            } catch (err) {
                console.error('Error updating preview:', err);
                hideDataPreview();
            }
        }

        // Show data preview from CSV file
        async function showPreviewFromCSV(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onerror = () => reject(new Error('Datei konnte nicht gelesen werden'));
                reader.onload = (e) => {
                    try {
                        const data = parseCSVToArray(e.target.result);
                        previewData = data;
                        showDataPreview(data);
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.readAsText(file);
            });
        }

        // Render the data preview table
        function showDataPreview(data) {
            if (!data || data.length === 0) {
                hideDataPreview();
                return;
            }

            const preview = document.getElementById('dataPreview');
            const table = document.getElementById('previewTable');
            const rowCountEl = document.getElementById('previewRowCount');
            const colCountEl = document.getElementById('previewColCount');
            const footerEl = document.getElementById('previewFooter');

            const totalRows = data.length;
            const totalCols = Math.max(...data.map(row => row.length));
            const displayRows = Math.min(totalRows, PREVIEW_MAX_ROWS);

            // Update stats
            rowCountEl.textContent = `${totalRows} Zeilen`;
            colCountEl.textContent = `${totalCols} Spalten`;

            // Build table HTML
            let html = '';

            // Header row (first row of data)
            if (data.length > 0) {
                html += '<thead><tr>';
                const headerRow = data[0];
                for (let i = 0; i < totalCols; i++) {
                    const cell = headerRow[i] !== undefined ? headerRow[i] : '';
                    html += `<th title="${escapeHtml(String(cell))}">${escapeHtml(truncateText(String(cell), 30))}</th>`;
                }
                html += '</tr></thead>';
            }

            // Data rows
            html += '<tbody>';
            for (let rowIdx = 1; rowIdx < displayRows; rowIdx++) {
                const row = data[rowIdx] || [];
                html += '<tr>';
                for (let colIdx = 0; colIdx < totalCols; colIdx++) {
                    const cell = row[colIdx] !== undefined ? row[colIdx] : '';
                    const cellStr = String(cell);
                    const isNumber = !isNaN(parseFloat(cellStr)) && cellStr.trim() !== '';
                    const isEmpty = cellStr.trim() === '';

                    let className = '';
                    if (isNumber) className = 'number';
                    if (isEmpty) className = 'empty';

                    const displayValue = isEmpty ? '(leer)' : truncateText(cellStr, 25);
                    html += `<td class="${className}" title="${escapeHtml(cellStr)}">${escapeHtml(displayValue)}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody>';

            table.innerHTML = html;

            // Update footer
            if (totalRows > PREVIEW_MAX_ROWS) {
                footerEl.textContent = `Zeige erste ${PREVIEW_MAX_ROWS} von ${totalRows} Zeilen`;
            } else {
                footerEl.textContent = `Zeige alle ${totalRows} Zeilen`;
            }

            preview.classList.add('visible');
        }

        // Hide data preview
        function hideDataPreview() {
            document.getElementById('dataPreview').classList.remove('visible');
            previewData = null;
        }

        // Utility: Truncate text with ellipsis
        function truncateText(text, maxLength) {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        // Utility: Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Remove file
        function removeFile() {
            selectedFile = null;
            workbook = null;
            selectedSheet = null;
            previewData = null;

            document.getElementById('fileInput').value = '';
            document.getElementById('filePreview').classList.remove('visible');
            uploadArea.classList.remove('has-file');
            hideSheetSelector();
            hideDataPreview();

            updateAnalyzeButton();
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Update Analyze Button state
        function updateAnalyzeButton() {
            const btn = document.getElementById('analyzeBtn');
            const apiStatus = document.getElementById('apiStatus');

            const hasValidKey = apiStatus.classList.contains('valid');
            const hasFile = selectedFile !== null;
            const hasSheet = !workbook || workbook.SheetNames.length === 1 || selectedSheet !== null;

            btn.disabled = !(hasValidKey && hasFile && hasSheet);
        }

        // Start Demo - ohne API Key und ohne Datei
        function startDemo() {
            // Demo-Analyseergebnis f√ºr einen Waterfall-Chart
            const demoResult = {
                result: JSON.stringify({
                    analysis: {
                        dataType: "income_statement",
                        detectedFormat: "matrix",
                        detectedUnit: "TEUR",
                        scaleFactor: 1,
                        totalRows: 12,
                        totalColumns: 4,
                        periods: ["Ist Dez", "Budget Dez", "Ist GJ", "Budget GJ"]
                    },
                    recommendation: {
                        primaryChart: "waterfall",
                        confidence: 0.95,
                        reasoning: "GuV-Daten eignen sich ideal f√ºr eine Waterfall-Bridge-Darstellung"
                    },
                    extractedData: {
                        waterfall: {
                            positions: [
                                { name: "Umsatzerl√∂se", type: "start", value: 185000 },
                                { name: "Bestandsver√§nderung", type: "increase", value: 2500 },
                                { name: "Aktivierte Eigenleistungen", type: "increase", value: 1200 },
                                { name: "Sonstige betriebliche Ertr√§ge", type: "increase", value: 3800 },
                                { name: "Materialaufwand", type: "decrease", value: -98500 },
                                { name: "Personalaufwand", type: "decrease", value: -52000 },
                                { name: "Abschreibungen", type: "decrease", value: -8500 },
                                { name: "Sonstige betriebliche Aufwendungen", type: "decrease", value: -18200 },
                                { name: "EBIT", type: "end", value: 15300 }
                            ],
                            compareValue: { name: "Budget EBIT", value: 14000 }
                        }
                    },
                    metadata: {
                        suggestedTitle: "GuV Bridge Dezember",
                        suggestedSubtitle: "in TEUR"
                    }
                }),
                csvData: "Demo-Daten",
                fileName: "Demo_GuV_Beispiel.xlsx"
            };

            // Speichere Demo-Ergebnis im SessionStorage
            sessionStorage.setItem('analysisResult', JSON.stringify(demoResult));
            sessionStorage.setItem('isDemo', 'true');

            // Weiterleitung zur Results-Seite (wie im normalen Flow)
            window.location.href = 'results.html';
        }

        // Start Analysis
        async function startAnalysis() {
            const btn = document.getElementById('analyzeBtn');
            btn.classList.add('loading');
            btn.disabled = true;
            hideError();

            try {
                // Read file content
                const content = await readFileContent();

                // Call API for analysis
                const result = await analyzeData(content);

                // Erkenne die Sprache der Daten
                const detectedLanguage = detectDataLanguage(content);
                console.log('Erkannte Sprache:', detectedLanguage);

                // Create result object (singular, not array)
                const analysisResult = {
                    fileName: selectedFile.name,
                    sheetName: selectedSheet,
                    displayName: selectedSheet ?
                        `${selectedFile.name} ‚Üí ${selectedSheet}` :
                        selectedFile.name,
                    result: result,
                    csvData: content,  // Speichere Rohdaten f√ºr zweiten API-Call
                    detectedLanguage: detectedLanguage  // NEU: Erkannte Sprache f√ºr Label-Beibehaltung
                };

                // Store in sessionStorage (singular key!)
                sessionStorage.setItem('analysisResult', JSON.stringify(analysisResult));
                sessionStorage.setItem('fileName', selectedFile.name);

                // Store API settings for potential future use
                sessionStorage.setItem('apiProvider', selectedProvider);
                sessionStorage.setItem('apiKey', document.getElementById('apiKey').value.trim());

                // Redirect to results page
                window.location.href = 'results.html';

            } catch (error) {
                showError('Fehler bei der Analyse: ' + error.message);
            } finally {
                btn.classList.remove('loading');
                updateAnalyzeButton();
            }
        }

        // =====================================================
        // SPRACH-ERKENNUNG: Erkennt ob Daten deutsch oder englisch sind
        // =====================================================
        function detectDataLanguage(csvContent) {
            const text = csvContent.toLowerCase();

            // Deutsche Finanz-Begriffe
            const germanWords = [
                'umsatz', 'kosten', 'gewinn', 'verlust', 'aufwand', 'erl√∂s', 'erl√∂se',
                'summe', 'gesamt', 'ergebnis', 'betrieb', 'material', 'personal',
                'abschreibung', 'steuer', 'zins', 'einkauf', 'verkauf', 'lager',
                'vorrat', 'forderung', 'verbindlichkeit', 'r√ºckstellung', 'eigenkapital',
                'fremdkapital', 'bilanz', 'aktiva', 'passiva', 'anlage', 'umlauf',
                'brutto', 'netto', 'marge', 'deckungsbeitrag', 'fixkosten', 'variable'
            ];

            // Englische Finanz-Begriffe
            const englishWords = [
                'revenue', 'cost', 'profit', 'loss', 'expense', 'income', 'sales',
                'total', 'sum', 'result', 'operating', 'material', 'personnel',
                'depreciation', 'tax', 'interest', 'purchase', 'inventory', 'stock',
                'receivable', 'payable', 'provision', 'equity', 'debt', 'liability',
                'balance', 'asset', 'gross', 'net', 'margin', 'contribution', 'fixed',
                'variable', 'earnings', 'ebitda', 'capex', 'opex', 'cogs'
            ];

            let germanScore = 0;
            let englishScore = 0;

            germanWords.forEach(word => {
                // Suche nach ganzen W√∂rtern (mit Wortgrenzen)
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                const matches = text.match(regex);
                if (matches) germanScore += matches.length;
            });

            englishWords.forEach(word => {
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                const matches = text.match(regex);
                if (matches) englishScore += matches.length;
            });

            console.log(`Sprach-Erkennung: Deutsch=${germanScore}, Englisch=${englishScore}`);

            if (germanScore > englishScore) return 'de';
            if (englishScore > germanScore) return 'en';
            return 'unknown';
        }

        // Read content from file
        function readFileContent() {
            return new Promise((resolve, reject) => {
                if (selectedFile.name.endsWith('.csv')) {
                    const reader = new FileReader();
                    reader.onerror = () => reject(new Error('Datei konnte nicht gelesen werden'));
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsText(selectedFile);
                } else {
                    // Excel file
                    if (workbook && selectedSheet) {
                        try {
                            const worksheet = workbook.Sheets[selectedSheet];
                            const csvContent = XLSX.utils.sheet_to_csv(worksheet, {
                                FS: ';',
                                blankrows: false
                            });
                            resolve(csvContent);
                        } catch (err) {
                            reject(new Error('Sheet konnte nicht gelesen werden'));
                        }
                    } else {
                        reject(new Error('Kein Workbook oder Sheet verf√ºgbar'));
                    }
                }
            });
        }

        // Analyze data with API
        async function analyzeData(content) {
            const apiKey = document.getElementById('apiKey').value.trim();

            let result;
            if (selectedProvider === 'anthropic') {
                result = await callClaudeAPI(apiKey, content);
            } else {
                result = await callOpenAIAPI(apiKey, content);
            }

            // Clean up result (remove potential markdown)
            let cleanResult = result.trim();
            if (cleanResult.startsWith('```json')) {
                cleanResult = cleanResult.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            } else if (cleanResult.startsWith('```')) {
                cleanResult = cleanResult.replace(/^```\s*/, '').replace(/\s*```$/, '');
            }

            // Validate JSON
            try {
                JSON.parse(cleanResult);
            } catch (e) {
                console.error('Invalid JSON from API:', cleanResult);
                throw new Error('API-Antwort konnte nicht geparst werden');
            }

            return cleanResult;
        }

        // Call Claude API
        async function callClaudeAPI(apiKey, content) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 8192,
                    messages: [{
                        role: 'user',
                        content: `${DATA_ANALYZER_PROMPT}

## DATEN ZUR ANALYSE:

${content}`
                    }]
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API-Fehler');
            }

            const data = await response.json();
            return data.content[0].text;
        }

        // Call OpenAI API
        async function callOpenAIAPI(apiKey, content) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    max_tokens: 8192,
                    messages: [{
                        role: 'user',
                        content: `${DATA_ANALYZER_PROMPT}

## DATEN ZUR ANALYSE:

${content}`
                    }]
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API-Fehler');
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        // Error Handling
        function showError(message) {
            const el = document.getElementById('errorMessage');
            el.textContent = message;
            el.classList.add('visible');
        }

        function hideError() {
            document.getElementById('errorMessage').classList.remove('visible');
        }
    </script>
</body>
</html>
