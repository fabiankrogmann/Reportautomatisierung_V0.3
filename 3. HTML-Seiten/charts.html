<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart-Beispiele - Think-Cell Stil</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- PptxGenJS für PowerPoint-Export -->
    <script src="https://cdn.jsdelivr.net/gh/gitbrent/PptxGenJS@3.12.0/dist/pptxgen.bundle.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .page-subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 40px;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            padding: 30px;
            /* Margin wird jetzt vom .chart-wrapper gehandhabt */
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .chart-info {
            flex: 1;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 5px;
        }

        .chart-subtitle {
            font-size: 13px;
            color: #666;
        }

        .chart-actions {
            display: flex;
            gap: 8px;
        }

        .btn-download {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-download:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        svg {
            display: block;
            width: 100%;
            height: auto;
        }

        /* Chart Styles */
        .bar { transition: opacity 0.2s ease; }
        .bar:hover { opacity: 0.8; cursor: pointer; }

        .stacked-bar { cursor: pointer; transition: opacity 0.2s ease; }
        .stacked-bar:hover { opacity: 0.85; }

        .connector-line { stroke-width: 1; }

        .value-label { font-size: 12px; font-weight: bold; text-anchor: middle; }
        .value-label-inside { font-size: 11px; font-weight: bold; fill: white; text-anchor: middle; dominant-baseline: middle; }
        .axis-label { font-size: 11px; text-anchor: middle; }
        .segment-label { font-size: 11px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .total-label { font-size: 13px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; }

        .bracket-line { stroke-width: 1.5; fill: none; }
        .bracket-line-dashed { stroke-width: 1; fill: none; }
        .bracket-bubble { fill: white; stroke-width: 1.5; }
        .bracket-label { font-size: 12px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; }
        .change-label { font-size: 10px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: middle; }
        .arrow-head { fill: #333; }

        .data-point { cursor: pointer; transition: r 0.2s ease; }
        .data-point:hover { r: 10 !important; }

        .legend-text { font-size: 11px; fill: #333; }

        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            font-size: 13px;
        }
        .tooltip.visible { opacity: 1; }

        /* Navigation */
        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto 30px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-pptx {
            background: #D24726;
            color: white;
        }

        .btn-pptx:hover {
            background: #B83D1E;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
        }

        .btn-download.btn-pptx {
            background: #D24726;
            color: white;
            border-color: #D24726;
        }

        .btn-download.btn-pptx:hover {
            background: #B83D1E;
            border-color: #B83D1E;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .empty-state-title {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        /* Loading State */
        .loading-state {
            text-align: center;
            padding: 80px 20px;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .loading-subtitle {
            color: #6b7280;
            font-size: 14px;
        }

        .loading-progress {
            margin-top: 30px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .progress-bar {
            height: 10px;
            background: #d1d5db;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            border-radius: 5px;
            width: 5%;
            transition: width 0.3s ease;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }

        footer {
            text-align: center;
            color: #9ca3af;
            font-size: 12px;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }

        /* KI-Entscheidungen Sektion */
        .reasoning-container {
            max-width: 1400px;
            margin: 40px auto 20px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .reasoning-container summary {
            padding: 14px 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            color: #475569;
            background: #f1f5f9;
            border-radius: 8px;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .reasoning-container summary::-webkit-details-marker {
            display: none;
        }

        .reasoning-container summary::before {
            content: '>';
            font-family: monospace;
            transition: transform 0.2s;
        }

        .reasoning-container[open] summary::before {
            transform: rotate(90deg);
        }

        .reasoning-container[open] summary {
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .reasoning-content {
            padding: 20px;
            font-size: 13px;
            color: #334155;
            line-height: 1.6;
        }

        .reasoning-section {
            margin-bottom: 20px;
        }

        .reasoning-section:last-child {
            margin-bottom: 0;
        }

        .reasoning-section-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e2e8f0;
        }

        .reasoning-item {
            padding: 8px 12px;
            background: white;
            border-radius: 4px;
            margin-bottom: 6px;
            border: 1px solid #e5e7eb;
        }

        .reasoning-item:last-child {
            margin-bottom: 0;
        }

        .reasoning-label {
            color: #64748b;
            min-width: 120px;
            display: inline-block;
        }

        .reasoning-value {
            color: #1e293b;
        }

        .reasoning-score {
            color: #059669;
            font-weight: 500;
        }

        .reasoning-reason {
            color: #6b7280;
            font-style: italic;
            margin-top: 4px;
            padding-left: 12px;
            border-left: 2px solid #e5e7eb;
        }

        .reasoning-chart-item {
            padding: 6px 12px;
            text-align: left;
        }

        .reasoning-chart-title {
            color: #1e293b;
            display: block;
        }

        .reasoning-chart-title::first-letter {
            font-weight: 600;
        }

        .reasoning-timestamp {
            text-align: right;
            color: #94a3b8;
            font-size: 11px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #e2e8f0;
        }

        /* Checkbox UI für Chart-Auswahl - ÜBER der Chart-Box */
        .chart-wrapper {
            max-width: 1400px;
            margin: 0 auto 40px auto;
        }

        .chart-select-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-left: 4px;
        }

        .chart-select-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #2563eb;
        }

        .chart-select-row label {
            font-size: 13px;
            color: #64748b;
            cursor: pointer;
            user-select: none;
        }

        .chart-select-row label:hover {
            color: #1e293b;
        }

        .export-selection-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 20px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
            max-width: 1400px;  /* Gleiche Breite wie Chart-Container */
            margin-left: auto;
            margin-right: auto;
        }

        .export-selection-bar .selection-info {
            font-size: 14px;
            color: #64748b;
        }

        .export-selection-bar .selection-count {
            font-weight: 600;
            color: #1e293b;
        }

        .export-selection-bar .btn-toggle-all {
            padding: 6px 12px;
            font-size: 13px;
            background: #fff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-selection-bar .btn-toggle-all:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .btn-export-selected {
            margin-left: auto;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-export-selected:hover:not(:disabled) {
            background: #1d4ed8;
        }

        .btn-export-selected:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        .chart-container.selected {
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }
    </style>
</head>
<body>
    <nav class="nav-bar">
        <a href="colors.html" class="btn btn-secondary">
            <span>&larr;</span> Zurück
        </a>
        <div class="nav-buttons">
            <button class="btn btn-pptx" onclick="downloadSelectedAsPPTX()" title="Ausgewählte Charts als PowerPoint">
                Ausgewählte als PPTX
            </button>
            <button class="btn btn-primary" onclick="downloadSelectedAsZIP()">
                Ausgewählte als ZIP
            </button>
        </div>
    </nav>

    <h1 id="page-title">Chart-Beispiele - Think-Cell Stil</h1>
    <p class="page-subtitle" id="page-subtitle">Basierend auf den analysierten Daten</p>

    <!-- Export-Auswahl-Leiste -->
    <div class="export-selection-bar" id="selectionBar" style="display: none;">
        <span class="selection-info">
            <span class="selection-count" id="selectionCount">0</span> von <span id="totalCharts">0</span> Charts ausgewählt
        </span>
        <button class="btn-toggle-all" onclick="toggleAllCharts()">Alle auswählen</button>
        <button class="btn-toggle-all" onclick="deselectAllCharts()">Keine auswählen</button>
    </div>

    <div id="charts-wrapper">
        <!-- Charts werden hier dynamisch eingefügt -->
    </div>

    <!-- KI-Entscheidungen (Chain of Thought) -->
    <details class="reasoning-container" id="ai-reasoning-section" style="display: none;">
        <summary>Entscheidungsprotokoll anzeigen</summary>
        <div class="reasoning-content" id="reasoningContent">
            <!-- Wird dynamisch gefuellt -->
        </div>
    </details>

    <footer>
        Chart-Generierung &middot; <span id="current-date"></span>
    </footer>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // =====================================================
        // GLOBALE VARIABLEN
        // =====================================================

        let analysisResult = null;
        let companyColors = [];
        let chartConfigs = [];
        let renderedCharts = {}; // Speichert SVG-Inhalte für Export
        let chartCount = 12; // Generiere alle Templates des gewählten Typs (max 12)
        let selectedChartsForExport = new Set(); // Tracks which charts are selected for export

        // KI-Entscheidungsdaten für Chain-of-Thought Anzeige
        let aiReasoningData = {
            profile: null,
            selectedTemplates: [],
            chartConfigs: [],
            timestamp: null,
            chartType: null,
            chartCount: 0,
            generationMode: 'demo', // Nur noch 2 Modi: 'ai' oder 'demo'
            errors: [], // Fehler die waehrend der Generierung auftreten
            apiKeyPresent: false,
            loadedPrompts: [], // Welche Prompts wurden geladen (Name, Größe, Quelle)
            reasoning: {
                chartTypeReason: '',
                templateReasons: [],
                dataInsights: [],
                mixStrategy: ''
            }
        };

        // Default-Farben wenn keine Company Colors definiert
        const DEFAULT_COLORS = {
            waterfall: {
                start: '#1B4F72',
                end: '#1B4F72',
                positive: '#27AE60',
                negative: '#E74C3C',
                compare: '#7F8C8D',
                connector: '#333333'
            },
            bar: ['#CCCCCC', '#999999', '#666666', '#0066B1'],
            stacked: ['#1E3A5F', '#2E5A88', '#5B8DBE', '#8BBDE0', '#B8D4E8', '#D9E8F0']
        };

        // =====================================================
        // LAYOUT-RANKING-SYSTEM (NEU)
        // Verwendet vordefinierte Layouts + API-basiertes Ranking
        // =====================================================

        // Layout-Kataloge werden beim Start geladen
        const LAYOUT_CATALOGS = {
            waterfall: null,
            bar: null,
            'stacked-bar': null
        };

        // Flag ob das neue Ranking-System verwendet werden soll
        const USE_LAYOUT_RANKING = true;

        // =====================================================
        // MODUL 0: CONFIG LOADER (NEU - Zentrale Konfigurationsverwaltung)
        // Lädt externe JSON-Dateien: color-schemes.json, chart-examples.json
        // =====================================================
        const ConfigLoader = {
            cache: {},
            basePath: '../6. Bibliotheken/',

            /**
             * Lädt eine JSON-Datei und cached das Ergebnis
             * @param {string} filename - Name der Datei (z.B. 'color-schemes.json')
             * @returns {Promise<Object>} Geladene Daten
             */
            async loadJSON(filename) {
                if (this.cache[filename]) {
                    return this.cache[filename];
                }

                try {
                    const response = await fetch(this.basePath + filename);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const data = await response.json();
                    this.cache[filename] = data;
                    console.log(`ConfigLoader: ${filename} geladen`);
                    return data;
                } catch (error) {
                    console.warn(`ConfigLoader: Fehler beim Laden von ${filename}:`, error.message);
                    return null;
                }
            },

            /**
             * Lädt Farbschemas aus color-schemes.json
             * @returns {Promise<Object>} Farbschemas oder null
             */
            async getColorSchemes() {
                return this.loadJSON('color-schemes.json');
            },

            /**
             * Lädt Beispiel-Konfigurationen für einen Chart-Typ
             * @param {string} chartType - 'waterfall', 'bar', oder 'stacked_bar'
             * @returns {Promise<Array>} Array von Beispiel-Configs
             */
            async getChartExamples(chartType) {
                const data = await this.loadJSON('chart-examples.json');
                if (!data || !data.examples) return [];
                // Normalisiere den Typ (stacked-bar → stacked_bar)
                const normalizedType = chartType.replace('-', '_');
                return data.examples[normalizedType] || [];
            },

            /**
             * Lädt alle Beispiele für alle Chart-Typen
             * @returns {Promise<Object>} Alle Beispiele gruppiert nach Typ
             */
            async getAllExamples() {
                const data = await this.loadJSON('chart-examples.json');
                return data?.examples || {};
            },

            /**
             * Prüft ob externe Konfigurationen verfügbar sind
             * @returns {Promise<boolean>} true wenn externe Configs geladen werden konnten
             */
            async isAvailable() {
                const colorSchemes = await this.getColorSchemes();
                return colorSchemes !== null;
            }
        };

        // =====================================================
        // MODUL 1: TEMPLATE LOADER
        // Lädt und cached die Template-Bibliothek (templates.json)
        // =====================================================
        const TemplateLoader = {
            templates: null,
            loaded: false,
            loading: null,

            /**
             * Lädt templates.json und cached die Templates
             * @returns {Promise<Object>} Template-Bibliothek
             */
            async load() {
                if (this.loaded && this.templates) {
                    return this.templates;
                }

                // Verhindere parallele Ladevorgänge
                if (this.loading) {
                    return this.loading;
                }

                this.loading = (async () => {
                    try {
                        // Relativer Pfad zur templates.json
                        const response = await fetch('../6. Bibliotheken/templates.json');
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        this.templates = await response.json();
                        this.loaded = true;
                        console.log(`TemplateLoader: ${this.templates.total_templates} Templates geladen`);
                        return this.templates;
                    } catch (error) {
                        console.error('TemplateLoader: Fehler beim Laden:', error);
                        // Fallback: Leere Struktur
                        this.templates = {
                            version: '1.0',
                            templates: { waterfall: [], stacked_bar: [], bar: [] }
                        };
                        this.loaded = true;
                        return this.templates;
                    } finally {
                        this.loading = null;
                    }
                })();

                return this.loading;
            },

            /**
             * Gibt alle Templates eines bestimmten Typs zurück
             * @param {string} type - 'waterfall', 'stacked_bar', oder 'bar'
             * @returns {Array} Array von Templates
             */
            getByType(type) {
                if (!this.loaded || !this.templates) {
                    console.warn('TemplateLoader: Templates nicht geladen');
                    return [];
                }
                // Normalisiere den Typ (stacked-bar → stacked_bar)
                const normalizedType = type.replace('-', '_');
                return this.templates.templates[normalizedType] || [];
            },

            /**
             * Gibt ein einzelnes Template anhand der ID zurück
             * @param {string} id - Template-ID (z.B. 'WF-01', 'BC-03')
             * @returns {Object|null} Template oder null
             */
            getById(id) {
                if (!this.loaded || !this.templates) {
                    console.warn('TemplateLoader: Templates nicht geladen');
                    return null;
                }
                // Durchsuche alle Template-Typen
                for (const type of ['waterfall', 'stacked_bar', 'bar']) {
                    const templates = this.templates.templates[type] || [];
                    const found = templates.find(t => t.template_id === id);
                    if (found) return found;
                }
                return null;
            },

            /**
             * Gibt alle Templates zurück
             * @returns {Array} Flaches Array aller Templates
             */
            getAll() {
                if (!this.loaded || !this.templates) {
                    console.warn('TemplateLoader: Templates nicht geladen');
                    return [];
                }
                const all = [];
                for (const type of ['waterfall', 'stacked_bar', 'bar']) {
                    all.push(...(this.templates.templates[type] || []));
                }
                return all;
            },

            /**
             * Filtert Templates nach Kriterien
             * @param {Object} criteria - Filter-Kriterien
             * @returns {Array} Gefilterte Templates
             */
            filter(criteria) {
                let templates = this.getAll();

                if (criteria.chart_type) {
                    templates = templates.filter(t => t.chart_type === criteria.chart_type);
                }
                if (criteria.target_audience) {
                    templates = templates.filter(t =>
                        t.metadata?.target_audience === criteria.target_audience);
                }
                if (criteria.analysis_perspective) {
                    templates = templates.filter(t =>
                        t.metadata?.analysis_perspective === criteria.analysis_perspective);
                }
                if (criteria.detail_level) {
                    templates = templates.filter(t =>
                        t.metadata?.detail_level === criteria.detail_level);
                }

                return templates;
            }
        };

        // =====================================================
        // MODUL 2: DATA PROFILER
        // Analysiert Daten ohne KI-Aufruf (reine JavaScript-Logik)
        // =====================================================
        const DataProfiler = {
            /**
             * Erstellt ein Profil des Datensatzes für die Template-Auswahl
             * @param {Object} analysisResult - Ergebnis des DATA_ANALYZER
             * @returns {Object} Daten-Profil
             */
            profile(analysisResult) {
                const parsed = analysisResult?.parsed || analysisResult;
                const analysis = parsed?.analysis || {};
                const extractedData = parsed?.extractedData || {};
                const metadata = parsed?.metadata || {};

                return {
                    // Report-Typ identifizieren
                    report_type: this._detectReportType(analysis, extractedData),

                    // Datenumfang
                    row_count: this._countRows(extractedData, analysis),
                    period_count: this._countPeriods(analysis, metadata),

                    // Verfügbare Datenarten
                    has_variance_column: this._hasVariance(analysis, extractedData),
                    has_time_series: this._hasTimeSeries(analysis, metadata),
                    has_budget: this._hasValueType(analysis, 'BUD'),
                    has_forecast: this._hasValueType(analysis, 'FC'),
                    has_prior_year: this._hasValueType(analysis, 'VJ'),

                    // Verfügbare Felder
                    available_fields: this._extractFieldNames(extractedData, analysis),
                    available_value_types: this._extractValueTypes(analysis),

                    // Chart-Empfehlung aus Analyse
                    recommended_chart: parsed?.recommendation?.primaryChart || 'waterfall',

                    // Rohdaten-Referenz
                    raw_data: analysisResult?.csvData || analysisResult?.rawData || ''
                };
            },

            /**
             * Erkennt den Report-Typ (P&L, Balance Sheet, Cashflow, etc.)
             */
            _detectReportType(analysis, extractedData) {
                const keywords = analysis?.dataType?.toLowerCase() || '';

                if (keywords.includes('guv') || keywords.includes('income') ||
                    keywords.includes('p&l') || keywords.includes('gewinn')) {
                    return 'income_statement';
                }
                if (keywords.includes('bilanz') || keywords.includes('balance')) {
                    return 'balance_sheet';
                }
                if (keywords.includes('cashflow') || keywords.includes('kapitalfluss')) {
                    return 'cashflow';
                }
                if (keywords.includes('kosten') || keywords.includes('cost')) {
                    return 'cost_report';
                }
                if (keywords.includes('umsatz') || keywords.includes('revenue') ||
                    keywords.includes('sales')) {
                    return 'revenue_report';
                }

                // Fallback: Analysiere die extrahierten Daten
                if (extractedData?.waterfall?.bars) {
                    const labels = extractedData.waterfall.bars.map(b =>
                        (b.label || '').toLowerCase());
                    if (labels.some(l => l.includes('umsatz') || l.includes('revenue'))) {
                        return 'income_statement';
                    }
                }

                return 'financial_report';
            },

            /**
             * Zählt die Anzahl der Datenzeilen
             */
            _countRows(extractedData, analysis) {
                // Versuche aus verschiedenen Quellen
                if (extractedData?.waterfall?.bars) {
                    return extractedData.waterfall.bars.length;
                }
                if (extractedData?.bar?.categories) {
                    return extractedData.bar.categories.length;
                }
                if (extractedData?.stacked?.categories) {
                    return extractedData.stacked.categories.length;
                }
                if (analysis?.rowCount) {
                    return analysis.rowCount;
                }
                return 10; // Default-Annahme
            },

            /**
             * Zählt die Anzahl der Perioden
             */
            _countPeriods(analysis, metadata) {
                if (metadata?.periodCount) return metadata.periodCount;
                if (analysis?.periods?.length) return analysis.periods.length;
                if (analysis?.timeRange && typeof analysis.timeRange === 'string') {
                    // Versuche aus timeRange zu extrahieren
                    const match = analysis.timeRange.match(/(\d{4})/g);
                    if (match) return match.length;
                }
                return 1;
            },

            /**
             * Prüft ob Varianz-Daten vorhanden sind
             */
            _hasVariance(analysis, extractedData) {
                if (analysis?.hasVariance) return true;
                if (extractedData?.waterfall?.bars) {
                    const types = extractedData.waterfall.bars.map(b => b.type);
                    return types.includes('increase') || types.includes('decrease');
                }
                return false;
            },

            /**
             * Prüft ob Zeitreihen-Daten vorhanden sind
             */
            _hasTimeSeries(analysis, metadata) {
                if (metadata?.isTimeSeries) return true;
                if (analysis?.dataFormat?.toLowerCase().includes('zeitreihe')) return true;
                if (analysis?.periods?.length > 2) return true;
                return false;
            },

            /**
             * Prüft ob eine bestimmte Wertart vorhanden ist
             */
            _hasValueType(analysis, type) {
                const types = analysis?.valueTypes || [];
                const typeMap = {
                    'IST': ['ist', 'actual', 'fy', 'cy'],
                    'BUD': ['bud', 'budget', 'plan'],
                    'FC': ['fc', 'forecast', 'prognose'],
                    'VJ': ['vj', 'py', 'prior', 'vorjahr']
                };

                const keywords = typeMap[type] || [];
                return types.some(t =>
                    keywords.some(k => t.toLowerCase().includes(k))
                );
            },

            /**
             * Extrahiert Feldnamen aus den Daten
             */
            _extractFieldNames(extractedData, analysis) {
                const fields = new Set();

                // Aus Waterfall-Bars
                if (extractedData?.waterfall?.bars) {
                    extractedData.waterfall.bars.forEach(b => {
                        if (b.label) fields.add(b.label);
                    });
                }

                // Aus Bar-Kategorien
                if (extractedData?.bar?.categories) {
                    extractedData.bar.categories.forEach(c => fields.add(c));
                }

                // Aus Stacked-Kategorien
                if (extractedData?.stacked?.categories) {
                    extractedData.stacked.categories.forEach(c => fields.add(c));
                }

                // Aus Analysis
                if (analysis?.fields) {
                    analysis.fields.forEach(f => fields.add(f));
                }

                return Array.from(fields);
            },

            /**
             * Extrahiert verfügbare Wertarten
             */
            _extractValueTypes(analysis) {
                const types = [];
                if (this._hasValueType(analysis, 'IST')) types.push('IST');
                if (this._hasValueType(analysis, 'VJ')) types.push('VJ');
                if (this._hasValueType(analysis, 'BUD')) types.push('BUD');
                if (this._hasValueType(analysis, 'FC')) types.push('FC');

                // Fallback wenn nichts erkannt wurde
                if (types.length === 0) types.push('IST');

                return types;
            }
        };

        // =====================================================
        // MODUL 3: API CLIENT
        // Einheitlicher Client für Anthropic und OpenAI
        // MIT ANTHROPIC PROMPT CACHING für 90% Kostenersparnis bei wiederholten Calls
        // =====================================================
        const APIClient = {
            provider: 'anthropic',
            apiKey: null,

            // Cache-Statistiken für Monitoring
            cacheStats: {
                totalCacheHits: 0,
                totalCacheWrites: 0,
                totalTokensSaved: 0
            },

            /**
             * Initialisiert den API Client
             */
            init(apiKey, provider = 'anthropic') {
                this.apiKey = apiKey;
                this.provider = provider;
            },

            /**
             * Führt einen API-Call aus
             * @param {string} systemPrompt - System-Prompt
             * @param {string} userPrompt - User-Prompt mit Daten
             * @param {Object} options - Zusätzliche Optionen
             * @param {number} options.maxTokens - Maximale Ausgabe-Tokens (default: 4096)
             * @param {boolean} options.enableCaching - Prompt Caching aktivieren (default: true für Anthropic)
             * @returns {Promise<string>} API-Antwort
             */
            async call(systemPrompt, userPrompt, options = {}) {
                const maxTokens = options.maxTokens || 4096;
                const enableCaching = options.enableCaching !== false; // Default: true

                if (this.provider === 'anthropic') {
                    return this._callAnthropic(systemPrompt, userPrompt, maxTokens, { enableCaching });
                } else {
                    return this._callOpenAI(systemPrompt, userPrompt, maxTokens);
                }
            },

            /**
             * Anthropic API Call mit Prompt Caching Support
             * Caching reduziert Kosten um bis zu 90% bei wiederholten Calls mit gleichem System-Prompt
             *
             * @param {string} systemPrompt - Der System-Prompt (wird gecacht)
             * @param {string} userPrompt - Der User-Prompt mit den Daten
             * @param {number} maxTokens - Maximale Ausgabe-Tokens
             * @param {Object} options - { enableCaching: boolean }
             */
            async _callAnthropic(systemPrompt, userPrompt, maxTokens, options = {}) {
                console.log('APIClient: Starte Anthropic API Call...');

                // AbortController für Timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s Timeout

                // System-Prompt: String → Array mit cache_control für Prompt Caching
                let systemContent;
                const estimatedTokens = Math.round(systemPrompt.length / 4);

                // Caching nur aktivieren wenn:
                // 1. enableCaching = true
                // 2. Prompt hat mindestens 1024 Tokens (Anthropic Minimum)
                if (options.enableCaching && estimatedTokens >= 1024) {
                    systemContent = [{
                        type: 'text',
                        text: systemPrompt,
                        cache_control: { type: 'ephemeral' }
                    }];
                    console.log(`APIClient: Prompt Caching aktiviert (~${estimatedTokens} Tokens, TTL: 5 Min)`);
                } else {
                    // Ohne Caching: einfacher String
                    systemContent = systemPrompt;
                    if (options.enableCaching && estimatedTokens < 1024) {
                        console.log(`APIClient: Prompt zu kurz für Caching (~${estimatedTokens} < 1024 Tokens)`);
                    }
                }

                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: maxTokens,
                            system: systemContent,  // Array-Format für Caching
                            messages: [{ role: 'user', content: userPrompt }]
                        }),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`Anthropic API Error: ${error.error?.message || response.statusText}`);
                    }

                    const data = await response.json();

                    // Cache-Statistiken loggen und tracken
                    if (data.usage) {
                        const { cache_creation_input_tokens, cache_read_input_tokens, input_tokens } = data.usage;

                        if (cache_read_input_tokens > 0) {
                            // Cache HIT - 90% Ersparnis auf diese Tokens!
                            this.cacheStats.totalCacheHits++;
                            this.cacheStats.totalTokensSaved += Math.round(cache_read_input_tokens * 0.9);
                            console.log(`✓ CACHE HIT: ${cache_read_input_tokens} Tokens aus Anthropic-Cache gelesen (90% günstiger)`);
                        } else if (cache_creation_input_tokens > 0) {
                            // Cache WRITE - 25% Aufschlag für erste Anfrage
                            this.cacheStats.totalCacheWrites++;
                            console.log(`Cache geschrieben: ${cache_creation_input_tokens} Tokens (TTL: 5 Min, +25% einmalig)`);
                        }

                        const totalInputTokens = (input_tokens || 0) + (cache_read_input_tokens || 0) + (cache_creation_input_tokens || 0);
                        console.log(`APIClient: Input-Tokens gesamt: ${totalInputTokens}, Output: ${data.usage.output_tokens || 'N/A'}`);
                    }

                    console.log('APIClient: Anthropic API Antwort erhalten');
                    return data.content[0].text;
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error('API Timeout: Anfrage dauerte länger als 60 Sekunden');
                    }
                    throw error;
                }
            },

            /**
             * OpenAI API Call (ohne Prompt Caching - nicht unterstützt)
             */
            async _callOpenAI(systemPrompt, userPrompt, maxTokens) {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        max_tokens: maxTokens,
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ]
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(`OpenAI API Error: ${error.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            },

            /**
             * Gibt Cache-Statistiken zurück
             * @returns {Object} - { totalCacheHits, totalCacheWrites, totalTokensSaved, estimatedSavings }
             */
            getCacheStats() {
                // Geschätzte Ersparnis in USD (bei $3/MTok Input, $0.30/MTok Cache-Read)
                const estimatedSavings = (this.cacheStats.totalTokensSaved / 1000000) * 2.70; // $3 - $0.30 = $2.70 pro MTok
                return {
                    ...this.cacheStats,
                    estimatedSavingsUSD: estimatedSavings.toFixed(4)
                };
            },

            /**
             * Parst JSON aus einer API-Antwort mit Auto-Repair für unvollständiges JSON
             */
            parseJSON(response) {
                // Debug: Zeige die ersten 200 Zeichen der Antwort
                console.log('parseJSON: Input (erste 200 Zeichen):', response?.substring(0, 200));

                if (!response || typeof response !== 'string') {
                    throw new Error('Keine gültige Antwort erhalten');
                }

                // Entferne Markdown-Code-Blöcke und BOM
                let cleaned = response
                    .replace(/^\uFEFF/, '')                              // BOM entfernen
                    .replace(/```json\s*/gi, '')
                    .replace(/```\s*/g, '')
                    .replace(/^[\s\S]*?(?=\{)/m, '')                     // Alles VOR dem ersten { entfernen
                    .trim();

                // Finde das JSON-Objekt (vom ersten { bis zum Ende)
                const startIndex = cleaned.indexOf('{');
                if (startIndex === -1) {
                    console.error('parseJSON: Kein JSON-Objekt gefunden in:', cleaned.substring(0, 500));
                    throw new Error('Kein JSON-Objekt in der Antwort gefunden');
                }

                let jsonStr = cleaned.substring(startIndex);

                // Spezialfall: Prüfe ob JSON mit ungültigem Zeichen nach { beginnt
                // Fehler "Expected property name or '}'" bei Position 6 bedeutet oft: { + Whitespace + ungültiges Zeichen
                const afterBrace = jsonStr.substring(1).trim();
                if (afterBrace && !afterBrace.startsWith('"') && !afterBrace.startsWith('}')) {
                    // JSON beginnt nicht mit einem Property-Namen oder schließender Klammer
                    // Versuche, das nächste gültige JSON-Objekt zu finden
                    console.warn('parseJSON: Ungültiger JSON-Start erkannt, suche alternatives JSON-Objekt');
                    const nextBrace = jsonStr.indexOf('{', 1);
                    if (nextBrace !== -1) {
                        jsonStr = jsonStr.substring(nextBrace);
                        console.log('parseJSON: Alternatives JSON-Objekt gefunden bei Position', nextBrace);
                    }
                }

                // Versuche zuerst direktes Parsen
                try {
                    return JSON.parse(jsonStr);
                } catch (firstError) {
                    console.warn('parseJSON: Erstes Parsen fehlgeschlagen, versuche Reparatur...', firstError.message);

                    // Schritt 1: Repariere abgeschnittene Strings
                    // Finde offene Strings und schließe sie
                    let repaired = jsonStr;
                    let inString = false;
                    let lastStringStart = -1;
                    let escapeNext = false;

                    for (let i = 0; i < repaired.length; i++) {
                        const char = repaired[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\' && inString) {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            if (!inString) {
                                inString = true;
                                lastStringStart = i;
                            } else {
                                inString = false;
                            }
                        }
                    }

                    // Wenn wir in einem offenen String enden, schließe ihn
                    if (inString && lastStringStart !== -1) {
                        console.warn('parseJSON: Offener String gefunden, schließe ihn');
                        repaired += '"';
                    }

                    // Schritt 2: Zähle offene/geschlossene Klammern
                    let openBraces = 0;
                    let openBrackets = 0;
                    inString = false;
                    escapeNext = false;

                    for (let i = 0; i < repaired.length; i++) {
                        const char = repaired[i];

                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }

                        if (char === '\\' && inString) {
                            escapeNext = true;
                            continue;
                        }

                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (char === '{') openBraces++;
                            else if (char === '}') openBraces--;
                            else if (char === '[') openBrackets++;
                            else if (char === ']') openBrackets--;
                        }
                    }

                    // Schritt 3: Entferne unvollständige letzte Elemente
                    // Entferne trailing comma, unvollständige key-value pairs
                    repaired = repaired
                        .replace(/,\s*$/, '')                           // Trailing comma
                        .replace(/,\s*"[^"]*":\s*$/, '')                // Unvollständiges key:value
                        .replace(/,\s*"[^"]*"\s*$/, '')                 // Key ohne Wert
                        .replace(/:\s*"[^"]*$/, ': ""')                 // Abgeschnittener String-Wert
                        .replace(/:\s*-?\d+\.?\d*$/, ': 0');            // Abgeschnittene Zahl

                    // Schritt 4: Füge fehlende Klammern hinzu
                    for (let i = 0; i < openBrackets; i++) {
                        repaired += ']';
                    }
                    for (let i = 0; i < openBraces; i++) {
                        repaired += '}';
                    }

                    console.log(`parseJSON: Repariert - ${openBraces} fehlende }, ${openBrackets} fehlende ]`);

                    try {
                        return JSON.parse(repaired);
                    } catch (secondError) {
                        // Schritt 5: Aggressivere Reparatur - suche letztes gültiges Objekt/Array
                        console.warn('parseJSON: Einfache Reparatur fehlgeschlagen, versuche aggressivere Methode');

                        // Versuche, das JSON Zeichen für Zeichen zu kürzen bis es parst
                        let truncated = repaired;
                        for (let cutoff = truncated.length - 1; cutoff > 100; cutoff--) {
                            const attempt = truncated.substring(0, cutoff);
                            // Zähle Klammern für diesen Versuch
                            let braces = 0, brackets = 0;
                            let inStr = false, esc = false;
                            for (const c of attempt) {
                                if (esc) { esc = false; continue; }
                                if (c === '\\' && inStr) { esc = true; continue; }
                                if (c === '"') { inStr = !inStr; continue; }
                                if (!inStr) {
                                    if (c === '{') braces++;
                                    else if (c === '}') braces--;
                                    else if (c === '[') brackets++;
                                    else if (c === ']') brackets--;
                                }
                            }

                            // Baue den abgeschnittenen JSON zusammen
                            let fixed = attempt.replace(/,\s*$/, '');
                            for (let i = 0; i < brackets; i++) fixed += ']';
                            for (let i = 0; i < braces; i++) fixed += '}';

                            try {
                                const result = JSON.parse(fixed);
                                console.log(`parseJSON: Erfolgreich nach Kürzung um ${truncated.length - cutoff} Zeichen`);
                                return result;
                            } catch (e) {
                                // Weiter kürzen
                            }
                        }

                        console.error('parseJSON: Alle Reparaturversuche fehlgeschlagen');
                        console.error('parseJSON: Original (erste 500 Zeichen):', jsonStr.substring(0, 500));
                        throw new Error(`JSON Parse error: ${secondError.message}`);
                    }
                }
            }
        };

        // =====================================================
        // MODUL 4: CHART MIXER
        // Filtert Templates nach Typ und nutzt optional KI-Ranking
        // =====================================================
        const ChartMixer = {
            /**
             * Wählt Templates des gewählten Typs aus
             * @param {Object} profile - Daten-Profil vom DataProfiler
             * @param {Array} templates - Verfügbare Templates
             * @param {number} count - Max Anzahl (für Ranking)
             * @param {Array} allowedTypes - Erlaubte Chart-Typen (nur einer!)
             * @param {boolean} useRanking - Ob KI-Ranking verwendet werden soll
             * @returns {Promise<Array>} Ausgewählte Templates
             */
            async selectTemplates(profile, templates, count, allowedTypes = ['waterfall'], useRanking = false) {
                // Filtere Templates nach erlaubtem Typ
                const filtered = templates.filter(t =>
                    allowedTypes.includes(t.chart_type) ||
                    allowedTypes.includes(t.chart_type.replace('_', '-'))
                );

                console.log(`ChartMixer: ${filtered.length} Templates für Typ "${allowedTypes.join(', ')}" gefunden`);
                console.log('ChartMixer: Template-IDs:', filtered.map(t => t.template_id).join(', '));

                // Wenn Ranking aktiviert und API verfügbar
                if (useRanking && APIClient.apiKey && filtered.length > count) {
                    console.log(`ChartMixer: Starte KI-Ranking (${filtered.length} → max ${count})`);
                    try {
                        const ranked = await LayoutRanker.rank(
                            allowedTypes[0],
                            profile,
                            filtered,
                            count
                        );
                        if (ranked && ranked.length > 0) {
                            console.log(`ChartMixer: KI-Ranking erfolgreich - ${ranked.length} Templates ausgewählt`);
                            return ranked;
                        }
                    } catch (error) {
                        console.warn('ChartMixer: KI-Ranking fehlgeschlagen, verwende alle Templates:', error.message);
                    }
                }

                // Fallback: Alle Templates des Typs zurückgeben
                return filtered;
            }
        };

        // =====================================================
        // MODUL 4b: LAYOUT RANKER (NEU)
        // Wählt die besten Layouts INNERHALB eines Chart-Typs
        // Verhindert redundante/unpassende Layouts
        // =====================================================
        const LayoutRanker = {
            /**
             * Rankt Layouts eines Chart-Typs basierend auf Daten-Profil
             * @param {string} chartType - Der Chart-Typ (waterfall, bar, stacked_bar)
             * @param {Object} profile - Daten-Profil vom DataProfiler
             * @param {Array} templates - Verfügbare Templates des Typs
             * @param {number} maxCount - Maximale Anzahl zu generierender Layouts
             * @returns {Promise<Array>} Gerankte Templates
             */
            async rank(chartType, profile, templates, maxCount = 10) {
                console.log(`LayoutRanker: Starte Ranking für ${chartType} (${templates.length} → max ${maxCount})`);

                // Lade den Ranking-Prompt
                const rankingPrompt = await PromptLoader.load('layout_ranking');
                if (!rankingPrompt) {
                    console.warn('LayoutRanker: Ranking-Prompt nicht verfügbar');
                    return templates.slice(0, maxCount);
                }

                // Baue den API-Request
                const templateList = templates.map(t => ({
                    template_id: t.template_id,
                    name: t.name,
                    chart_type: t.chart_type,
                    description: t.description || '',
                    metadata: t.metadata || {}
                }));

                const userMessage = `
## Chart-Typ
${chartType}

## Daten-Profil
${JSON.stringify(profile, null, 2)}

## Gewünschte Anzahl
${maxCount}

## Verfügbare Templates
${JSON.stringify(templateList, null, 2)}

Wähle die ${maxCount} besten ${chartType}-Layouts für diese Daten.
Antworte NUR mit dem JSON-Objekt, keine Erklärungen.
`;

                try {
                    const response = await APIClient.call(
                        rankingPrompt,
                        userMessage,
                        4096  // Kleinere maxTokens für Ranking
                    );

                    // Parse die Antwort
                    const result = this._parseRankingResponse(response);

                    if (result && result.selected_layouts && result.selected_layouts.length > 0) {
                        // Mappe die IDs zurück zu den vollständigen Templates
                        const selectedIds = result.selected_layouts.map(l => l.template_id);
                        const rankedTemplates = [];

                        for (const id of selectedIds) {
                            const template = templates.find(t => t.template_id === id);
                            if (template) {
                                rankedTemplates.push(template);
                            }
                        }

                        console.log(`LayoutRanker: ${rankedTemplates.length} Templates ausgewählt:`, selectedIds);

                        // Speichere Reasoning für Debug
                        if (result.excluded_templates) {
                            console.log('LayoutRanker: Ausgeschlossene Templates:', result.excluded_templates);
                        }

                        return rankedTemplates;
                    }
                } catch (error) {
                    console.error('LayoutRanker: Fehler beim Ranking:', error.message);
                }

                // Fallback: Erste N Templates zurückgeben
                console.log('LayoutRanker: Fallback - erste', maxCount, 'Templates');
                return templates.slice(0, maxCount);
            },

            /**
             * Parst die KI-Antwort für Ranking
             */
            _parseRankingResponse(response) {
                try {
                    // Versuche direkt zu parsen
                    if (typeof response === 'object') {
                        return response;
                    }

                    // String-Antwort: JSON extrahieren
                    let jsonStr = response;

                    // Entferne Markdown Code-Blöcke
                    if (jsonStr.includes('```json')) {
                        jsonStr = jsonStr.split('```json')[1].split('```')[0];
                    } else if (jsonStr.includes('```')) {
                        jsonStr = jsonStr.split('```')[1].split('```')[0];
                    }

                    return JSON.parse(jsonStr.trim());
                } catch (error) {
                    console.error('LayoutRanker: JSON Parse Fehler:', error.message);
                    return null;
                }
            }
        };

        // =====================================================
        // MODUL 5: CONFIG GENERATOR
        // Generiert Chart-Configs aus Templates + Daten
        // =====================================================
        const ConfigGenerator = {
            /**
             * Generiert eine Chart-Config aus Template und Daten
             * @param {Object} template - Das ausgewählte Template
             * @param {Object} data - Die Quelldaten
             * @param {Object} colors - Die Farbpalette
             * @param {string} detectedLanguage - Erkannte Sprache der Quelldaten ('de', 'en', 'unknown')
             * @returns {Promise<Object>} Fertige Chart-Config
             */
            async generate(template, data, colors, detectedLanguage = 'unknown') {
                const chartType = template.chart_type;

                // Lade den passenden Prompt aus .md-Datei (via PromptLoader)
                let prompt;
                switch (chartType) {
                    case 'waterfall':
                        prompt = await PromptLoader.load('waterfall');
                        break;
                    case 'bar':
                        prompt = await PromptLoader.load('bar');
                        break;
                    case 'stacked_bar':
                    case 'stacked-bar':
                        prompt = await PromptLoader.load('stacked_bar');
                        break;
                    default:
                        throw new Error(`Unbekannter Chart-Typ: ${chartType}`);
                }

                // Prüfe ob API-Key vorhanden
                if (!APIClient.apiKey) {
                    throw new Error('Kein API-Key vorhanden - Demo-Modus erforderlich');
                }

                // KI-Generierung
                console.log('ConfigGenerator: Starte KI-Generierung für Template:', template.template_id);
                const config = await this._generateWithAI(template, data, colors, prompt, detectedLanguage);
                config._generatedBy = 'ai'; // Markiere als KI-generiert
                console.log('ConfigGenerator: KI-Generierung erfolgreich');
                return config;
                // Fehler werden nach oben propagiert für Demo-Modus
            },

            /**
             * KI-gestützte Config-Generierung
             * @param {Object} template - Das ausgewählte Template
             * @param {Object} data - Die Quelldaten
             * @param {Object} colors - Die Farbpalette
             * @param {string} prompt - Der System-Prompt für den Chart-Typ
             * @param {string} detectedLanguage - Erkannte Sprache ('de', 'en', 'unknown')
             */
            async _generateWithAI(template, data, colors, prompt, detectedLanguage = 'unknown') {
                const fieldMappingPrompt = await PromptLoader.load('field_mapping');
                const chartType = template.chart_type;

                console.log(`ConfigGenerator._generateWithAI: Template ${template.template_id}, Typ: ${chartType}, Sprache: ${detectedLanguage}`);

                // Sprach-Hinweis erstellen
                let languageNote;
                if (detectedLanguage === 'de') {
                    languageNote = 'Die Quelldaten sind auf DEUTSCH. Verwende AUSSCHLIESSLICH deutsche Labels!';
                } else if (detectedLanguage === 'en') {
                    languageNote = 'Die Quelldaten sind auf ENGLISCH. Verwende AUSSCHLIESSLICH englische Labels!';
                } else {
                    languageNote = 'Behalte die Original-Sprache der Labels bei!';
                }

                // Lade passende Beispiele aus externer JSON (modular)
                let examplesSection = '';
                try {
                    const examples = await ConfigLoader.getChartExamples(chartType);
                    if (examples && examples.length > 0) {
                        // Wähle Beispiel basierend auf Sprache
                        const relevantExamples = examples.filter(e =>
                            e.language === detectedLanguage || detectedLanguage === 'unknown'
                        ).slice(0, 2); // Max 2 Beispiele

                        if (relevantExamples.length > 0) {
                            examplesSection = `
## Beispiel-Konfigurationen (zur Orientierung)
Die folgenden Beispiele zeigen das erwartete Format. WICHTIG: Verwende Labels aus deinen Quelldaten, NICHT aus diesen Beispielen!

${relevantExamples.map((ex, i) => `### Beispiel ${i + 1}: ${ex.description}
\`\`\`json
${JSON.stringify(ex.config, null, 2)}
\`\`\`
`).join('\n')}`;
                            console.log(`ConfigGenerator: ${relevantExamples.length} Beispiele für ${chartType} geladen`);
                        }
                    }
                } catch (error) {
                    console.warn('Konnte Beispiele nicht laden:', error.message);
                    // Weiter ohne Beispiele - Prompt hat inline-Beispiele als Fallback
                }

                const userPrompt = `## Template
${JSON.stringify(template, null, 2)}

## Daten
${JSON.stringify(data, null, 2)}

## Farbpalette
${JSON.stringify(colors, null, 2)}
${examplesSection}
## KRITISCHE LABEL-ANWEISUNG:
${languageNote}

### Pflicht-Regeln für Labels:
1. Verwende EXAKT die Labels/Bezeichnungen aus den "Daten" oben
2. KEINE Übersetzungen (z.B. "Umsatz" → "Revenue" ist VERBOTEN)
3. KEINE Synonyme (z.B. "Kosten" → "Aufwendungen" ist VERBOTEN)
4. KEINE erfundenen Labels - nur was in den Daten steht
5. Schreibweise 1:1 übernehmen (Groß-/Kleinschreibung)

WICHTIG: Antworte NUR mit einem validen JSON-Objekt. Kein erklärender Text davor oder danach.
Generiere eine vollständige Chart-Konfiguration für dieses Template.
Befolge exakt das config-Format aus dem Prompt.`;

                try {
                    const response = await APIClient.call(prompt, userPrompt, { maxTokens: 16384 });
                    console.log(`ConfigGenerator._generateWithAI: Antwort erhalten für ${template.template_id} (${response?.length || 0} Zeichen)`);

                    let config = APIClient.parseJSON(response);

                    console.log(`ConfigGenerator._generateWithAI: Geparste Config für ${template.template_id}:`, Object.keys(config));

                    // WICHTIG: Behandle den Fall, dass die KI einen Wrapper verwendet
                    // Die Prompt-Beispiele zeigen "variant1" als Wrapper, also könnte die KI das auch verwenden
                    const wrapperKeys = ['variant1', 'variant2', 'config', 'chartConfig', 'data', 'chart'];
                    for (const key of wrapperKeys) {
                        if (config[key] && typeof config[key] === 'object') {
                            // Prüfe ob das Wrapper-Objekt die eigentliche Config enthält
                            const wrapped = config[key];
                            const hasChartData = wrapped.bars || wrapped.periods || wrapped.categories || wrapped.segments;
                            if (hasChartData) {
                                console.log(`ConfigGenerator._generateWithAI: Extrahiere config aus "${key}" Wrapper`);
                                config = wrapped;
                                break;
                            }
                        }
                    }

                    console.log(`ConfigGenerator._generateWithAI: Finale Config-Felder:`, Object.keys(config));

                    // Validiere die Config basierend auf Chart-Typ
                    if (chartType === 'waterfall') {
                        if (!config.bars || !Array.isArray(config.bars)) {
                            console.warn(`ConfigGenerator._generateWithAI: Waterfall-Config ohne bars-Array für ${template.template_id}`);
                            // Versuche bars aus anderen Feldern zu extrahieren
                            if (config.data && Array.isArray(config.data)) {
                                config.bars = config.data;
                            } else {
                                throw new Error(`Waterfall-Config für ${template.template_id} hat kein bars-Array`);
                            }
                        }
                    }

                    if (chartType === 'bar') {
                        // Bar-Charts brauchen periods UND categories mit values
                        if (!config.periods || !Array.isArray(config.periods) || config.periods.length === 0) {
                            console.error(`ConfigGenerator._generateWithAI: Bar-Config ohne periods für ${template.template_id}`);
                            console.error('Config:', JSON.stringify(config, null, 2).substring(0, 500));
                            throw new Error(`Bar-Config für ${template.template_id} hat keine periods`);
                        }
                        if (!config.categories || !Array.isArray(config.categories) || config.categories.length === 0) {
                            console.error(`ConfigGenerator._generateWithAI: Bar-Config ohne categories für ${template.template_id}`);
                            throw new Error(`Bar-Config für ${template.template_id} hat keine categories`);
                        }
                        // Prüfe ob categories values haben
                        const hasValues = config.categories.every(c => c.values && Array.isArray(c.values));
                        if (!hasValues) {
                            console.error(`ConfigGenerator._generateWithAI: Bar-Config categories ohne values für ${template.template_id}`);
                            throw new Error(`Bar-Config für ${template.template_id}: categories haben keine values`);
                        }
                    }

                    if (chartType === 'stacked_bar' || chartType === 'stacked-bar') {
                        // Stacked-Bar braucht categories UND segments mit values
                        if (!config.categories || !Array.isArray(config.categories) || config.categories.length === 0) {
                            console.error(`ConfigGenerator._generateWithAI: Stacked-Bar ohne categories für ${template.template_id}`);
                            throw new Error(`Stacked-Bar für ${template.template_id} hat keine categories`);
                        }
                        if (!config.segments || !Array.isArray(config.segments) || config.segments.length === 0) {
                            console.error(`ConfigGenerator._generateWithAI: Stacked-Bar ohne segments für ${template.template_id}`);
                            throw new Error(`Stacked-Bar für ${template.template_id} hat keine segments`);
                        }
                        // Prüfe ob segments values haben
                        const hasValues = config.segments.every(s => s.values && Array.isArray(s.values));
                        if (!hasValues) {
                            console.error(`ConfigGenerator._generateWithAI: Stacked-Bar segments ohne values für ${template.template_id}`);
                            throw new Error(`Stacked-Bar für ${template.template_id}: segments haben keine values`);
                        }
                    }

                    // Füge Chart-Typ zur Config hinzu für spätere Erkennung
                    config._chartType = chartType;

                    console.log(`ConfigGenerator._generateWithAI: ✅ Config für ${template.template_id} validiert`);
                    return config;
                } catch (error) {
                    console.error(`ConfigGenerator._generateWithAI: Fehler für ${template.template_id}:`, error.message);
                    throw error;
                }
            },

            /**
             * DEPRECATED - Nicht mehr verwendet
             * Regelbasierte Config-Generierung wurde durch reine KI-Generierung ersetzt.
             * Bei Fehlern wird direkt der Demo-Modus aktiviert.
             */
            _generateFromTemplate(template, data, colors) {
                const chartType = template.chart_type;

                switch (chartType) {
                    case 'waterfall':
                        return this._generateWaterfallConfig(template, data, colors);
                    case 'bar':
                        return this._generateBarConfig(template, data, colors);
                    case 'stacked_bar':
                    case 'stacked-bar':
                        return this._generateStackedBarConfig(template, data, colors);
                    default:
                        throw new Error(`Unbekannter Chart-Typ: ${chartType}`);
                }
            },

            /**
             * DEPRECATED - Nicht mehr verwendet (Teil des regelbasierten Systems)
             */
            _generateWaterfallConfig(template, data, colors) {
                const bars = [];
                const items = template.structure?.items || [];
                const extractedBars = data?.waterfall?.bars || data?.bars || [];

                // Mappe Template-Items auf Daten
                items.forEach((item, index) => {
                    const dataBar = extractedBars[index] || {};
                    bars.push({
                        type: item.type,
                        label: dataBar.label || item.label || `Item ${index + 1}`,
                        value: dataBar.value || 0,
                        displayValue: dataBar.displayValue || this._formatValue(dataBar.value)
                    });
                });

                return {
                    title: template.display_name || data?.title || 'Financial Overview',
                    subtitle: data?.subtitle || '',
                    colors: {
                        start: colors?.start || colors?.primary || '#1B4F72',
                        end: colors?.end || colors?.primary || '#1B4F72',
                        positive: colors?.increase || colors?.positive || '#27AE60',
                        negative: colors?.decrease || colors?.negative || '#E74C3C',
                        compare: colors?.compare || colors?.neutral || '#7F8C8D',
                        connector: colors?.connector || '#333333'
                    },
                    bars: bars,
                    bracket: {
                        show: bars.length > 2,
                        fromIndex: 0,
                        toIndex: bars.length - 1,
                        label: ''
                    }
                };
            },

            /**
             * DEPRECATED - Nicht mehr verwendet (Teil des regelbasierten Systems)
             */
            _generateBarConfig(template, data, colors) {
                const categories = data?.bar?.categories || data?.categories || [];
                const series = data?.bar?.series || data?.series || [];

                return {
                    title: template.display_name || data?.title || 'Comparison',
                    subtitle: data?.subtitle || '',
                    orientation: template.structure?.orientation || 'vertical',
                    colors: colors?.bar || ['#1B4F72', '#2E86AB', '#7FB069'],
                    categories: categories,
                    series: series
                };
            },

            /**
             * DEPRECATED - Nicht mehr verwendet (Teil des regelbasierten Systems)
             */
            _generateStackedBarConfig(template, data, colors) {
                const categories = data?.stacked?.categories || data?.categories || [];
                const series = data?.stacked?.series || data?.series || [];

                return {
                    title: template.display_name || data?.title || 'Composition',
                    subtitle: data?.subtitle || '',
                    stackMode: template.structure?.stack_mode || 'absolute',
                    colors: colors?.stacked || ['#1E3A5F', '#2E5A88', '#5B8DBE', '#8BBDE0'],
                    categories: categories,
                    series: series
                };
            },

            /**
             * Formatiert einen numerischen Wert
             */
            _formatValue(value) {
                if (typeof value !== 'number') return '';
                if (Math.abs(value) >= 1000000) {
                    return (value / 1000000).toFixed(1) + 'M';
                }
                if (Math.abs(value) >= 1000) {
                    return (value / 1000).toFixed(0) + 'K';
                }
                return value.toFixed(0);
            }
        };

        // =====================================================
        // MODUL: PromptLoader - Lädt Prompts aus .md-Dateien
        // VOLLSTÄNDIG laden (keine Marker-Extraktion mehr)
        // Mit Hash-basierter Cache-Validierung für Anthropic Prompt Caching
        // =====================================================
        const PromptLoader = {
            cache: {},           // { promptName: { content, hash, timestamp, size, tokens } }
            loadedPrompts: [],   // Tracking welche Prompts geladen wurden
            basePaths: {
                charts: '../4. Prompts/Prompts for Charts/',
                general: '../4. Prompts/'
            },

            // Mapping: Prompt-Name → Dateiname
            // HINWEIS: Nur noch die in charts.html benötigten Prompts
            // - color_schema: nur in colors.html benötigt
            promptFiles: {
                'waterfall': 'WATERFALL-CHART-PROMPT.md',
                'bar': 'BAR-CHART-PROMPT.md',
                'stacked_bar': 'STACKED-BAR-CHART-PROMPT.md',
                'field_mapping': 'FIELD-MAPPING-PROMPT.md',
                'layout_ranking': 'LAYOUT-RANKING-PROMPT.md'  // Intra-Typ Layout-Ranking
            },

            /**
             * Berechnet einen einfachen Hash für Cache-Validierung
             * @param {string} content - Der Inhalt zum Hashen
             * @returns {string} - Hexadezimaler Hash-String
             */
            computeHash(content) {
                let hash = 0;
                for (let i = 0; i < content.length; i++) {
                    const char = content.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash.toString(16);
            },

            /**
             * Prüft ob Cache-Eintrag noch gültig ist (Hash-Vergleich)
             * @param {string} promptName - Name des Prompts
             * @param {string} currentHash - Hash des aktuell geladenen Inhalts
             * @returns {boolean} - true wenn Cache valide
             */
            isCacheValid(promptName, currentHash) {
                const cached = this.cache[promptName];
                if (!cached) return false;

                // Hash-Vergleich: Datei geändert?
                if (cached.hash !== currentHash) {
                    console.log(`PromptLoader: Cache ungültig für '${promptName}' (Hash geändert: ${cached.hash} → ${currentHash})`);
                    return false;
                }

                return true;
            },

            /**
             * Extrahiert den relevanten Prompt-Inhalt basierend auf Markern
             * Reduziert Token-Anzahl durch Ausschluss von Dokumentation
             * @param {string} rawContent - Vollständiger Dateiinhalt
             * @param {string} promptName - Name des Prompts (für Logging)
             * @returns {string} - Extrahierter Prompt-Inhalt
             */
            extractPromptContent(rawContent, promptName) {
                const startMarker = '<!-- PROMPT-START -->';
                const endMarker = '<!-- PROMPT-END -->';
                const includeStartMarker = '<!-- PROMPT-INCLUDE -->';
                const includeEndMarker = '<!-- PROMPT-INCLUDE-END -->';

                let extractedContent = '';
                let usedMarkers = false;

                // 1. Haupt-Prompt zwischen PROMPT-START und PROMPT-END extrahieren
                const startIndex = rawContent.indexOf(startMarker);
                const endIndex = rawContent.indexOf(endMarker);

                if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                    // Haupt-Prompt extrahieren (ohne die Marker selbst)
                    extractedContent = rawContent.substring(
                        startIndex + startMarker.length,
                        endIndex
                    ).trim();
                    usedMarkers = true;
                }

                // 2. Alle PROMPT-INCLUDE Blöcke finden und hinzufügen
                let searchStart = 0;
                while (true) {
                    const includeStart = rawContent.indexOf(includeStartMarker, searchStart);
                    if (includeStart === -1) break;

                    const includeEnd = rawContent.indexOf(includeEndMarker, includeStart);
                    if (includeEnd === -1) break;

                    // Include-Block extrahieren
                    const includeContent = rawContent.substring(
                        includeStart + includeStartMarker.length,
                        includeEnd
                    ).trim();

                    if (includeContent) {
                        extractedContent += '\n\n' + includeContent;
                        usedMarkers = true;
                    }

                    searchStart = includeEnd + includeEndMarker.length;
                }

                // 3. Wenn keine Marker gefunden → vollständigen Inhalt verwenden
                if (!usedMarkers) {
                    console.log(`PromptLoader: '${promptName}' hat keine Marker - verwende vollständigen Inhalt`);
                    return rawContent;
                }

                // Token-Reduktion berechnen und loggen
                const originalTokens = Math.round(rawContent.length / 4);
                const extractedTokens = Math.round(extractedContent.length / 4);
                const reduction = Math.round((1 - extractedTokens / originalTokens) * 100);
                console.log(`PromptLoader: '${promptName}' extrahiert - ${reduction}% Token-Reduktion (${originalTokens} → ${extractedTokens})`);

                return extractedContent;
            },

            /**
             * Lädt einen Prompt aus der entsprechenden .md-Datei
             * Extrahiert nur Marker-Inhalt für Chart-Prompts
             * @param {string} promptName - Name des Prompts (z.B. 'waterfall', 'bar')
             * @param {boolean} forceReload - Cache ignorieren und neu laden
             * @returns {Promise<string>} - Der vollständige Prompt-Inhalt
             * @throws {Error} - Wenn Prompt nicht geladen werden kann
             */
            async load(promptName, forceReload = false) {
                const filename = this.promptFiles[promptName];
                if (!filename) {
                    throw new Error(`PromptLoader: Unbekannter Prompt '${promptName}'. Verfügbare Prompts: ${Object.keys(this.promptFiles).join(', ')}`);
                }

                const isChartPrompt = ['waterfall', 'bar', 'stacked_bar'].includes(promptName);
                const basePath = isChartPrompt ? this.basePaths.charts : this.basePaths.general;
                const fullPath = basePath + filename;

                try {
                    // Datei laden (immer für Hash-Berechnung)
                    const response = await fetch(fullPath);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status} beim Laden von ${fullPath}`);
                    }
                    const rawContent = await response.text();

                    if (!rawContent || rawContent.trim().length === 0) {
                        throw new Error(`Prompt-Datei ${fullPath} ist leer`);
                    }

                    // Hash berechnen
                    const currentHash = this.computeHash(rawContent);

                    // Cache-Validierung (wenn nicht forceReload)
                    if (!forceReload && this.isCacheValid(promptName, currentHash)) {
                        // Bei Cache-Hit: KEIN neuer Tracking-Eintrag (wurde bereits beim ersten Load getracked)
                        console.log(`PromptLoader: '${promptName}' aus Cache (Hash: ${currentHash}, ~${this.cache[promptName].tokens} Tokens)`);
                        return this.cache[promptName].content;
                    }

                    // Marker-basierte Extraktion für Chart-Prompts (Token-Reduktion)
                    const content = this.extractPromptContent(rawContent, promptName);
                    const tokens = Math.round(content.length / 4);

                    // Cache aktualisieren
                    this.cache[promptName] = {
                        content: content,
                        hash: currentHash,
                        timestamp: Date.now(),
                        size: content.length,
                        tokens: tokens
                    };

                    // Tracking für Protokoll (nur wenn noch nicht vorhanden)
                    if (!this.loadedPrompts.find(p => p.name === promptName)) {
                        this.loadedPrompts.push({
                            name: promptName,
                            file: filename,
                            size: content.length,
                            tokens: tokens,
                            source: forceReload ? 'reload' : 'fresh',
                            hash: currentHash
                        });
                    }

                    console.log(`PromptLoader: '${promptName}' geladen (${content.length} Zeichen, ~${tokens} Tokens, Hash: ${currentHash})`);
                    return content;

                } catch (error) {
                    // Kein Fallback - Fehler direkt weitergeben
                    const errorMsg = `FEHLER: Prompt '${promptName}' konnte nicht geladen werden.\n` +
                        `Datei: ${fullPath}\n` +
                        `Grund: ${error.message}\n\n` +
                        `HINWEIS: Stellen Sie sicher, dass:\n` +
                        `1. Die Anwendung über einen HTTP-Server läuft (nicht file://)\n` +
                        `2. Die Prompt-Datei existiert unter: 4. Prompts/\n` +
                        `3. Der Server Zugriff auf den Prompts-Ordner hat`;

                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }
            },

            /**
             * Lädt alle Prompts vor (für schnellere Generierung)
             * @throws {Error} - Wenn ein Prompt nicht geladen werden kann
             */
            async preloadAll() {
                const promptNames = Object.keys(this.promptFiles);
                const errors = [];

                for (const name of promptNames) {
                    try {
                        await this.load(name);
                    } catch (error) {
                        errors.push({ name, error: error.message });
                    }
                }

                if (errors.length > 0) {
                    const errorDetails = errors.map(e => `- ${e.name}: ${e.error}`).join('\n');
                    const errorMsg = `PromptLoader: ${errors.length} von ${promptNames.length} Prompts konnten nicht geladen werden:\n${errorDetails}`;
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }

                // Zusammenfassung ausgeben
                const totalTokens = Object.values(this.cache).reduce((sum, c) => sum + c.tokens, 0);
                const totalSize = Object.values(this.cache).reduce((sum, c) => sum + c.size, 0);
                console.log(`PromptLoader: Alle ${promptNames.length} Prompts geladen (${(totalSize/1024).toFixed(1)} KB, ~${totalTokens} Tokens gesamt)`);
            },

            /**
             * Prüft ob Prompts neu geladen werden müssen
             * Vergleicht Hashes der gecachten Prompts mit aktuellen Dateien
             * @returns {Promise<Object>} - { valid: [], invalid: [], errors: [] }
             */
            async validateCache() {
                const results = { valid: [], invalid: [], errors: [] };

                for (const [promptName, cached] of Object.entries(this.cache)) {
                    try {
                        const filename = this.promptFiles[promptName];
                        const isChartPrompt = ['waterfall', 'bar', 'stacked_bar'].includes(promptName);
                        const basePath = isChartPrompt ? this.basePaths.charts : this.basePaths.general;

                        const response = await fetch(basePath + filename);
                        const content = await response.text();
                        const currentHash = this.computeHash(content);

                        if (cached.hash === currentHash) {
                            results.valid.push(promptName);
                        } else {
                            results.invalid.push({
                                name: promptName,
                                oldHash: cached.hash,
                                newHash: currentHash
                            });
                        }
                    } catch (error) {
                        results.errors.push({ name: promptName, error: error.message });
                    }
                }

                console.log('PromptLoader: Cache-Validierung:', results);
                return results;
            },

            /**
             * Lädt ungültige Cache-Einträge neu
             * @returns {Promise<number>} - Anzahl neu geladener Prompts
             */
            async refreshInvalidCache() {
                const validation = await this.validateCache();

                for (const item of validation.invalid) {
                    console.log(`PromptLoader: Lade '${item.name}' neu (Hash geändert)`);
                    await this.load(item.name, true); // forceReload
                }

                return validation.invalid.length;
            },

            /**
             * Cache leeren (für Entwicklung/Debugging)
             */
            clearCache() {
                this.cache = {};
                this.loadedPrompts = [];
                console.log('PromptLoader: Cache geleert');
            },

            /**
             * Gibt Cache-Statistiken zurück
             * @returns {Object} - Statistiken über gecachte Prompts
             */
            getCacheStats() {
                const stats = {
                    count: Object.keys(this.cache).length,
                    prompts: {},
                    totalSize: 0,
                    totalTokens: 0
                };

                for (const [name, data] of Object.entries(this.cache)) {
                    stats.prompts[name] = {
                        size: data.size,
                        tokens: data.tokens,
                        hash: data.hash,
                        age: Date.now() - data.timestamp
                    };
                    stats.totalSize += data.size;
                    stats.totalTokens += data.tokens;
                }

                return stats;
            }
        };

        // Funktion zur Auswahl des richtigen Prompts basierend auf Chart-Typ
        // Verwendet PromptLoader für dynamisches Laden aus .md-Dateien
        async function getChartPromptByType(chartType) {
            const typeMap = {
                'waterfall': 'waterfall',
                'bar': 'bar',
                'stacked-bar': 'stacked_bar',
                'stacked_bar': 'stacked_bar'
            };
            return await PromptLoader.load(typeMap[chartType] || 'waterfall');
        }

        // =====================================================
        // LAYOUT-KATALOGE (inline für schnellen Zugriff)
        // Diese werden als Fallback verwendet, wenn templates.json nicht geladen werden kann
        // =====================================================
        const LAYOUT_CATALOG_WATERFALL = {"chartType":"waterfall","layouts":[{"id":"WF01","name":"Vollständige GuV-Bridge (IST)","cat":"pnl","tags":["guv","vollständig","ist","detail"],"pos":[5,12],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"revenue-to-profit"},{"id":"WF02","name":"Vollständige GuV-Bridge (FC)","cat":"pnl","tags":["guv","vollständig","forecast"],"pos":[5,12],"req":["FC"],"opt":["IST","BUD"],"pattern":"revenue-to-profit"},{"id":"WF03","name":"Vollständige GuV-Bridge (BUD)","cat":"pnl","tags":["guv","vollständig","budget","plan"],"pos":[5,12],"req":["BUD"],"opt":["IST","FC"],"pattern":"revenue-to-profit"},{"id":"WF04","name":"Kompakte GuV-Bridge (Top 3)","cat":"pnl","tags":["guv","kompakt","top3","management"],"pos":[3,5],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"revenue-to-profit"},{"id":"WF05","name":"Kompakte GuV-Bridge (Top 5)","cat":"pnl","tags":["guv","kompakt","top5"],"pos":[5,7],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"revenue-to-profit"},{"id":"WF06","name":"Margen-Bridge (Umsatz→EBIT)","cat":"focus","tags":["marge","ebit","vereinfacht","executive"],"pos":[2,4],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"margin-analysis"},{"id":"WF07","name":"Margen-Bridge (Umsatz→Netto)","cat":"focus","tags":["marge","nettoergebnis","bottom-line"],"pos":[3,6],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"margin-analysis"},{"id":"WF08","name":"IST vs. Budget","cat":"compare","tags":["ist","budget","vergleich","plan-ist"],"pos":[4,10],"req":["IST","BUD"],"opt":["FC"],"pattern":"budget-actual"},{"id":"WF09","name":"IST vs. Forecast","cat":"compare","tags":["ist","forecast","vergleich"],"pos":[4,10],"req":["IST","FC"],"opt":["BUD"],"pattern":"forecast-actual"},{"id":"WF10","name":"IST vs. Vorjahr (YoY)","cat":"compare","tags":["ist","vorjahr","yoy","entwicklung"],"pos":[4,10],"req":["IST","VJ"],"opt":["FC","BUD"],"pattern":"yoy-comparison"},{"id":"WF11","name":"IST vs. FC vs. BUD (3-Wege)","cat":"compare","tags":["drei-wege","vollvergleich"],"pos":[4,10],"req":["IST","FC","BUD"],"opt":["VJ"],"pattern":"budget-actual"},{"id":"WF12","name":"FC vs. Budget","cat":"compare","tags":["fc","budget","prognose-plan"],"pos":[4,10],"req":["FC","BUD"],"opt":["IST"],"pattern":"budget-actual"},{"id":"WF13","name":"FC vs. Vorjahr","cat":"compare","tags":["fc","vorjahr","yoy"],"pos":[4,10],"req":["FC","VJ"],"opt":["IST","BUD"],"pattern":"yoy-comparison"},{"id":"WF14","name":"Budget vs. Vorjahr","cat":"compare","tags":["budget","vorjahr","yoy"],"pos":[4,10],"req":["BUD","VJ"],"opt":["IST","FC"],"pattern":"yoy-comparison"},{"id":"WF15","name":"Varianz Budget→IST","cat":"variance","tags":["varianz","delta","abweichung"],"pos":[3,8],"req":["IST","BUD"],"opt":["FC"],"pattern":"variance-analysis"},{"id":"WF16","name":"Varianz Vorjahr→IST","cat":"variance","tags":["varianz","yoy","veränderung"],"pos":[3,8],"req":["IST","VJ"],"opt":["FC","BUD"],"pattern":"variance-analysis"},{"id":"WF17","name":"Varianz FC→IST","cat":"variance","tags":["varianz","forecast","prognoseabweichung"],"pos":[3,8],"req":["IST","FC"],"opt":["BUD"],"pattern":"variance-analysis"},{"id":"WF18","name":"Mit Quoten (% vom Umsatz)","cat":"special","tags":["quoten","prozent","kostenquote"],"pos":[4,10],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"cost-structure"},{"id":"WF19","name":"Nur Kostenstruktur","cat":"focus","tags":["kosten","opex","struktur"],"pos":[3,8],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"cost-structure"},{"id":"WF20","name":"EBITDA-Bridge","cat":"pnl","tags":["ebitda","operativ"],"pos":[3,8],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"revenue-to-profit"},{"id":"WF21","name":"EBITDA→EBIT Bridge","cat":"pnl","tags":["ebitda","ebit","abschreibungen"],"pos":[2,4],"req":["IST"],"opt":["FC","BUD"],"pattern":"revenue-to-profit"},{"id":"WF22","name":"Cash Flow Bridge","cat":"special","tags":["cashflow","ocf","liquidity"],"pos":[3,8],"req":["IST"],"opt":["FC","BUD"],"pattern":"revenue-to-profit"},{"id":"WF23","name":"Free Cash Flow Bridge","cat":"special","tags":["fcf","capex","free-cash-flow"],"pos":[2,5],"req":["IST"],"opt":["FC","BUD"],"pattern":"revenue-to-profit"},{"id":"WF24","name":"Working Capital Bridge","cat":"special","tags":["working-capital","nwc"],"pos":[3,6],"req":["IST"],"opt":["VJ"],"pattern":"variance-analysis"},{"id":"WF25","name":"Segment-Bridge (2-3 Segmente)","cat":"special","tags":["segment","division","geschäftsbereich"],"pos":[4,8],"req":["IST"],"opt":["FC","BUD"],"pattern":"segment-breakdown"},{"id":"WF26","name":"Regional-Bridge","cat":"special","tags":["regional","länder","dach"],"pos":[4,8],"req":["IST"],"opt":["FC","BUD"],"pattern":"regional-comparison"},{"id":"WF27","name":"Produkt-Bridge","cat":"special","tags":["produkt","portfolio","produktlinie"],"pos":[4,8],"req":["IST"],"opt":["FC","BUD"],"pattern":"product-mix"},{"id":"WF28","name":"Quartals-Entwicklung (Q1-Q4)","cat":"special","tags":["quartal","ytd","zeitreihe"],"pos":[4,6],"req":["IST"],"opt":["FC","BUD"],"pattern":"time-series"},{"id":"WF29","name":"Price-Volume-Mix Analyse","cat":"variance","tags":["pvm","price","volume","mix"],"pos":[4,6],"req":["IST","VJ"],"opt":["BUD"],"pattern":"variance-analysis"},{"id":"WF30","name":"Organic vs. Inorganic","cat":"variance","tags":["organisch","m&a","akquisition"],"pos":[3,6],"req":["IST","VJ"],"opt":[],"pattern":"variance-analysis"},{"id":"WF31","name":"Adjusted EBITDA Bridge","cat":"pnl","tags":["adjusted","bereinigt","sondereffekte"],"pos":[3,8],"req":["IST"],"opt":["FC","BUD"],"pattern":"revenue-to-profit"},{"id":"WF32","name":"Full Year Estimate","cat":"compare","tags":["fye","ytd","restjahr"],"pos":[3,6],"req":["IST","FC"],"opt":["BUD"],"pattern":"forecast-actual"},{"id":"WF33","name":"Rohertrag-Bridge","cat":"pnl","tags":["rohertrag","gross-profit","bruttomarge"],"pos":[2,5],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"revenue-to-profit"},{"id":"WF34","name":"Multi-Step Income (detailliert)","cat":"pnl","tags":["mehrstufig","subtotals","vollständig"],"pos":[6,15],"req":["IST"],"opt":["FC","BUD"],"pattern":"revenue-to-profit"},{"id":"WF35","name":"Mini-Bridge (3 Balken)","cat":"focus","tags":["mini","kompakt","sparkline","dashboard"],"pos":[1,3],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"margin-analysis"}]};

        const LAYOUT_CATALOG_BAR = {"chartType":"bar","layouts":[{"id":"BAR01","name":"2-Perioden Vergleich (YoY)","cat":"period","tags":["yoy","2-perioden","jahresvergleich"],"pos":[1,6],"req":["IST"],"opt":["VJ"],"pattern":"yoy-comparison"},{"id":"BAR02","name":"3-Perioden Vergleich","cat":"period","tags":["3-perioden","trend","entwicklung"],"pos":[1,6],"req":["IST"],"opt":["VJ"],"pattern":"time-series"},{"id":"BAR03","name":"4-Perioden Vergleich","cat":"period","tags":["4-perioden","mehrjährig"],"pos":[1,6],"req":["IST"],"opt":[],"pattern":"time-series"},{"id":"BAR04","name":"5+ Perioden Zeitreihe","cat":"period","tags":["zeitreihe","langfristig","history"],"pos":[1,5],"req":["IST"],"opt":[],"pattern":"time-series"},{"id":"BAR05","name":"Quartalsvergleich (Q1-Q4)","cat":"period","tags":["quartal","q1-q4","quartalsweise"],"pos":[1,6],"req":["IST"],"opt":["VJ"],"pattern":"time-series"},{"id":"BAR06","name":"Monatsvergleich (12 Monate)","cat":"period","tags":["monatlich","12-monate","jan-dez"],"pos":[1,3],"req":["IST"],"opt":["VJ","BUD"],"pattern":"time-series"},{"id":"BAR07","name":"Rolling 12 Months","cat":"period","tags":["rolling","r12","ltm"],"pos":[1,3],"req":["IST"],"opt":["VJ"],"pattern":"time-series"},{"id":"BAR08","name":"IST vs. Budget (einfach)","cat":"budget","tags":["ist","budget","vergleich"],"pos":[1,8],"req":["IST","BUD"],"opt":[],"pattern":"budget-actual"},{"id":"BAR09","name":"IST vs. FC (einfach)","cat":"budget","tags":["ist","fc","forecast"],"pos":[1,8],"req":["IST","FC"],"opt":[],"pattern":"forecast-actual"},{"id":"BAR10","name":"IST vs. BUD vs. FC (3-fach)","cat":"budget","tags":["drei-wege","vollständig","plan-ist-fc"],"pos":[1,6],"req":["IST","BUD","FC"],"opt":[],"pattern":"budget-actual"},{"id":"BAR11","name":"IST vs. BUD vs. VJ (3-fach)","cat":"budget","tags":["drei-wege","yoy","plan-ist-vj"],"pos":[1,6],"req":["IST","BUD","VJ"],"opt":[],"pattern":"budget-actual"},{"id":"BAR12","name":"Budget Tracking (Quartale)","cat":"budget","tags":["budget","quartale","tracking"],"pos":[1,4],"req":["IST","BUD"],"opt":["FC"],"pattern":"budget-actual"},{"id":"BAR13","name":"YTD vs. Full Year Projection","cat":"budget","tags":["ytd","full-year","projection"],"pos":[1,4],"req":["IST","FC"],"opt":["BUD"],"pattern":"forecast-actual"},{"id":"BAR14","name":"Single KPI mit Target","cat":"kpi","tags":["single-kpi","target","ziel"],"pos":[1,1],"req":["IST"],"opt":["BUD","FC","VJ"],"pattern":"kpi-dashboard"},{"id":"BAR15","name":"2 KPIs Vergleich","cat":"kpi","tags":["2-kpi","vergleich","dual"],"pos":[2,2],"req":["IST"],"opt":["VJ","BUD"],"pattern":"kpi-dashboard"},{"id":"BAR16","name":"3 KPIs Dashboard","cat":"kpi","tags":["3-kpi","dashboard","übersicht"],"pos":[3,3],"req":["IST"],"opt":["VJ","BUD"],"pattern":"kpi-dashboard"},{"id":"BAR17","name":"4-5 KPIs Dashboard","cat":"kpi","tags":["multi-kpi","dashboard","scorecard"],"pos":[4,5],"req":["IST"],"opt":["VJ","BUD"],"pattern":"kpi-dashboard"},{"id":"BAR18","name":"Finanz-KPIs (EBIT/Marge/ROE)","cat":"kpi","tags":["finanz-kpi","rentabilität","profitability"],"pos":[2,4],"req":["IST"],"opt":["VJ","BUD"],"pattern":"kpi-dashboard"},{"id":"BAR19","name":"Top 5 Ranking","cat":"ranking","tags":["top5","ranking","beste"],"pos":[5,5],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"BAR20","name":"Top 10 Ranking","cat":"ranking","tags":["top10","ranking","liste"],"pos":[10,10],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"BAR21","name":"Top 10 Ranking (horizontal)","cat":"ranking","tags":["top10","horizontal","lang"],"pos":[10,10],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"BAR22","name":"Abteilungsvergleich","cat":"ranking","tags":["abteilung","cost-center","vergleich"],"pos":[3,8],"req":["IST"],"opt":["BUD","VJ"],"pattern":"segment-breakdown"},{"id":"BAR23","name":"Produktvergleich","cat":"ranking","tags":["produkt","portfolio","vergleich"],"pos":[3,8],"req":["IST"],"opt":["VJ"],"pattern":"product-mix"},{"id":"BAR24","name":"Regionalvergleich","cat":"ranking","tags":["regional","länder","geo"],"pos":[3,8],"req":["IST"],"opt":["VJ","BUD"],"pattern":"regional-comparison"},{"id":"BAR25","name":"Kundenvergleich (Top 5)","cat":"ranking","tags":["kunden","top5","customer"],"pos":[5,5],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"BAR26","name":"Mit Durchschnittslinie","cat":"special","tags":["durchschnitt","average","benchmark"],"pos":[3,10],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"BAR27","name":"Bullet Chart Style","cat":"special","tags":["bullet","target","range"],"pos":[1,5],"req":["IST","BUD"],"opt":[],"pattern":"budget-actual"},{"id":"BAR28","name":"Gestapelt + Gruppiert Hybrid","cat":"special","tags":["hybrid","stacked","grouped"],"pos":[2,6],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"BAR29","name":"Mit Wachstumsrate (%)","cat":"special","tags":["wachstum","growth","prozent"],"pos":[2,8],"req":["IST","VJ"],"opt":[],"pattern":"yoy-comparison"},{"id":"BAR30","name":"Negative Werte (unter Null)","cat":"special","tags":["negativ","unter-null","verlust"],"pos":[1,6],"req":["IST"],"opt":["VJ","BUD"],"pattern":"variance-analysis"},{"id":"BAR31","name":"Dual-Axis (zwei Skalen)","cat":"special","tags":["dual-axis","zwei-skalen","kombi"],"pos":[1,4],"req":["IST"],"opt":["VJ"],"pattern":"kpi-dashboard"},{"id":"BAR32","name":"Mini Bars (Sparkline-Style)","cat":"special","tags":["mini","sparkline","kompakt"],"pos":[1,3],"req":["IST"],"opt":["VJ"],"pattern":"time-series"},{"id":"BAR33","name":"Pareto-Analyse (80/20)","cat":"special","tags":["pareto","80-20","abc-analyse"],"pos":[5,20],"req":["IST"],"opt":[],"pattern":"segment-breakdown"},{"id":"BAR34","name":"Index-Darstellung (Base=100)","cat":"special","tags":["index","base-100","normiert"],"pos":[1,5],"req":["IST"],"opt":["VJ"],"pattern":"time-series"},{"id":"BAR35","name":"Vergleich mit Branchendurchschnitt","cat":"special","tags":["branche","benchmark","industrie"],"pos":[1,5],"req":["IST"],"opt":[],"pattern":"kpi-dashboard"}]};

        const LAYOUT_CATALOG_STACKED_BAR = {"chartType":"stacked-bar","layouts":[{"id":"SB01","name":"Kostenstruktur - Vollständig","cat":"cost","tags":["kosten","vollständig","opex","detail"],"seg":[4,8],"per":[1,4],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"cost-structure"},{"id":"SB02","name":"Kostenstruktur - Top 4 + Sonstige","cat":"cost","tags":["kosten","top4","aggregiert"],"seg":[5,5],"per":[1,4],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"cost-structure"},{"id":"SB03","name":"OpEx Breakdown","cat":"cost","tags":["opex","betriebskosten","breakdown"],"seg":[3,6],"per":[1,3],"req":["IST"],"opt":["BUD","VJ"],"pattern":"cost-structure"},{"id":"SB04","name":"COGS Aufschlüsselung","cat":"cost","tags":["cogs","herstellkosten","material"],"seg":[3,6],"per":[1,3],"req":["IST"],"opt":["BUD"],"pattern":"cost-structure"},{"id":"SB05","name":"Personalkosten nach Gruppen","cat":"cost","tags":["personal","hr","mitarbeiter"],"seg":[3,5],"per":[1,3],"req":["IST"],"opt":["BUD","VJ"],"pattern":"cost-structure"},{"id":"SB06","name":"Abteilungs-Kosten Vergleich","cat":"cost","tags":["abteilung","cost-center","vergleich"],"seg":[3,6],"per":[1,4],"req":["IST"],"opt":["BUD"],"pattern":"cost-structure"},{"id":"SB07","name":"Revenue Mix - Produkte","cat":"revenue","tags":["revenue","produkt","mix"],"seg":[3,6],"per":[1,4],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"product-mix"},{"id":"SB08","name":"Revenue Mix - Regionen","cat":"revenue","tags":["revenue","regional","länder"],"seg":[3,6],"per":[1,4],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"regional-comparison"},{"id":"SB09","name":"Revenue Mix - Segmente","cat":"revenue","tags":["revenue","segment","geschäftsbereich"],"seg":[2,5],"per":[1,4],"req":["IST"],"opt":["FC","BUD","VJ"],"pattern":"segment-breakdown"},{"id":"SB10","name":"Revenue Mix - Kunden","cat":"revenue","tags":["revenue","kunde","customer"],"seg":[3,6],"per":[1,3],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB11","name":"Revenue Mix - Channels","cat":"revenue","tags":["revenue","channel","vertriebskanal"],"seg":[2,5],"per":[1,4],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB12","name":"100% Stacked - Kostenanteil","cat":"100pct","tags":["100%","anteil","kosten","proportional"],"seg":[3,6],"per":[2,5],"req":["IST"],"opt":["VJ"],"pattern":"cost-structure"},{"id":"SB13","name":"100% Stacked - Marktanteil","cat":"100pct","tags":["100%","marktanteil","market-share"],"seg":[3,6],"per":[2,5],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB14","name":"100% Stacked - Revenue Mix","cat":"100pct","tags":["100%","revenue","mix","proportional"],"seg":[3,6],"per":[2,5],"req":["IST"],"opt":["VJ"],"pattern":"product-mix"},{"id":"SB15","name":"100% Stacked - Segment Evolution","cat":"100pct","tags":["100%","segment","entwicklung"],"seg":[2,5],"per":[3,6],"req":["IST"],"opt":[],"pattern":"segment-breakdown"},{"id":"SB16","name":"Multi-Periode Kostenentwicklung","cat":"multi","tags":["multi-periode","kosten","trend"],"seg":[3,6],"per":[3,5],"req":["IST"],"opt":["VJ"],"pattern":"cost-structure"},{"id":"SB17","name":"Multi-Periode Revenue Mix","cat":"multi","tags":["multi-periode","revenue","trend"],"seg":[3,6],"per":[3,5],"req":["IST"],"opt":["VJ"],"pattern":"product-mix"},{"id":"SB18","name":"Quartalsvergleich (Q1-Q4)","cat":"multi","tags":["quartal","q1-q4","zeitreihe"],"seg":[3,6],"per":[4,4],"req":["IST"],"opt":["VJ"],"pattern":"time-series"},{"id":"SB19","name":"Jahresvergleich (3 Jahre)","cat":"multi","tags":["jahresvergleich","3-jahre","trend"],"seg":[3,6],"per":[3,3],"req":["IST"],"opt":[],"pattern":"time-series"},{"id":"SB20","name":"Jahresvergleich (5 Jahre)","cat":"multi","tags":["jahresvergleich","5-jahre","langfristig"],"seg":[3,5],"per":[5,5],"req":["IST"],"opt":[],"pattern":"time-series"},{"id":"SB21","name":"IST vs. Budget Stacked","cat":"multi","tags":["ist","budget","vergleich"],"seg":[3,6],"per":[2,2],"req":["IST","BUD"],"opt":[],"pattern":"budget-actual"},{"id":"SB22","name":"IST vs. FC vs. BUD Stacked","cat":"multi","tags":["drei-wege","ist","fc","bud"],"seg":[3,5],"per":[3,3],"req":["IST","FC","BUD"],"opt":[],"pattern":"budget-actual"},{"id":"SB23","name":"Margin Decomposition","cat":"special","tags":["marge","decomposition","aufschlüsselung"],"seg":[3,5],"per":[1,3],"req":["IST"],"opt":["VJ"],"pattern":"margin-analysis"},{"id":"SB24","name":"Horizontal Stacked (lang)","cat":"special","tags":["horizontal","lang","viele-kategorien"],"seg":[3,6],"per":[5,10],"req":["IST"],"opt":[],"pattern":"segment-breakdown"},{"id":"SB25","name":"Mit Summen-Labels","cat":"special","tags":["summen","totals","labels"],"seg":[3,6],"per":[2,4],"req":["IST"],"opt":["VJ"],"pattern":"cost-structure"},{"id":"SB26","name":"Mit Veränderungs-Brackets","cat":"special","tags":["brackets","veränderung","delta"],"seg":[3,6],"per":[2,3],"req":["IST"],"opt":["VJ"],"pattern":"variance-analysis"},{"id":"SB27","name":"Inventory/Bestand Aufbau","cat":"special","tags":["inventory","bestand","lager"],"seg":[3,5],"per":[2,4],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB28","name":"Working Capital Components","cat":"special","tags":["working-capital","nwc","bilanz"],"seg":[3,4],"per":[2,4],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB29","name":"Debt Structure","cat":"special","tags":["debt","verschuldung","kapitalstruktur"],"seg":[2,4],"per":[2,4],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB30","name":"FTE/Headcount by Department","cat":"special","tags":["fte","headcount","mitarbeiter"],"seg":[3,6],"per":[2,4],"req":["IST"],"opt":["BUD","VJ"],"pattern":"segment-breakdown"},{"id":"SB31","name":"Sales Pipeline Stages","cat":"special","tags":["pipeline","sales","stages"],"seg":[4,6],"per":[2,4],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB32","name":"Project Portfolio","cat":"special","tags":["projekt","portfolio","status"],"seg":[3,5],"per":[1,3],"req":["IST"],"opt":["BUD"],"pattern":"segment-breakdown"},{"id":"SB33","name":"Asset Allocation","cat":"special","tags":["asset","allocation","vermögen"],"seg":[3,6],"per":[2,4],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB34","name":"Mini Stacked (Dashboard)","cat":"special","tags":["mini","dashboard","kompakt"],"seg":[2,4],"per":[1,2],"req":["IST"],"opt":["VJ"],"pattern":"segment-breakdown"},{"id":"SB35","name":"Hatched/Schraffiert (VJ)","cat":"special","tags":["schraffiert","hatched","vorjahr"],"seg":[3,5],"per":[2,2],"req":["IST","VJ"],"opt":[],"pattern":"yoy-comparison"}]};

        // Funktion um den richtigen Katalog zu bekommen
        function getLayoutCatalog(chartType) {
            switch(chartType) {
                case 'waterfall': return LAYOUT_CATALOG_WATERFALL;
                case 'bar': return LAYOUT_CATALOG_BAR;
                case 'stacked-bar': return LAYOUT_CATALOG_STACKED_BAR;
                default: return null;
            }
        }

        // =====================================================
        // CHART_CONCEPT_PROMPT (Legacy, nur für Fallback)
        // =====================================================
        const CHART_CONCEPT_PROMPT = `Du bist ein Financial Visualization Expert.
Generiere bis zu 10 verschiedene Chart-Konfigurationen basierend auf den bereitgestellten Finanzdaten.

## OUTPUT-FORMAT
Gib ein JSON-Objekt mit variant1 bis variant10 zurück, wobei jede Variante enthält:
- name: Kurzer Name der Variante
- description: Beschreibung
- useCase: Anwendungsfall
- config: Vollständiges Config-Objekt für den Chart-Renderer

Jede Config muss direkt vom Renderer verwendbar sein mit allen erforderlichen Feldern.`;

        // =====================================================
        // LAYOUT-RANKING API-CALL - ENTFERNT (Phase 1 Refactoring)
        // =====================================================
        // Diese Funktion wurde entfernt, da ranking_mix nicht mehr verwendet wird.
        // Stattdessen werden ALLE Templates des gewählten Typs direkt generiert.
        // Die Funktion generateChartsWithRanking ist ebenfalls Legacy und wird nicht mehr aufgerufen.

        // =====================================================
        // CONFIG-GENERATOR API-CALL
        // =====================================================
        // Generiert ALLE Configs in einem einzigen API-Call (spart 9 API-Calls!)
        async function generateAllConfigsViaAPI(apiKey, provider, rankings, catalog, extractedData, colors) {
            // Lade Prompt aus .md-Datei
            const configGeneratorPrompt = await PromptLoader.load('field_mapping');

            // Baue Liste der zu generierenden Layouts
            const layoutsToGenerate = rankings.slice(0, 10).map(r => {
                const metadata = catalog.layouts.find(l => l.id === r.layoutId);
                return {
                    layoutId: r.layoutId,
                    score: r.score,
                    reason: r.reason,
                    metadata: metadata
                };
            }).filter(l => l.metadata);

            const userPrompt = `## Aufgabe
Generiere für ALLE folgenden ${layoutsToGenerate.length} Layouts die vollständigen Chart-Konfigurationen.

## Layouts (nach Ranking sortiert):
${JSON.stringify(layoutsToGenerate.map(l => ({ id: l.layoutId, name: l.metadata.name, score: l.score })), null, 2)}

## Layout-Metadaten:
${JSON.stringify(layoutsToGenerate.map(l => l.metadata), null, 2)}

## Extrahierte Daten:
${JSON.stringify(extractedData, null, 2)}

## Firmenfarben:
${JSON.stringify(colors, null, 2)}

## Output-Format
Gib ein JSON-Array zurück mit GENAU ${layoutsToGenerate.length} Config-Objekten in der gleichen Reihenfolge wie die Layouts oben.
Jedes Config-Objekt muss ein zusätzliches Feld "_layoutId" enthalten, das die Layout-ID angibt.

Beispiel-Struktur:
[
  { "chartType": "waterfall", "layoutId": "WF01", "_layoutId": "WF01", "title": "...", ... },
  { "chartType": "waterfall", "layoutId": "WF04", "_layoutId": "WF04", "title": "...", ... },
  ...
]

Gib NUR das JSON-Array zurück, keine zusätzlichen Erklärungen.`;

            let response;
            if (provider === 'anthropic') {
                response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 16000,  // Mehr Tokens für alle 10 Configs
                        messages: [
                            { role: 'user', content: configGeneratorPrompt + '\n\n' + userPrompt }
                        ]
                    })
                });
            } else {
                response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        max_tokens: 16000,
                        messages: [
                            { role: 'system', content: configGeneratorPrompt },
                            { role: 'user', content: userPrompt }
                        ]
                    })
                });
            }

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Config API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
            }

            const data = await response.json();
            const content = provider === 'anthropic'
                ? data.content[0].text
                : data.choices[0].message.content;

            // Parse JSON-Array
            const jsonMatch = content.match(/\[[\s\S]*\]/);
            if (!jsonMatch) {
                throw new Error('Keine gültige JSON-Array-Antwort vom Config-Generator');
            }

            const configs = JSON.parse(jsonMatch[0]);

            // Füge Ranking-Metadaten hinzu
            return configs.map((config, index) => {
                const layoutInfo = layoutsToGenerate.find(l => l.layoutId === config._layoutId) || layoutsToGenerate[index];
                if (layoutInfo) {
                    config._rankingScore = layoutInfo.score;
                    config._rankingReason = layoutInfo.reason;
                    config._layoutName = layoutInfo.metadata?.name;
                }
                return config;
            });
        }

        // =====================================================
        // LEGACY: generateChartsWithRanking - ENTFERNT (Phase 1 Refactoring)
        // =====================================================
        // Diese Funktion wurde entfernt, da sie rankLayoutsViaAPI verwendet hat.
        // Das System generiert nun ALLE Templates des gewählten Typs direkt
        // über den Template-basierten Workflow (TemplateLoader + ChartMixer).
        // Siehe: selectTemplates() in ChartMixer

        // Hilfsfunktion: Keywords aus Analyse extrahieren
        function extractKeywordsFromAnalysis(analysis) {
            const keywords = [];
            if (analysis?.positions) {
                analysis.positions.forEach(p => {
                    if (p.label) {
                        keywords.push(p.label.toLowerCase());
                    }
                });
            }
            // Zusätzliche Keywords aus dataFormat
            if (analysis?.dataFormat) {
                keywords.push(analysis.dataFormat.toLowerCase());
            }
            return keywords.slice(0, 20); // Max 20 Keywords
        }

        // =====================================================
        // INITIALISIERUNG
        // =====================================================

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('current-date').textContent = new Date().toLocaleDateString('de-DE');
            initializeCharts();
        });

        async function initializeCharts() {
            try {
                // HINWEIS: Prompts werden NICHT mehr vorab geladen
                // Stattdessen wird nur der benötigte Chart-Prompt später geladen
                // Das spart ~20.000 Tokens pro Generierung!

                // Lade Analyse-Ergebnis
                const resultRaw = sessionStorage.getItem('analysisResult');
                if (!resultRaw) {
                    showEmptyState('Keine Analyseergebnisse gefunden. Bitte starte eine neue Analyse.');
                    return;
                }

                analysisResult = JSON.parse(resultRaw);

                // Parse das result wenn es ein String ist
                if (typeof analysisResult.result === 'string') {
                    analysisResult.parsed = JSON.parse(analysisResult.result);
                } else {
                    analysisResult.parsed = analysisResult.result;
                }

                // Lade Company Colors
                const colorsRaw = sessionStorage.getItem('companyColors');
                if (colorsRaw) {
                    companyColors = JSON.parse(colorsRaw);
                }

                // Chart-Anzahl: ALLE Templates des gewählten Typs generieren
                // (Slider wurde in Phase 1 entfernt - keine User-Auswahl mehr)
                // chartCount bleibt auf 12 (Maximum aus templates.json)
                console.log('Chart-Anzahl: Generiere alle Templates des Typs (max', chartCount, ')');

                // Ermittle Chart-Typ
                console.log('=== CHART-TYP DEBUG (charts.html) ===');
                console.log('Gesamtes analysisResult.parsed.recommendation:', JSON.stringify(analysisResult.parsed.recommendation, null, 2));
                console.log('selectedChart:', analysisResult.parsed.recommendation?.selectedChart);
                console.log('primaryChart:', analysisResult.parsed.recommendation?.primaryChart);
                console.log('_userSelectedChart:', analysisResult.parsed.recommendation?._userSelectedChart);

                // chartType kommt aus User-Auswahl in results.html (selectedChart)
                // Fallback auf primaryChart (KI-Empfehlung) wenn nichts gewählt
                let chartType;
                if (analysisResult.parsed.recommendation?.selectedChart) {
                    chartType = analysisResult.parsed.recommendation.selectedChart;
                    console.log('chartType aus selectedChart:', chartType);
                } else if (analysisResult.parsed.recommendation?.primaryChart) {
                    chartType = analysisResult.parsed.recommendation.primaryChart;
                    console.log('chartType aus primaryChart (KI-Empfehlung):', chartType);
                } else {
                    chartType = 'waterfall';
                    console.log('chartType auf waterfall gesetzt (Default)');
                }
                console.log('Finaler chartType:', chartType);
                console.log('=== END DEBUG (charts.html) ===')

                // Setze Seitentitel
                const typeLabels = {
                    'waterfall': 'Waterfall Charts',
                    'bar': 'Bar Charts',
                    'stacked-bar': 'Stacked Bar Charts',
                    'stacked_bar': 'Stacked Bar Charts'  // Alternative Schreibweise
                };
                // Normalisiere chartType für Titel
                const displayChartType = chartType === 'stacked_bar' ? 'stacked-bar' : chartType;
                console.log('displayChartType für Titel:', displayChartType);
                document.getElementById('page-title').textContent =
                    `${typeLabels[displayChartType] || 'Charts'} - Think-Cell Stil`;
                document.getElementById('page-subtitle').textContent =
                    `Basierend auf: ${analysisResult.displayName || analysisResult.fileName}`;

                // API-Key für Chart-Generierung (2. API-Call)
                const apiKey = sessionStorage.getItem('apiKey');
                const provider = sessionStorage.getItem('apiProvider') || 'anthropic';

                // Erstelle Daten-Profil (immer, auch ohne API-Key)
                console.log('Erstelle Daten-Profil...');
                const profile = DataProfiler.profile(analysisResult);
                console.log('Daten-Profil:', profile);
                aiReasoningData.profile = profile;

                // =====================================================
                // CHART-GENERIERUNG: Nur KI oder Demo-Modus
                // =====================================================

                // Track API-Key Status
                aiReasoningData.apiKeyPresent = !!apiKey;

                console.log('API-Key Status:', apiKey ? 'vorhanden (***' + apiKey.slice(-4) + ')' : 'NICHT vorhanden');
                console.log('Provider:', provider);

                if (apiKey) {
                    // KI-MODUS: Vollstaendige KI-Pipeline
                    try {
                        console.log('=== STARTE KI-GENERIERUNG ===');
                        showLoadingState();
                        aiReasoningData.generationMode = 'ai';

                        // Initialisiere API Client
                        APIClient.init(apiKey, provider);
                        console.log('APIClient initialisiert');

                        // Lade nur den benötigten Chart-Prompt (spart ~20.000 Tokens!)
                        const promptName = chartType === 'stacked-bar' ? 'stacked_bar' : chartType;
                        console.log(`Lade nur Chart-Prompt für '${promptName}'...`);
                        await PromptLoader.load(promptName);
                        console.log('Chart-Prompt geladen');

                        // Lade Template-Bibliothek
                        console.log('1/3: Lade Template-Bibliothek...');
                        await TemplateLoader.load();
                        console.log('1/3: Template-Bibliothek geladen');

                        // Wähle Templates des gewählten Typs (mit optionalem KI-Ranking)
                        console.log('2/3: Lade Templates für Typ:', chartType);
                        const allowedTypes = [chartType.replace('-', '_')];
                        console.log('Erlaubte Chart-Typen:', allowedTypes);
                        const allTemplates = TemplateLoader.getAll();
                        console.log('Verfügbare Templates:', allTemplates.length);

                        // KI-Ranking aktivieren wenn mehr Templates als gewünscht
                        // Das spart API-Calls und Zeit bei der Generierung
                        const useLayoutRanking = true;  // Feature-Flag
                        console.log('Layout-Ranking:', useLayoutRanking ? 'AKTIVIERT' : 'deaktiviert');

                        const selectedTemplates = await ChartMixer.selectTemplates(
                            profile,
                            allTemplates,
                            chartCount,
                            allowedTypes,
                            useLayoutRanking  // Neuer Parameter
                        );
                        console.log('2/3: Templates ausgewählt:', selectedTemplates.map(t => t.template_id));
                        // Zeige Chart-Typ-Verteilung
                        const typeCount = {};
                        selectedTemplates.forEach(t => {
                            typeCount[t.chart_type] = (typeCount[t.chart_type] || 0) + 1;
                        });
                        console.log('Chart-Typ-Verteilung:', typeCount);

                        // Generiere Configs für jedes Template via KI (Chart-Prompts)
                        console.log('3/3: Generiere Chart-Configs via KI (Chart-Prompts)...');
                        chartConfigs = [];
                        const extractedData = analysisResult.parsed.extractedData || {};

                        // =====================================================
                        // DUPLIKAT-ERKENNUNG: Fingerprints für generierte Configs
                        // =====================================================
                        const usedFingerprints = new Set();
                        let duplicatesSkipped = 0;

                        /**
                         * Erstellt einen strukturellen Fingerprint einer Config
                         * um inhaltlich ähnliche Charts zu erkennen
                         */
                        function generateConfigFingerprint(config, chartType) {
                            try {
                                if (chartType === 'waterfall') {
                                    // Fingerprint: Anzahl Bars + Typ-Sequenz + Vorzeichen der Werte
                                    const barsSignature = config.bars?.map(b =>
                                        `${b.type}:${Math.sign(b.value || 0)}`
                                    ).join('|') || '';
                                    return `WF:${config.bars?.length || 0}:${barsSignature}`;
                                }
                                if (chartType === 'bar') {
                                    // Fingerprint: Anzahl Perioden + Anzahl Kategorien + Werte-Hash
                                    const periodsCount = config.periods?.length || 0;
                                    const categoriesCount = config.categories?.length || 0;
                                    const valuesHash = config.categories?.slice(0, 3).map(c =>
                                        (c.values || []).slice(0, 2).map(v => Math.round(v / 1000)).join(',')
                                    ).join('|') || '';
                                    return `BAR:${periodsCount}:${categoriesCount}:${valuesHash}`;
                                }
                                if (chartType === 'stacked_bar' || chartType === 'stacked-bar') {
                                    // Fingerprint: Anzahl Kategorien + Anzahl Segmente + Werte-Hash
                                    const categoriesCount = config.categories?.length || 0;
                                    const segmentsCount = config.segments?.length || 0;
                                    const valuesHash = config.segments?.slice(0, 3).map(s =>
                                        (s.values || []).slice(0, 2).map(v => Math.round(v / 1000)).join(',')
                                    ).join('|') || '';
                                    return `SB:${categoriesCount}:${segmentsCount}:${valuesHash}`;
                                }
                                // Fallback: Generischer Hash
                                return `GENERIC:${JSON.stringify(config).length}`;
                            } catch (e) {
                                console.warn('Fingerprint-Generierung fehlgeschlagen:', e.message);
                                return `ERROR:${Date.now()}`; // Eindeutiger Fallback
                            }
                        }

                        // Sprache aus analysisResult holen
                        const detectedLanguage = analysisResult.detectedLanguage || 'unknown';
                        console.log(`Erkannte Sprache der Quelldaten: ${detectedLanguage}`);

                        for (const template of selectedTemplates) {
                            try {
                                console.log(`Generiere Config für Template: ${template.template_id}...`);
                                const config = await ConfigGenerator.generate(
                                    template,
                                    extractedData,
                                    companyColors,
                                    detectedLanguage
                                );
                                if (config) {
                                    // Prüfe auf Duplikate
                                    const fingerprint = generateConfigFingerprint(config, template.chart_type);
                                    console.log(`Fingerprint für ${template.template_id}: ${fingerprint}`);

                                    if (!usedFingerprints.has(fingerprint)) {
                                        usedFingerprints.add(fingerprint);
                                        chartConfigs.push(config);
                                        console.log(`Config für ${template.template_id} erfolgreich hinzugefügt`);
                                    } else {
                                        duplicatesSkipped++;
                                        console.log(`⚠️ Duplikat erkannt für ${template.template_id}, überspringe (Fingerprint: ${fingerprint})`);
                                    }
                                }
                            } catch (templateError) {
                                // Einzelne Template-Fehler loggen, aber fortfahren
                                console.warn(`Fehler bei Template ${template.template_id}:`, templateError.message);
                                aiReasoningData.errors = aiReasoningData.errors || [];
                                aiReasoningData.errors.push({
                                    phase: 'config-generation',
                                    template: template.template_id,
                                    error: templateError.message,
                                    timestamp: new Date().toISOString()
                                });
                            }
                        }

                        console.log(`${chartConfigs.length} Chart-Configs via KI generiert (${duplicatesSkipped} Duplikate übersprungen)`);

                        // Zeige Zusammenfassung nach Chart-Typ
                        const generatedTypeCount = {};
                        chartConfigs.forEach(c => {
                            const type = c._chartType || detectChartType(c);
                            generatedTypeCount[type] = (generatedTypeCount[type] || 0) + 1;
                        });
                        console.log('Generierte Chart-Typ-Verteilung:', generatedTypeCount);

                        // Speichere Templates und Duplikat-Info für Chain-of-Thought
                        aiReasoningData.selectedTemplates = selectedTemplates;
                        aiReasoningData.duplicatesSkipped = duplicatesSkipped;
                        aiReasoningData.uniqueChartsGenerated = chartConfigs.length;
                        aiReasoningData.requestedChartCount = chartCount;

                        // Hinweis wenn weniger Charts generiert wurden als angefordert
                        if (chartConfigs.length < chartCount) {
                            const reason = duplicatesSkipped > 0
                                ? `${duplicatesSkipped} Duplikate wurden übersprungen, da sie strukturell identisch waren.`
                                : 'Nicht genügend unterschiedliche Layouts verfügbar.';
                            console.log(`ℹ️ ${chartConfigs.length} von ${chartCount} Charts generiert. ${reason}`);
                            aiReasoningData.chartCountNote = reason;
                        }

                        // Wenn KI keine Charts generieren konnte -> Demo-Modus
                        if (chartConfigs.length === 0) {
                            const templateErrors = (aiReasoningData.errors || [])
                                .filter(e => e.phase === 'config-generation')
                                .map(e => `${e.template}: ${e.error}`)
                                .join('; ');
                            const errorMsg = templateErrors
                                ? `KI konnte keine Charts generieren. Template-Fehler: ${templateErrors}`
                                : `KI konnte keine Charts generieren (${selectedTemplates.length} Templates ausgewählt, aber alle Configs fehlgeschlagen)`;
                            throw new Error(errorMsg);
                        }

                    } catch (error) {
                        // BEI JEDEM FEHLER: Wechsel zu Demo-Modus
                        console.error('KI-Generierung fehlgeschlagen:', error);
                        aiReasoningData.generationMode = 'demo';
                        aiReasoningData.errors = aiReasoningData.errors || [];
                        aiReasoningData.errors.push({
                            phase: 'ai-generation',
                            error: error.message,
                            timestamp: new Date().toISOString()
                        });

                        // Demo-Daten laden für den gewählten Typ
                        console.log('Wechsel zu Demo-Modus...');
                        generateChartVariants(chartType);
                    }
                } else {
                    // DEMO-MODUS: Kein API-Key vorhanden
                    console.log('Kein API-Key - Demo-Modus aktiv');
                    aiReasoningData.generationMode = 'demo';
                    generateChartVariants(chartType);
                }

                renderAllCharts();

                // Sammle finale KI-Entscheidungsdaten für Chain-of-Thought Anzeige
                // (nach allen Fallbacks, damit chartConfigs korrekt gefüllt ist)
                const finalChartType = chartType;
                aiReasoningData.chartConfigs = chartConfigs;
                aiReasoningData.chartType = finalChartType;
                aiReasoningData.chartCount = chartConfigs.length;
                aiReasoningData.timestamp = new Date().toISOString();
                aiReasoningData.reasoning = generateReasoning(profile, finalChartType, chartConfigs);

                renderReasoningSection();

                // Falls immer noch nichts gerendert wurde
                if (chartConfigs.length === 0) {
                    showEmptyState('Es konnten keine Charts generiert werden. Bitte versuche es erneut.');
                }

            } catch (error) {
                console.error('Error loading data:', error);
                showEmptyState('Fehler beim Laden der Daten: ' + error.message);
            }
        }

        function showLoadingState() {
            document.getElementById('charts-wrapper').innerHTML = `
                <div class="chart-container">
                    <div class="loading-state">
                        <div class="loading-spinner"></div>
                        <div class="loading-title">Charts werden generiert...</div>
                        <div class="loading-subtitle">Die KI erstellt bis zu 10 optimierte Chart-Varianten</div>
                        <div class="loading-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Animiere Progress-Bar
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress > 90) progress = 90;
                const fill = document.getElementById('progressFill');
                if (fill) fill.style.width = progress + '%';
            }, 500);

            // Speichere Interval für Cleanup
            window.loadingInterval = interval;
        }

        // =====================================================
        // NEUE FUNKTION: generateConceptsViaAPI
        // Verwendet den CHART_CONCEPT_PROMPT für intelligente Varianten
        // =====================================================
        async function generateConceptsViaAPI(apiKey, provider, chartType) {
            try {
                // Hole die Daten aus dem 1. API-Call (DATA-ANALYZER)
                const analysisData = analysisResult.parsed.analysis || {};
                const extractedData = analysisResult.parsed.extractedData || {};
                const metadata = analysisResult.parsed.metadata || {};
                const rawData = analysisResult.csvData || analysisResult.rawData || '';

                // Wähle die relevanten extrahierten Daten je nach Chart-Typ
                let relevantData = {};
                if (chartType === 'waterfall' && extractedData.waterfall) {
                    relevantData = extractedData.waterfall;
                } else if (chartType === 'bar' && extractedData.bar) {
                    relevantData = extractedData.bar;
                } else if (chartType === 'stacked-bar' && extractedData.bar) {
                    relevantData = extractedData.bar;
                }

                // Erstelle den User-Prompt mit allen relevanten Daten
                const userPrompt = `Hier sind die analysierten Finanzdaten für die Chart-Konzept-Generierung:

## CHART-TYP: ${chartType.toUpperCase()}

## ANALYSE-ERGEBNIS (aus DATA-ANALYZER):
${JSON.stringify(analysisData, null, 2)}

## EXTRAHIERTE DATEN FÜR ${chartType.toUpperCase()}:
${JSON.stringify(relevantData, null, 2)}

## METADATA:
- Dateiname: ${analysisResult.fileName || 'Unbekannt'}
- Empfohlener Titel: ${metadata.suggestedTitle || 'Finanzübersicht'}
- Empfohlener Untertitel: ${metadata.suggestedSubtitle || 'in TEUR'}
- Einheit: ${analysisData.detectedUnit || 'TEUR'}

## VERFÜGBARE POSITIONEN:
${JSON.stringify(analysisData.positions || {}, null, 2)}

## VERFÜGBARE WERTARTEN:
${JSON.stringify(analysisData.valueTypes || [], null, 2)}

## ROHDATEN (erste 3000 Zeichen):
${rawData.substring(0, 3000)}

## FIRMENFARBEN (bereits ausgewählt):
${companyColors.length > 0 ? `
Farbe 1: ${companyColors[0] || '#1B4F72'}
Farbe 2: ${companyColors[1] || '#27AE60'}
Farbe 3: ${companyColors[2] || '#E74C3C'}
Farbe 4: ${companyColors[3] || '#7F8C8D'}
Farbe 5: ${companyColors[4] || '#6B8BAE'}
Farbe 6: ${companyColors[5] || '#8B5CF6'}` : 'Keine Firmenfarben - verwende Standard-Farben'}

## AUFGABE:
Erstelle bis zu 10 vollständige ${chartType}-Chart-Konfigurationen.
- Jede Variante muss KONKRETE WERTE aus den obigen Daten enthalten
- Nur SINNVOLLE und UNTERSCHIEDLICHE Varianten erstellen
- Die Configs müssen direkt vom Renderer verwendbar sein
- Farben aus den Firmenfarben übernehmen`;

                let response;

                if (provider === 'anthropic') {
                    response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 16000,
                            messages: [
                                { role: 'user', content: CHART_CONCEPT_PROMPT + '\n\n' + userPrompt }
                            ]
                        })
                    });
                } else {
                    response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            max_tokens: 16000,
                            messages: [
                                { role: 'system', content: CHART_CONCEPT_PROMPT },
                                { role: 'user', content: userPrompt }
                            ]
                        })
                    });
                }

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();

                // Extrahiere Content basierend auf Provider
                let content;
                if (provider === 'anthropic') {
                    content = data.content[0].text;
                } else {
                    content = data.choices[0].message.content;
                }

                console.log('CHART_CONCEPT_PROMPT Response erhalten');

                // Parse JSON
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Keine gültige JSON-Antwort vom Konzept-Prompt');
                }

                const conceptResult = JSON.parse(jsonMatch[0]);

                // Extrahiere die Configs aus den Varianten
                const variantKeys = ['variant1', 'variant2', 'variant3', 'variant4', 'variant5',
                                     'variant6', 'variant7', 'variant8', 'variant9', 'variant10'];

                chartConfigs = variantKeys
                    .map(k => {
                        const variant = conceptResult[k];
                        if (variant && variant.config) {
                            // Füge Varianten-Metadaten zur Config hinzu für die Anzeige
                            return {
                                ...variant.config,
                                _variantName: variant.name || '',
                                _variantDescription: variant.description || '',
                                _variantUseCase: variant.useCase || ''
                            };
                        }
                        return null;
                    })
                    .filter(config => config && typeof config === 'object' && Object.keys(config).length > 0);

                // Wende Company Colors an falls noch nicht in Config
                if (companyColors.length > 0) {
                    chartConfigs = chartConfigs.map(config => applyCompanyColors(config, chartType));
                }

                // Log Ergebnis
                console.log(`CHART_CONCEPT_PROMPT: ${chartConfigs.length} Varianten generiert`);
                if (conceptResult.metadata) {
                    console.log('Metadata:', conceptResult.metadata);
                }

                // Stoppe Loading-Animation
                if (window.loadingInterval) {
                    clearInterval(window.loadingInterval);
                    const fill = document.getElementById('progressFill');
                    if (fill) fill.style.width = '100%';
                }

            } catch (error) {
                console.error('CHART_CONCEPT_PROMPT Error:', error);
                // Stoppe Loading-Animation
                if (window.loadingInterval) clearInterval(window.loadingInterval);

                // Fallback zur alten Methode
                console.log('Fallback zu generateChartsViaAPI...');
                await generateChartsViaAPI(apiKey, provider, chartType);
            }
        }

        // =====================================================
        // ALTE FUNKTION: generateChartsViaAPI (als Fallback)
        // =====================================================
        async function generateChartsViaAPI(apiKey, provider, chartType) {
            try {
                // Wähle den passenden Prompt basierend auf Chart-Typ (aus .md-Datei)
                const chartPrompt = await getChartPromptByType(chartType);

                // Hole die extrahierten Daten aus dem 1. API-Call
                const analysisData = analysisResult.parsed.analysis || {};
                const extractedData = analysisResult.parsed.extractedData || {};
                const metadata = analysisResult.parsed.metadata || {};
                const rawData = analysisResult.csvData || analysisResult.rawData || '';

                // Wähle die relevanten extrahierten Daten je nach Chart-Typ
                let relevantData = {};
                if (chartType === 'waterfall' && extractedData.waterfall) {
                    relevantData = extractedData.waterfall;
                } else if (chartType === 'bar' && extractedData.bar) {
                    relevantData = extractedData.bar;
                } else if (chartType === 'stacked-bar' && extractedData.bar) {
                    relevantData = extractedData.bar;
                }

                const userPrompt = `Hier sind die analysierten und extrahierten Finanzdaten:

## ANALYSE-ERGEBNIS (aus 1. API-Call):
${JSON.stringify(analysisData, null, 2)}

## EXTRAHIERTE DATEN FÜR ${chartType.toUpperCase()}:
${JSON.stringify(relevantData, null, 2)}

## METADATA:
- Empfohlener Titel: ${metadata.suggestedTitle || 'Finanzübersicht'}
- Empfohlener Untertitel: ${metadata.suggestedSubtitle || 'in TEUR'}
- Einheit: ${analysisData.detectedUnit || 'TEUR'}
- Skalierungsfaktor: ${analysisData.scaleFactor || 1}

## ROHDATEN (WICHTIG - Prüfe auf Typ-Spalte wie "Scenario", "Typ", etc.!):
${rawData.substring(0, 3000)}

## GEWÄHLTER CHART-TYP: ${chartType}

## FIRMENFARBEN:
${companyColors.length > 0 ? `
- Farbe 1 (Start/End): ${companyColors[0] || '#1B4F72'}
- Farbe 2 (Positive): ${companyColors[1] || '#27AE60'}
- Farbe 3 (Negative): ${companyColors[2] || '#E74C3C'}
- Farbe 4 (Compare): ${companyColors[3] || '#7F8C8D'}
- Farbe 5: ${companyColors[4] || '#6B8BAE'}
- Farbe 6: ${companyColors[5] || '#8B5CF6'}` : 'Keine Firmenfarben definiert - verwende Standard-Farben'}

## AUFGABE:
Generiere bis zu 10 verschiedene ${chartType}-Chart-Konfigurationen im Think-Cell Stil.
Verwende die extrahierten Daten und erstelle SINNVOLLE, UNTERSCHIEDLICHE Perspektiven/Varianten.

Die Ausgabe muss ein JSON-Objekt mit variant1 bis maximal variant10 sein.
- Jede Variante muss einen ECHTEN MEHRWERT bieten (nicht nur andere Farben!)
- Wenn weniger als 10 sinnvolle Varianten möglich sind, erstelle nur so viele wie sinnvoll
- Varianten die sich wiederholen würden WEGLASSEN (nicht mit null füllen)

## KRITISCH FÜR BAR-CHARTS:

### 1. VERWENDE DIE EXTRAHIERTEN PERIODEN DIREKT!

Die "EXTRAHIERTE DATEN FÜR BAR" oben enthält bereits:
- periods: Array mit { label, type } für JEDEN Datenpunkt
- categories: Array mit Werten pro Periode

**Übernimm diese 1:1 in dein config-Objekt und füge nur die Farben hinzu!**

Beispiel - Aus extrahierten Daten:
"periods": [
    { "label": "2020", "type": "IST" },
    { "label": "2025", "type": "IST" },
    { "label": "2026 PLAN", "type": "PLAN" }
]

Wird zu:
periods: [
    { label: '2020', color: '#CCCCCC', type: 'IST' },
    { label: '2025', color: '#333333', type: 'IST' },
    { label: '2026 PLAN', color: '#0066B1', type: 'PLAN' }
]

### 2. FARBSCHEMA BASIEREND AUF TYPE

- IST-Jahre: Grautöne von hell nach dunkel (#CCCCCC → #AAAAAA → #888888 → #666666 → #444444 → #333333)
- PLAN-Jahre: Blau (#0066B1)
- BUD-Jahre: Grün (#27AE60)

### 3. KEINE AGGREGATION!

**Die extrahierten Daten enthalten bereits JEDEN einzelnen Datenpunkt!**
- Übernimm ALLE periods aus den extrahierten Daten
- Die Anzahl values pro category MUSS mit der Anzahl periods übereinstimmen

## KRITISCH FÜR WATERFALL-CHARTS - NUR ECHTE DATEN!

### KEINE ERFUNDENEN EFFEKTE!

**VERWENDE AUSSCHLIESSLICH die Daten aus "EXTRAHIERTE DATEN FÜR WATERFALL"!**

❌ VERBOTEN - Erfundene Kategorien wie:
- "Inflation", "Pricing", "Volume", "Mix", "Plan-Aufschlag"
- "Cost Savings", "Synergies", "Market Growth"
- Beliebige andere Labels die NICHT in den Quelldaten stehen

### WATERFALL-TYP ANHAND DER DATEN ERKENNEN:

**Typ A: GuV-Bridge** (wenn extractedData.waterfall.dataType === 'guv' oder positions vorhanden)
- Start: Erste Position (z.B. "Umsatzerlöse")
- Increase/Decrease: Kostenarten aus den Daten
- End: Letzte Position (z.B. "EBIT")

**Typ B: Zeitreihen-Bridge** (wenn extractedData.waterfall.timeseries vorhanden)
Zeige Wertentwicklung über Zeit mit ALLEN Jahren:

Beispiel für timeseries mit Werten: 2020=80, 2021=85, 2022=90, 2023=95, 2024=100, 2025=105, 2026=260
→ Generiere:
bars: [
    { type: 'start', label: '2020', value: 80, displayValue: '80 Mio €' },
    { type: 'increase', label: 'Δ 2021', value: 5, displayValue: '+5 Mio €' },
    { type: 'increase', label: 'Δ 2022', value: 5, displayValue: '+5 Mio €' },
    { type: 'increase', label: 'Δ 2023', value: 5, displayValue: '+5 Mio €' },
    { type: 'increase', label: 'Δ 2024', value: 5, displayValue: '+5 Mio €' },
    { type: 'increase', label: 'Δ 2025', value: 5, displayValue: '+5 Mio €' },
    { type: 'increase', label: 'Δ 2026', value: 155, displayValue: '+155 Mio €' },
    { type: 'end', label: '2026', value: 260, displayValue: '260 Mio €' }
]

**WICHTIG bei großen Wertsprüngen:**
- Wenn ein Δ-Wert >3x größer ist als die anderen, ist ein SKALENBRUCH sinnvoll
- Setze dann: scaleBreak: { enabled: true, barIndex: X } für den großen Balken

### MATHEMATISCHE KORREKTHEIT (PFLICHT!):
End-Wert = Start-Wert + Summe(alle increase/decrease values)

### WERT-LABELS:
- POSITIV: Label ÜBER dem Balken
- NEGATIV: Label ÜBER der Nulllinie`;

                // Kombiniere Chart-spezifischen Prompt mit Ausgabe-Anweisungen
                const fullPrompt = chartPrompt + OUTPUT_INSTRUCTIONS;

                let response;

                if (provider === 'anthropic') {
                    response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 16000,
                            messages: [
                                { role: 'user', content: fullPrompt + '\n\n' + userPrompt }
                            ]
                        })
                    });
                } else {
                    response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            max_tokens: 16000,
                            messages: [
                                { role: 'system', content: fullPrompt },
                                { role: 'user', content: userPrompt }
                            ]
                        })
                    });
                }

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();

                // Extrahiere Content basierend auf Provider
                let content;
                if (provider === 'anthropic') {
                    content = data.content[0].text;
                } else {
                    content = data.choices[0].message.content;
                }

                // Parse JSON
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Keine gültige JSON-Antwort');
                }

                const configs = JSON.parse(jsonMatch[0]);

                // Extrahiere bis zu 10 Varianten (nur vorhandene, keine null/undefined)
                const variantKeys = ['variant1', 'variant2', 'variant3', 'variant4', 'variant5',
                                     'variant6', 'variant7', 'variant8', 'variant9', 'variant10'];
                chartConfigs = variantKeys
                    .map(k => configs[k])
                    .filter(config => config && typeof config === 'object' && Object.keys(config).length > 0);

                // Wende Company Colors an falls definiert
                if (companyColors.length > 0) {
                    chartConfigs = chartConfigs.map(config => applyCompanyColors(config, chartType));
                }

                // Stoppe Loading-Animation
                if (window.loadingInterval) {
                    clearInterval(window.loadingInterval);
                    const fill = document.getElementById('progressFill');
                    if (fill) fill.style.width = '100%';
                }

                console.log('Chart-Generierung erfolgreich, Anzahl Configs:', chartConfigs.length);

            } catch (error) {
                console.error('API Error:', error);
                console.error('Error details:', error.message, error.stack);
                // Stoppe Loading-Animation
                if (window.loadingInterval) clearInterval(window.loadingInterval);

                // Fallback zu lokaler Generierung
                console.log('Fallback zu lokaler Chart-Generierung wegen Fehler');
                generateChartVariants(chartType);
                console.log('Nach Fallback, chartConfigs:', chartConfigs.length);
            }
        }

        function showEmptyState(message) {
            document.getElementById('charts-wrapper').innerHTML = `
                <div class="chart-container">
                    <div class="empty-state">
                        <div class="empty-state-icon">📊</div>
                        <div class="empty-state-title">Keine Charts verfügbar</div>
                        <p>${message}</p>
                        <a href="upload.html" class="btn btn-primary" style="margin-top: 20px;">Neue Analyse starten</a>
                    </div>
                </div>
            `;
        }

        // =====================================================
        // VARIANTEN-GENERIERUNG (Fallback ohne API)
        // =====================================================

        function generateChartVariants(chartType) {
            // Da der 1. API-Call jetzt KEINE Configs mehr erstellt,
            // verwenden wir hier nur noch die Demo-Daten als Fallback.
            // Die echten Configs werden im 2. API-Call erstellt.

            console.log('Fallback: Verwende Demo-Daten für Chart-Typ:', chartType);

            switch (chartType) {
                case 'waterfall':
                    chartConfigs = generateDemoWaterfallConfigs();
                    break;
                case 'bar':
                    chartConfigs = generateDemoBarConfigs();
                    break;
                case 'stacked-bar':
                    chartConfigs = generateDemoStackedBarConfigs();
                    break;
                default:
                    console.warn('Unbekannter Chart-Typ:', chartType);
                    chartConfigs = generateDemoWaterfallConfigs();
            }

            // Wende Company Colors an
            chartConfigs = chartConfigs.map(config => applyCompanyColors(config, chartType));
        }

        function generateWaterfallVariants(baseConfig) {
            const bars = baseConfig.bars || [];
            const metadata = analysisResult.parsed.metadata || {};
            const unit = metadata.suggestedSubtitle || 'in TEUR';

            // Wenn keine Bars, erstelle Demo-Daten
            if (bars.length === 0) {
                return generateDemoWaterfallConfigs();
            }

            const variants = [];

            // Variante 1: Vollständige Bridge (Original)
            variants.push({
                title: 'Variante 1: Vollständige GuV Bridge',
                subtitle: unit,
                colors: { ...DEFAULT_COLORS.waterfall },
                bars: [...bars],
                bracket: baseConfig.bracket || { show: false }
            });

            // Variante 2: Kompakte Version (nur Start, größte Änderungen, End)
            const compactBars = createCompactBars(bars);
            variants.push({
                title: 'Variante 2: Kompakte Bridge',
                subtitle: unit,
                colors: { ...DEFAULT_COLORS.waterfall },
                bars: compactBars,
                bracket: { show: true, fromIndex: 0, toIndex: compactBars.length - 1, label: calculateMargin(compactBars) }
            });

            // Variante 3: Mit Vergleichsbalken
            const withCompareBars = [...bars];
            if (!withCompareBars.find(b => b.type === 'compare')) {
                const endBar = withCompareBars.find(b => b.type === 'end');
                if (endBar) {
                    withCompareBars.push({
                        type: 'compare',
                        label: 'Budget',
                        value: endBar.value * 1.1,
                        displayValue: formatValue(endBar.value * 1.1)
                    });
                }
            }
            variants.push({
                title: 'Variante 3: IST vs. Budget',
                subtitle: unit,
                colors: { ...DEFAULT_COLORS.waterfall },
                bars: withCompareBars,
                bracket: { show: true, fromIndex: 0, toIndex: withCompareBars.length - 2, label: calculateMargin(withCompareBars) }
            });

            // Variante 4: Nur Kosten (decrease items)
            const costBars = createCostFocusBars(bars);
            variants.push({
                title: 'Variante 4: Kostenstruktur',
                subtitle: unit,
                colors: { ...DEFAULT_COLORS.waterfall },
                bars: costBars,
                bracket: { show: true, fromIndex: 0, toIndex: costBars.length - 1, label: calculateMargin(costBars) }
            });

            // Variante 5: Alternative Farbgebung
            variants.push({
                title: 'Variante 5: Alternative Darstellung',
                subtitle: unit,
                colors: {
                    start: '#2E86AB',
                    end: '#2E86AB',
                    positive: '#28A745',
                    negative: '#DC3545',
                    compare: '#6C757D',
                    connector: '#444444'
                },
                bars: [...bars],
                bracket: baseConfig.bracket || { show: false }
            });

            return variants;
        }

        function generateBarVariants(baseConfig) {
            const periods = baseConfig.periods || [];
            const categories = baseConfig.categories || [];
            const metadata = analysisResult.parsed.metadata || {};
            const unit = metadata.suggestedSubtitle || 'in Mio. EUR';

            if (periods.length === 0 || categories.length === 0) {
                return generateDemoBarConfigs();
            }

            const variants = [];
            const colors = DEFAULT_COLORS.bar;

            // Variante 1: Alle Perioden
            variants.push({
                title: 'Variante 1: Alle Perioden',
                subtitle: unit,
                periods: periods.map((p, i) => ({ ...p, color: colors[i % colors.length] })),
                categories: [...categories]
            });

            // Variante 2: Nur letzte 2 Perioden
            const last2Periods = periods.slice(-2);
            variants.push({
                title: 'Variante 2: Aktueller Vergleich',
                subtitle: unit,
                periods: last2Periods.map((p, i) => ({ ...p, color: i === 0 ? '#999999' : '#0066B1' })),
                categories: categories.map(c => ({
                    ...c,
                    values: c.values.slice(-2)
                }))
            });

            // Variante 3: Erste und letzte Periode
            variants.push({
                title: 'Variante 3: Entwicklung',
                subtitle: unit,
                periods: [
                    { ...periods[0], color: '#CCCCCC' },
                    { ...periods[periods.length - 1], color: '#0066B1' }
                ],
                categories: categories.map(c => ({
                    ...c,
                    values: [c.values[0], c.values[c.values.length - 1]]
                }))
            });

            // Variante 4: Mit Highlight auf letzter Periode
            variants.push({
                title: 'Variante 4: Fokus Aktuell',
                subtitle: unit,
                periods: periods.map((p, i) => ({
                    ...p,
                    color: i === periods.length - 1 ? '#E20074' : '#CCCCCC'
                })),
                categories: [...categories]
            });

            // Variante 5: Monochrom
            variants.push({
                title: 'Variante 5: Monochrom',
                subtitle: unit,
                periods: periods.map((p, i) => {
                    const shade = Math.round(200 - (i * 40));
                    return { ...p, color: `rgb(${shade}, ${shade}, ${shade})` };
                }),
                categories: [...categories]
            });

            return variants;
        }

        function generateStackedBarVariants(baseConfig) {
            const categories = baseConfig.categories || [];
            const segments = baseConfig.segments || [];
            const metadata = analysisResult.parsed.metadata || {};
            const unit = metadata.suggestedSubtitle || 'in Tausend Euro';

            if (categories.length === 0 || segments.length === 0) {
                return generateDemoStackedBarConfigs();
            }

            const variants = [];
            const colors = DEFAULT_COLORS.stacked;

            // Variante 1: Alle Segmente
            variants.push({
                title: 'Variante 1: Vollständige Darstellung',
                subtitle: unit,
                categories: [...categories],
                segments: segments.map((s, i) => ({ ...s, color: colors[i % colors.length] })),
                options: { showValues: true, showTotals: true, showLegend: true }
            });

            // Variante 2: Top 4 + Sonstige
            const top4Segments = createTop4PlusSonstige(segments);
            variants.push({
                title: 'Variante 2: Top 4 + Sonstige',
                subtitle: unit,
                categories: [...categories],
                segments: top4Segments.map((s, i) => ({ ...s, color: colors[i % colors.length] })),
                options: { showValues: true, showTotals: true, showLegend: true }
            });

            // Variante 3: Mit Prozent-Labels
            variants.push({
                title: 'Variante 3: Prozentuale Anteile',
                subtitle: unit,
                categories: [...categories],
                segments: segments.map((s, i) => ({ ...s, color: colors[i % colors.length] })),
                options: { showValues: true, showPercentages: true, showTotals: true, showLegend: true }
            });

            // Variante 4: Normalisiert auf 100%
            variants.push({
                title: 'Variante 4: Normalisiert (100%)',
                subtitle: 'Anteil in %',
                categories: [...categories],
                segments: segments.map((s, i) => ({ ...s, color: colors[i % colors.length] })),
                options: { showValues: true, showPercentages: true, normalized: true, showLegend: true }
            });

            // Variante 5: Ohne Werte, nur visuell
            variants.push({
                title: 'Variante 5: Visueller Vergleich',
                subtitle: unit,
                categories: [...categories],
                segments: segments.map((s, i) => ({ ...s, color: colors[i % colors.length] })),
                options: { showValues: false, showTotals: true, showLegend: true }
            });

            return variants;
        }

        // =====================================================
        // DEMO-DATEN (wenn keine echten Daten vorhanden)
        // =====================================================

        // Demo-Konfigurationen basierend auf guv-waterfall-examples.html
        function generateDemoWaterfallConfigs() {
            // Variante 1: GuV Bridge Dezember IST - Vollständige P&L (wie config1)
            const variant1 = {
                title: 'Chart 1: GuV Bridge Dezember (IST)',
                subtitle: 'Von Umsatzerlösen zum EBIT - in TEUR',
                colors: {
                    start: '#1B4F72',
                    end: '#1B4F72',
                    positive: '#27AE60',
                    negative: '#E74C3C',
                    compare: '#7F8C8D',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'Umsatz-\nerlöse', value: 185, displayValue: '185 T€' },
                    { type: 'increase', label: 'Bestands-\nveränd.', value: 2.5, displayValue: '+2,5 T€' },
                    { type: 'increase', label: 'Aktivierte\nEigenleist.', value: 1.2, displayValue: '+1,2 T€' },
                    { type: 'increase', label: 'Sonst. betr.\nErträge', value: 3.8, displayValue: '+3,8 T€' },
                    { type: 'decrease', label: 'Material-\naufwand', value: -98.5, displayValue: '-98,5 T€' },
                    { type: 'decrease', label: 'Personal-\naufwand', value: -52, displayValue: '-52 T€' },
                    { type: 'decrease', label: 'Abschrei-\nbungen', value: -8.5, displayValue: '-8,5 T€' },
                    { type: 'decrease', label: 'Sonst. betr.\nAufw.', value: -18.2, displayValue: '-18,2 T€' },
                    { type: 'end', label: 'EBIT', value: 15.3, displayValue: '15,3 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 8, label: '8,3% Marge' }
            };

            // Variante 2: EBIT Bridge Gesamtjahr - IST vs. Budget (wie config2)
            const variant2 = {
                title: 'Chart 2: EBIT Bridge Gesamtjahr',
                subtitle: 'IST vs. Budget - in T€',
                colors: {
                    start: '#2E86AB',
                    end: '#2E86AB',
                    positive: '#28A745',
                    negative: '#DC3545',
                    compare: '#6C757D',
                    connector: '#444444'
                },
                bars: [
                    { type: 'start', label: 'EBIT\nBudget', value: 190, displayValue: '190 T€' },
                    { type: 'increase', label: 'Umsatz\n+35 T€', value: 35, displayValue: '+35 T€' },
                    { type: 'increase', label: 'Sonst. Ertr.\n+3 T€', value: 3, displayValue: '+3 T€' },
                    { type: 'decrease', label: 'Material\n-28 T€', value: -28, displayValue: '-28 T€' },
                    { type: 'decrease', label: 'Personal\n-18 T€', value: -18, displayValue: '-18 T€' },
                    { type: 'decrease', label: 'Abschr.\n-3 T€', value: -3, displayValue: '-3 T€' },
                    { type: 'end', label: 'EBIT\nIST', value: 179.5, displayValue: '179,5 T€' },
                    { type: 'compare', label: 'EBIT\nForecast', value: 187, displayValue: '187 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 6, label: '-5,5%' }
            };

            // Variante 3: Kostenstruktur-Analyse Gesamtjahr (wie config3)
            const variant3 = {
                title: 'Chart 3: Kostenstruktur-Analyse',
                subtitle: 'Von Gesamtleistung zum EBIT - in T€',
                colors: {
                    start: '#1A535C',
                    end: '#1A535C',
                    positive: '#4ECDC4',
                    negative: '#FF6B6B',
                    compare: '#A0A0A0',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'Gesamt-\nleistung', value: 2282.5, displayValue: '2.283 T€' },
                    { type: 'decrease', label: 'Material\n(51,2%)', value: -1168, displayValue: '-1.168 T€' },
                    { type: 'decrease', label: 'Personal\n(27,1%)', value: -618, displayValue: '-618 T€' },
                    { type: 'decrease', label: 'Abschreib.\n(4,4%)', value: -101, displayValue: '-101 T€' },
                    { type: 'decrease', label: 'Sonst. Aufw.\n(9,5%)', value: -216, displayValue: '-216 T€' },
                    { type: 'end', label: 'EBIT\n(7,9%)', value: 179.5, displayValue: '179,5 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 5, label: '7,9% Marge' }
            };

            // Variante 4: Dezember Plan-Ist-Abweichung (wie config4)
            const variant4 = {
                title: 'Chart 4: Plan-Ist-Abweichung Dezember',
                subtitle: 'Vom Budget-JÜ zum IST-JÜ - in T€',
                colors: {
                    start: '#5D4E8C',
                    end: '#5D4E8C',
                    positive: '#2ECC71',
                    negative: '#E74C3C',
                    compare: '#95A5A6',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'JÜ\nBudget', value: 8.54, displayValue: '8,54 T€' },
                    { type: 'increase', label: 'Umsatz\n+5 T€', value: 5, displayValue: '+5 T€' },
                    { type: 'increase', label: 'Sonst. Ertr.\n+0,3 T€', value: 0.3, displayValue: '+0,3 T€' },
                    { type: 'decrease', label: 'Material\n-2,5 T€', value: -2.5, displayValue: '-2,5 T€' },
                    { type: 'decrease', label: 'Personal\n-2 T€', value: -2, displayValue: '-2 T€' },
                    { type: 'decrease', label: 'Sonstige\n-0,5 T€', value: -0.5, displayValue: '-0,5 T€' },
                    { type: 'end', label: 'JÜ\nIST', value: 8.84, displayValue: '8,84 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 6, label: '+3,5%' }
            };

            // Variante 5: Vom EBIT zum Jahresüberschuss (wie config5)
            const variant5 = {
                title: 'Chart 5: EBIT zu Jahresüberschuss',
                subtitle: 'Gesamtjahr - in T€',
                colors: {
                    start: '#34495E',
                    end: '#34495E',
                    positive: '#27AE60',
                    negative: '#C0392B',
                    compare: '#7F8C8D',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'EBIT', value: 179.5, displayValue: '179,5 T€' },
                    { type: 'increase', label: 'Zins-\nerträge', value: 1.45, displayValue: '+1,45 T€' },
                    { type: 'decrease', label: 'Zins-\naufwand', value: -33.5, displayValue: '-33,5 T€' },
                    { type: 'end', label: 'EBT', value: 147.45, displayValue: '147,45 T€' },
                    { type: 'decrease', label: 'Steuern', value: -44.24, displayValue: '-44,24 T€' },
                    { type: 'end', label: 'Jahres-\nüberschuss', value: 103.21, displayValue: '103,21 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 5, label: '-42,5%' }
            };

            // Variante 6: Cash Flow Bridge
            const variant6 = {
                title: 'Chart 6: Cash Flow Bridge',
                subtitle: 'Operating Cash Flow - in T€',
                colors: {
                    start: '#1B4F72',
                    end: '#1B4F72',
                    positive: '#27AE60',
                    negative: '#E74C3C',
                    compare: '#7F8C8D',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'Jahres-\nüberschuss', value: 103.21, displayValue: '103,21 T€' },
                    { type: 'increase', label: 'Abschrei-\nbungen', value: 101, displayValue: '+101 T€' },
                    { type: 'decrease', label: 'Working\nCapital', value: -45, displayValue: '-45 T€' },
                    { type: 'increase', label: 'Rück-\nstellungen', value: 12, displayValue: '+12 T€' },
                    { type: 'end', label: 'Operativer\nCash Flow', value: 171.21, displayValue: '171,21 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 4, label: '+66%' }
            };

            // Variante 7: Umsatzentwicklung Q1-Q4
            const variant7 = {
                title: 'Chart 7: Umsatzentwicklung',
                subtitle: 'Quartalsweise Veränderung - in T€',
                colors: {
                    start: '#2E86AB',
                    end: '#2E86AB',
                    positive: '#28A745',
                    negative: '#DC3545',
                    compare: '#6C757D',
                    connector: '#444444'
                },
                bars: [
                    { type: 'start', label: 'Q1\nUmsatz', value: 520, displayValue: '520 T€' },
                    { type: 'increase', label: 'Q2\nWachstum', value: 45, displayValue: '+45 T€' },
                    { type: 'increase', label: 'Q3\nWachstum', value: 62, displayValue: '+62 T€' },
                    { type: 'decrease', label: 'Q4\nRückgang', value: -18, displayValue: '-18 T€' },
                    { type: 'end', label: 'Jahres-\numsatz', value: 609, displayValue: '609 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 4, label: '+17,1%' }
            };

            // Variante 8: Margenanalyse
            const variant8 = {
                title: 'Chart 8: Margenanalyse',
                subtitle: 'Von Bruttomarge zu Nettomarge - in %',
                colors: {
                    start: '#1A535C',
                    end: '#1A535C',
                    positive: '#4ECDC4',
                    negative: '#FF6B6B',
                    compare: '#A0A0A0',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'Brutto-\nmarge', value: 42.5, displayValue: '42,5%' },
                    { type: 'decrease', label: 'Personal', value: -12.3, displayValue: '-12,3%' },
                    { type: 'decrease', label: 'Marketing', value: -5.8, displayValue: '-5,8%' },
                    { type: 'decrease', label: 'Overhead', value: -8.2, displayValue: '-8,2%' },
                    { type: 'decrease', label: 'Abschreib.', value: -3.5, displayValue: '-3,5%' },
                    { type: 'end', label: 'EBIT-\nMarge', value: 12.7, displayValue: '12,7%' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 5, label: '-29,8%pt' }
            };

            // Variante 9: Segment Performance
            const variant9 = {
                title: 'Chart 9: Segment Performance',
                subtitle: 'Beitrag der Geschäftsbereiche - in T€',
                colors: {
                    start: '#5D4E8C',
                    end: '#5D4E8C',
                    positive: '#2ECC71',
                    negative: '#E74C3C',
                    compare: '#95A5A6',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'Konzern-\nEBIT VJ', value: 150, displayValue: '150 T€' },
                    { type: 'increase', label: 'Segment A', value: 28, displayValue: '+28 T€' },
                    { type: 'increase', label: 'Segment B', value: 15, displayValue: '+15 T€' },
                    { type: 'decrease', label: 'Segment C', value: -8, displayValue: '-8 T€' },
                    { type: 'decrease', label: 'Holding', value: -5.5, displayValue: '-5,5 T€' },
                    { type: 'end', label: 'Konzern-\nEBIT CY', value: 179.5, displayValue: '179,5 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 5, label: '+19,7%' }
            };

            // Variante 10: Investitionsrechnung
            const variant10 = {
                title: 'Chart 10: Investitionsrechnung',
                subtitle: 'Free Cash Flow Verwendung - in T€',
                colors: {
                    start: '#34495E',
                    end: '#34495E',
                    positive: '#27AE60',
                    negative: '#C0392B',
                    compare: '#7F8C8D',
                    connector: '#333333'
                },
                bars: [
                    { type: 'start', label: 'Free\nCash Flow', value: 171.21, displayValue: '171,21 T€' },
                    { type: 'decrease', label: 'CAPEX', value: -85, displayValue: '-85 T€' },
                    { type: 'decrease', label: 'Dividende', value: -30, displayValue: '-30 T€' },
                    { type: 'decrease', label: 'Tilgung', value: -25, displayValue: '-25 T€' },
                    { type: 'end', label: 'Überschuss', value: 31.21, displayValue: '31,21 T€' }
                ],
                bracket: { show: true, fromIndex: 0, toIndex: 4, label: '-81,8%' }
            };

            return [variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9, variant10];
        }

        function generateDemoBarConfigs() {
            // Variante 1: Alle Quartale
            const variant1 = {
                title: 'Chart 1: Quartalsvergleich',
                subtitle: 'Revenue in Mio. EUR',
                periods: [
                    { label: 'Q1', color: '#CCCCCC' },
                    { label: 'Q2', color: '#999999' },
                    { label: 'Q3', color: '#666666' },
                    { label: 'Q4', color: '#0066B1' }
                ],
                categories: [{ name: 'Revenue', subtitle: 'in Mio. EUR', values: [245, 268, 312, 358] }],
                showBrackets: true
            };

            // Variante 2: Nur Q3 vs Q4
            const variant2 = {
                title: 'Chart 2: Aktueller Vergleich',
                subtitle: 'Q3 vs. Q4 in Mio. EUR',
                periods: [
                    { label: 'Q3', color: '#999999' },
                    { label: 'Q4', color: '#0066B1' }
                ],
                categories: [{ name: 'Revenue', subtitle: '', values: [312, 358] }],
                showBrackets: true
            };

            // Variante 3: Mehrere Kategorien
            const variant3 = {
                title: 'Chart 3: Multi-Kategorie',
                subtitle: 'IST vs. Budget in TEUR',
                periods: [
                    { label: 'IST', color: '#0066B1' },
                    { label: 'Budget', color: '#CCCCCC' }
                ],
                categories: [
                    { name: 'Umsatz', values: [1850, 1900] },
                    { name: 'EBIT', values: [153, 180] },
                    { name: 'Cash Flow', values: [245, 220] }
                ],
                showBrackets: false
            };

            // Variante 4: Horizontale Balken (simuliert)
            const variant4 = {
                title: 'Chart 4: Jahr-zu-Jahr',
                subtitle: 'Jahresvergleich in Mio. EUR',
                periods: [
                    { label: '2023', color: '#CCCCCC' },
                    { label: '2024', color: '#0066B1' }
                ],
                categories: [{ name: 'Gesamtumsatz', values: [1120, 1183] }],
                showBrackets: true
            };

            // Variante 5: Monochrom
            const variant5 = {
                title: 'Chart 5: Monochrome Darstellung',
                subtitle: 'Quartale in Mio. EUR',
                periods: [
                    { label: 'Q1', color: '#1E3A5F' },
                    { label: 'Q2', color: '#2E5A88' },
                    { label: 'Q3', color: '#5B8DBE' },
                    { label: 'Q4', color: '#8BBDE0' }
                ],
                categories: [{ name: 'Revenue', values: [245, 268, 312, 358] }],
                showBrackets: false
            };

            // Variante 6: Mit Budget-Vergleich
            const variant6 = {
                title: 'Chart 6: IST vs Budget',
                subtitle: 'Quartale mit Planwerten - in Mio. EUR',
                periods: [
                    { label: 'Q1 IST', color: '#333333', type: 'IST' },
                    { label: 'Q1 BUD', color: '#999999', type: 'BUD' },
                    { label: 'Q2 IST', color: '#333333', type: 'IST' },
                    { label: 'Q2 BUD', color: '#999999', type: 'BUD' }
                ],
                categories: [{ name: 'Revenue', values: [245, 240, 268, 255] }],
                showBrackets: true
            };

            // Variante 7: Multi-Kategorie
            const variant7 = {
                title: 'Chart 7: Produkt-Performance',
                subtitle: 'Nach Kategorie - in T€',
                periods: [
                    { label: '2023', color: '#666666' },
                    { label: '2024', color: '#0066B1' }
                ],
                categories: [
                    { name: 'Produkt A', values: [320, 385] },
                    { name: 'Produkt B', values: [280, 312] },
                    { name: 'Produkt C', values: [195, 225] }
                ],
                showBrackets: true
            };

            // Variante 8: Forecast
            const variant8 = {
                title: 'Chart 8: Halbjahres-Forecast',
                subtitle: 'H1 vs H2 - in Mio. EUR',
                periods: [
                    { label: 'H1 IST', color: '#333333', type: 'IST' },
                    { label: 'H2 FC', color: '#0066B1', type: 'FC' }
                ],
                categories: [{ name: 'Umsatz', values: [513, 548] }],
                showBrackets: true
            };

            // Variante 9: Regional
            const variant9 = {
                title: 'Chart 9: Regionale Verteilung',
                subtitle: 'Nach Standort - in T€',
                periods: [
                    { label: 'DACH', color: '#1E3A5F' },
                    { label: 'EU', color: '#2E5A88' },
                    { label: 'USA', color: '#5B8DBE' },
                    { label: 'APAC', color: '#8BBDE0' }
                ],
                categories: [{ name: 'Revenue', values: [425, 312, 285, 161] }],
                showBrackets: false
            };

            // Variante 10: Wachstum
            const variant10 = {
                title: 'Chart 10: 5-Jahres-Wachstum',
                subtitle: 'Langfristentwicklung - in Mio. EUR',
                periods: [
                    { label: '2020', color: '#E8E8E8' },
                    { label: '2021', color: '#CCCCCC' },
                    { label: '2022', color: '#999999' },
                    { label: '2023', color: '#666666' },
                    { label: '2024', color: '#333333' }
                ],
                categories: [{ name: 'Gesamtumsatz', values: [850, 920, 1025, 1120, 1183] }],
                showBrackets: true
            };

            return [variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9, variant10];
        }

        function generateDemoStackedBarConfigs() {
            // Variante 1: Alle Segmente
            const variant1 = {
                title: 'Chart 1: Kostenstruktur nach Standort',
                subtitle: 'in Tausend Euro',
                categories: [
                    { label: 'Berlin' }, { label: 'München' }, { label: 'Hamburg' }
                ],
                segments: [
                    { name: 'Personal', color: '#1E3A5F', values: [450, 520, 380] },
                    { name: 'Miete', color: '#2E5A88', values: [180, 280, 150] },
                    { name: 'Material', color: '#5B8DBE', values: [120, 95, 140] },
                    { name: 'IT', color: '#8BBDE0', values: [80, 65, 55] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            // Variante 2: Top 3 + Sonstige
            const variant2 = {
                title: 'Chart 2: Top 3 + Sonstige',
                subtitle: 'Zusammengefasst - in TEUR',
                categories: [
                    { label: 'Berlin' }, { label: 'München' }, { label: 'Hamburg' }
                ],
                segments: [
                    { name: 'Personal', color: '#1E3A5F', values: [450, 520, 380] },
                    { name: 'Miete', color: '#2E5A88', values: [180, 280, 150] },
                    { name: 'Sonstige', color: '#B8D4E8', values: [200, 160, 195] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            // Variante 3: Mit Prozent-Labels
            const variant3 = {
                title: 'Chart 3: Prozentuale Anteile',
                subtitle: 'Relative Verteilung',
                categories: [
                    { label: 'Berlin' }, { label: 'München' }, { label: 'Hamburg' }
                ],
                segments: [
                    { name: 'Personal', color: '#1E3A5F', values: [54, 54, 52] },
                    { name: 'Miete', color: '#2E5A88', values: [22, 29, 21] },
                    { name: 'Material', color: '#5B8DBE', values: [14, 10, 19] },
                    { name: 'IT', color: '#8BBDE0', values: [10, 7, 8] }
                ],
                options: { showValues: true, showTotals: false, showLegend: true, showPercent: true }
            };

            // Variante 4: Zeitvergleich mit Schraffur
            const variant4 = {
                title: 'Chart 4: IST vs. Plan',
                subtitle: 'Mit Schraffur für Plan-Werte',
                categories: [
                    { label: 'IST', hatched: false }, { label: 'Plan', hatched: true }
                ],
                segments: [
                    { name: 'Personal', color: '#1E3A5F', values: [450, 480] },
                    { name: 'Miete', color: '#2E5A88', values: [180, 175] },
                    { name: 'Material', color: '#5B8DBE', values: [120, 130] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            // Variante 5: Minimalistisch
            const variant5 = {
                title: 'Chart 5: Clean Design',
                subtitle: 'Ohne Zahlen',
                categories: [
                    { label: 'Q1' }, { label: 'Q2' }, { label: 'Q3' }, { label: 'Q4' }
                ],
                segments: [
                    { name: 'A', color: '#1E3A5F', values: [40, 45, 48, 52] },
                    { name: 'B', color: '#5B8DBE', values: [30, 32, 28, 35] },
                    { name: 'C', color: '#B8D4E8', values: [30, 23, 24, 13] }
                ],
                options: { showValues: false, showTotals: false, showLegend: true }
            };

            // Variante 6: Prozentual
            const variant6 = {
                title: 'Chart 6: Anteil am Gesamtumsatz',
                subtitle: 'Prozentuale Verteilung',
                categories: [
                    { label: 'Berlin' }, { label: 'München' }, { label: 'Hamburg' }
                ],
                segments: [
                    { name: 'Personal', color: '#1E3A5F', values: [54, 54, 52] },
                    { name: 'Miete', color: '#2E5A88', values: [22, 29, 21] },
                    { name: 'Material', color: '#5B8DBE', values: [14, 10, 19] },
                    { name: 'IT', color: '#8BBDE0', values: [10, 7, 8] }
                ],
                options: { showValues: true, showTotals: false, showLegend: true, isPercentage: true }
            };

            // Variante 7: Zeitreihe
            const variant7 = {
                title: 'Chart 7: Entwicklung über Zeit',
                subtitle: 'Q1-Q4 - in TEUR',
                categories: [
                    { label: 'Q1' }, { label: 'Q2' }, { label: 'Q3' }, { label: 'Q4' }
                ],
                segments: [
                    { name: 'Produkt A', color: '#1E3A5F', values: [120, 135, 142, 155] },
                    { name: 'Produkt B', color: '#2E5A88', values: [95, 88, 102, 98] },
                    { name: 'Produkt C', color: '#5B8DBE', values: [65, 72, 68, 85] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            // Variante 8: Zwei Kategorien
            const variant8 = {
                title: 'Chart 8: IST vs PLAN',
                subtitle: 'Kostenvergleich - in TEUR',
                categories: [
                    { label: 'IST' }, { label: 'PLAN' }
                ],
                segments: [
                    { name: 'Personal', color: '#1E3A5F', values: [520, 500] },
                    { name: 'Miete', color: '#2E5A88', values: [280, 270] },
                    { name: 'Material', color: '#5B8DBE', values: [140, 155] },
                    { name: 'IT', color: '#8BBDE0', values: [85, 90] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            // Variante 9: Viele Kategorien
            const variant9 = {
                title: 'Chart 9: Monatliche Entwicklung',
                subtitle: 'Jan-Jun - in TEUR',
                categories: [
                    { label: 'Jan' }, { label: 'Feb' }, { label: 'Mär' },
                    { label: 'Apr' }, { label: 'Mai' }, { label: 'Jun' }
                ],
                segments: [
                    { name: 'Umsatz', color: '#1E3A5F', values: [85, 92, 88, 95, 102, 98] },
                    { name: 'Kosten', color: '#5B8DBE', values: [72, 78, 75, 80, 85, 82] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            // Variante 10: Regional
            const variant10 = {
                title: 'Chart 10: Regionale Verteilung',
                subtitle: 'Nach Geschäftsbereich - in T€',
                categories: [
                    { label: 'DACH' }, { label: 'EU' }, { label: 'USA' }
                ],
                segments: [
                    { name: 'Consulting', color: '#1E3A5F', values: [180, 120, 95] },
                    { name: 'Produkte', color: '#2E5A88', values: [220, 185, 240] },
                    { name: 'Services', color: '#5B8DBE', values: [95, 65, 55] }
                ],
                options: { showValues: true, showTotals: true, showLegend: true }
            };

            return [variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9, variant10];
        }

        // =====================================================
        // HILFSFUNKTIONEN FÜR VARIANTEN
        // =====================================================

        function createCompactBars(bars) {
            const start = bars.find(b => b.type === 'start');
            const end = bars.find(b => b.type === 'end');
            const increases = bars.filter(b => b.type === 'increase').sort((a, b) => b.value - a.value);
            const decreases = bars.filter(b => b.type === 'decrease').sort((a, b) => a.value - b.value);

            const result = [start];
            if (increases.length > 0) result.push(increases[0]);
            if (decreases.length > 0) result.push(decreases[0]);
            if (decreases.length > 1) result.push(decreases[1]);
            result.push(end);

            return result.filter(Boolean);
        }

        function createCostFocusBars(bars) {
            const start = bars.find(b => b.type === 'start');
            const decreases = bars.filter(b => b.type === 'decrease');
            const end = bars.find(b => b.type === 'end');

            const totalRevenue = start ? start.value : 100;
            const costStart = {
                type: 'start',
                label: 'Gesamt-\nleistung',
                value: totalRevenue,
                displayValue: formatValue(totalRevenue)
            };

            return [costStart, ...decreases, end].filter(Boolean);
        }

        function createTop4PlusSonstige(segments) {
            if (segments.length <= 5) return segments;

            const sorted = [...segments].sort((a, b) => {
                const sumA = a.values.reduce((x, y) => x + y, 0);
                const sumB = b.values.reduce((x, y) => x + y, 0);
                return sumB - sumA;
            });

            const top4 = sorted.slice(0, 4);
            const rest = sorted.slice(4);

            const sonstigeValues = rest[0].values.map((_, i) =>
                rest.reduce((sum, seg) => sum + seg.values[i], 0)
            );

            return [...top4, { name: 'Sonstiges', values: sonstigeValues }];
        }

        function calculateMargin(bars) {
            const start = bars.find(b => b.type === 'start');
            const end = bars.find(b => b.type === 'end');
            if (!start || !end) return '';
            const margin = ((end.value / start.value) * 100).toFixed(1);
            return `${margin}% Marge`;
        }

        function formatValue(value) {
            if (value === undefined || value === null) return '';
            const num = parseFloat(value);
            if (isNaN(num)) return String(value);
            return num.toLocaleString('de-DE', { maximumFractionDigits: 1 }) + ' T€';
        }

        // =====================================================
        // COMPANY COLORS ANWENDEN
        // =====================================================

        function applyCompanyColors(config, chartType) {
            if (companyColors.length === 0) return config;

            const newConfig = JSON.parse(JSON.stringify(config));

            switch (chartType) {
                case 'waterfall':
                    if (newConfig.colors) {
                        newConfig.colors.start = companyColors[0] || newConfig.colors.start;
                        newConfig.colors.end = companyColors[0] || newConfig.colors.end;
                        newConfig.colors.positive = companyColors[1] || newConfig.colors.positive;
                        newConfig.colors.negative = companyColors[2] || newConfig.colors.negative;
                        newConfig.colors.compare = companyColors[3] || newConfig.colors.compare;
                        newConfig.colors.connector = companyColors[4] || newConfig.colors.connector;
                    }
                    break;

                case 'bar':
                    if (newConfig.periods) {
                        newConfig.periods = newConfig.periods.map((p, i) => ({
                            ...p,
                            color: companyColors[i % companyColors.length] || p.color
                        }));
                    }
                    break;

                case 'stacked-bar':
                    if (newConfig.segments) {
                        newConfig.segments = newConfig.segments.map((s, i) => ({
                            ...s,
                            color: companyColors[i % companyColors.length] || s.color
                        }));
                    }
                    break;
            }

            return newConfig;
        }

        // =====================================================
        // KI-ENTSCHEIDUNGEN (CHAIN OF THOUGHT)
        // =====================================================

        function collectReasoningData(profile, selectedTemplates, configs, chartType) {
            aiReasoningData = {
                profile: profile,
                selectedTemplates: selectedTemplates || [],
                chartConfigs: configs || [],
                timestamp: new Date().toISOString(),
                chartType: chartType,
                chartCount: (configs || []).length,
                reasoning: generateReasoning(profile, chartType, configs)
            };
        }

        /**
         * Generiert automatisch Begruendungen basierend auf Daten-Profil und Auswahl
         */
        function generateReasoning(profile, chartType, configs) {
            const reasoning = {
                chartTypeReason: '',
                templateReasons: [],
                dataInsights: [],
                mixStrategy: ''
            };

            if (!profile) {
                reasoning.chartTypeReason = 'Demo-Modus: Beispiel-Charts werden angezeigt, da keine Daten analysiert wurden.';
                reasoning.mixStrategy = 'Ausgewogene Verteilung von Waterfall, Bar und Stacked Bar Charts fuer maximale Vielfalt.';
                return reasoning;
            }

            // 1. Begruendung fuer Chart-Typ basierend auf Daten-Profil
            const reportType = profile.report_type || 'financial_report';
            const rowCount = profile.row_count || 0;
            const hasVariance = profile.has_variance_column;
            const hasBudget = profile.has_budget;
            const hasPriorYear = profile.has_prior_year;

            if (chartType === 'waterfall') {
                reasoning.chartTypeReason = `Waterfall gewaehlt: ${
                    reportType === 'income_statement'
                        ? 'Ideal fuer GuV-Darstellung mit Kostenaufschluesselung vom Umsatz zum Ergebnis.'
                        : 'Zeigt Veraenderungen zwischen Ausgangs- und Endwert als Bridge.'
                }`;
            } else if (chartType === 'bar') {
                reasoning.chartTypeReason = `Bar Chart gewaehlt: ${
                    hasBudget || hasVariance
                        ? 'Optimal fuer Soll/Ist-Vergleiche und Abweichungsanalysen.'
                        : 'Klare Darstellung von Kategorien im direkten Vergleich.'
                }`;
            } else if (chartType === 'stacked-bar') {
                reasoning.chartTypeReason = `Stacked Bar gewaehlt: ${
                    rowCount > 5
                        ? 'Zeigt Zusammensetzung und Anteile bei mehreren Kategorien.'
                        : 'Visualisiert Teil-Ganzes-Beziehungen uebersichtlich.'
                }`;
            }

            // 2. Daten-Insights generieren
            if (reportType === 'income_statement') {
                reasoning.dataInsights.push('GuV-Struktur erkannt: Umsatz, Kosten und Ergebniszeilen identifiziert');
            }
            if (hasBudget) {
                reasoning.dataInsights.push('Budget-Werte vorhanden: Plan/Ist-Vergleich moeglich');
            }
            if (hasPriorYear) {
                reasoning.dataInsights.push('Vorjahreswerte erkannt: Jahresvergleich empfohlen');
            }
            if (hasVariance) {
                reasoning.dataInsights.push('Varianz-Spalten gefunden: Abweichungsanalyse sinnvoll');
            }
            if (rowCount >= 10) {
                reasoning.dataInsights.push(`${rowCount} Datenpunkte: Detaillierte Analyse moeglich`);
            } else if (rowCount >= 5) {
                reasoning.dataInsights.push(`${rowCount} Datenpunkte: Kompakte Darstellung empfohlen`);
            }

            // 3. Template-Begruendungen (wenn Templates vorhanden)
            if (configs && configs.length > 0) {
                configs.forEach((config, index) => {
                    let reason = '';
                    const title = config.title || '';

                    if (title.toLowerCase().includes('bridge') || title.toLowerCase().includes('guv')) {
                        reason = 'Zeigt Ergebnisherleitung Schritt fuer Schritt';
                    } else if (title.toLowerCase().includes('vergleich') || title.toLowerCase().includes('comparison')) {
                        reason = 'Ermoeglicht direkten Periodenvergleich';
                    } else if (title.toLowerCase().includes('struktur') || title.toLowerCase().includes('kostenstruktur')) {
                        reason = 'Visualisiert Kostenverteilung und -anteile';
                    } else if (title.toLowerCase().includes('abweichung') || title.toLowerCase().includes('varianz')) {
                        reason = 'Hebt Plan-Ist-Differenzen hervor';
                    } else if (title.toLowerCase().includes('trend') || title.toLowerCase().includes('entwicklung')) {
                        reason = 'Zeigt zeitliche Entwicklung';
                    } else if (title.toLowerCase().includes('top') || title.toLowerCase().includes('ranking')) {
                        reason = 'Fokussiert auf wichtigste Treiber';
                    } else {
                        reason = 'Ergaenzende Perspektive auf die Daten';
                    }

                    reasoning.templateReasons.push({
                        title: title,
                        reason: reason
                    });
                });
            }

            return reasoning;
        }

        function renderReasoningSection() {
            const section = document.getElementById('ai-reasoning-section');
            const content = document.getElementById('reasoningContent');

            // Immer anzeigen wenn chartConfigs vorhanden sind
            if (aiReasoningData.chartConfigs.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';

            let html = '';
            const isDemo = !sessionStorage.getItem('apiKey');
            const profile = aiReasoningData.profile || {};
            const reasoning = aiReasoningData.reasoning || {};

            // 1. DATENPROFIL - Überblick über die Quelldaten
            html += `
                <div class="reasoning-section">
                    <div class="reasoning-section-title">Datenprofil</div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Report-Typ:</span>
                        <span class="reasoning-value">${profile.report_type || 'Demo-Daten'}</span>
                    </div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Datenpunkte:</span>
                        <span class="reasoning-value">${profile.row_count || aiReasoningData.chartConfigs.length || '-'}</span>
                    </div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Perioden:</span>
                        <span class="reasoning-value">${profile.period_count || '-'}</span>
                    </div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Wertarten:</span>
                        <span class="reasoning-value">${(profile.available_value_types || []).join(', ') || 'IST'}</span>
                    </div>
                    ${profile.has_budget ? '<div class="reasoning-item"><span class="reasoning-value">✓ Budget-Daten verfügbar</span></div>' : ''}
                    ${profile.has_prior_year ? '<div class="reasoning-item"><span class="reasoning-value">✓ Vorjahres-Daten verfügbar</span></div>' : ''}
                </div>
            `;

            // 2. ERKANNTE DATENMUSTER - Was die KI in den Daten gefunden hat
            if (reasoning.dataInsights && reasoning.dataInsights.length > 0) {
                html += `
                    <div class="reasoning-section">
                        <div class="reasoning-section-title">Erkannte Datenmuster</div>
                        <div class="reasoning-item" style="flex-direction: column; align-items: flex-start;">
                            ${reasoning.dataInsights.map(insight => `
                                <div style="margin-bottom: 4px;">• ${insight}</div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // 3. ENTSCHEIDUNGSBEGRÜNDUNG - Warum diese Chart-Auswahl
            html += `
                <div class="reasoning-section">
                    <div class="reasoning-section-title">Entscheidungsbegründung</div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Warum diese Charts?</span>
                        <span class="reasoning-value">${reasoning.chartTypeReason || 'Automatische Auswahl basierend auf Datenstruktur.'}</span>
                    </div>
                    ${reasoning.mixStrategy ? `
                    <div class="reasoning-item">
                        <span class="reasoning-label">Mix-Strategie:</span>
                        <span class="reasoning-value">${reasoning.mixStrategy}</span>
                    </div>
                    ` : ''}
                </div>
            `;

            // 4. Chart-Auswahl mit Modus
            const chartTypeLabel = {
                'waterfall': 'Waterfall Charts',
                'bar': 'Bar Charts',
                'stacked-bar': 'Stacked Bar Charts',
                'stacked_bar': 'Stacked Bar Charts'  // Alternative Schreibweise
            };

            // Generierungsmodus Label (nur noch 2 Modi: ai und demo)
            const generationModeLabels = {
                'ai': 'KI-generiert (Claude API)',
                'demo': 'Demo-Modus (Beispieldaten)'
            };
            const generationMode = aiReasoningData.generationMode || 'demo';
            const generationModeLabel = generationModeLabels[generationMode] || 'Demo-Modus (Beispieldaten)';
            const isDemoMode = generationMode === 'demo';

            // Zaehle KI-generierte Charts
            const aiGeneratedCount = aiReasoningData.chartConfigs.filter(c => c._generatedBy === 'ai').length;

            // Demo-Modus Banner (wenn nicht KI)
            if (isDemoMode) {
                const errorMessages = (aiReasoningData.errors || []).map(e => e.error).join(', ');
                html += `
                    <div class="demo-warning" style="background: #fef3c7; border: 2px solid #f59e0b; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                        <strong style="color: #92400e;">⚠️ Demo-Modus aktiv</strong><br>
                        <span style="color: #78350f;">
                            ${aiReasoningData.apiKeyPresent
                                ? 'KI-Generierung fehlgeschlagen - Beispieldaten werden angezeigt.'
                                : 'Kein API-Key vorhanden - Beispieldaten werden angezeigt.'}
                        </span>
                        ${errorMessages ? `<br><br><span style="color: #b45309; font-size: 12px;">Fehler: ${errorMessages}</span>` : ''}
                    </div>
                `;
            }

            html += `
                <div class="reasoning-section">
                    <div class="reasoning-section-title">Generierungseinstellungen</div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Chart-Typ:</span>
                        <span class="reasoning-value">${chartTypeLabel[aiReasoningData.chartType] || aiReasoningData.chartType || 'Nicht festgelegt'}</span>
                    </div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Anzahl Charts:</span>
                        <span class="reasoning-value">${aiReasoningData.chartCount}</span>
                    </div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">Generierungsmodus:</span>
                        <span class="reasoning-value" style="color: ${generationMode === 'ai' ? '#16a34a' : '#d97706'}; font-weight: 500;">
                            ${generationModeLabel}
                        </span>
                    </div>
                    <div class="reasoning-item">
                        <span class="reasoning-label">API-Key:</span>
                        <span class="reasoning-value">${aiReasoningData.apiKeyPresent ? 'Vorhanden' : 'Nicht vorhanden'}</span>
                    </div>
                    ${aiGeneratedCount > 0 ? `
                    <div class="reasoning-item">
                        <span class="reasoning-label">KI-generierte Charts:</span>
                        <span class="reasoning-value">${aiGeneratedCount}</span>
                    </div>
                    ` : ''}
                    ${aiReasoningData.duplicatesSkipped > 0 ? `
                    <div class="reasoning-item">
                        <span class="reasoning-label">Duplikate übersprungen:</span>
                        <span class="reasoning-value" style="color: #9ca3af;">${aiReasoningData.duplicatesSkipped}</span>
                    </div>
                    ` : ''}
                    ${aiReasoningData.chartCountNote ? `
                    <div class="reasoning-item" style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-radius: 4px;">
                        <span class="reasoning-value" style="color: #0369a1; font-size: 12px;">
                            ℹ️ ${aiReasoningData.chartCountNote}
                        </span>
                    </div>
                    ` : ''}
                </div>
            `;

            // 5. VERWENDETE TEMPLATES - Welche Layouts wurden angewendet
            if (aiReasoningData.selectedTemplates.length > 0) {
                // Ermittle welche Templates tatsächlich zu Charts führten
                // Normalisiere IDs: "WF-01" und "WF01" sollen matchen
                const normalizeId = (id) => id ? id.toUpperCase().replace(/-/g, '') : '';

                const usedTemplateIds = new Set(
                    aiReasoningData.chartConfigs
                        .map(c => normalizeId(c._layoutId || c.layoutId))
                        .filter(id => id)
                );

                // Debug-Log
                console.log('Template-Matching Debug:', {
                    chartLayoutIds: aiReasoningData.chartConfigs.map(c => c._layoutId || c.layoutId),
                    normalizedChartIds: [...usedTemplateIds],
                    templateIds: aiReasoningData.selectedTemplates.map(t => t.template_id)
                });

                html += `
                    <div class="reasoning-section">
                        <div class="reasoning-section-title">Verwendete Templates</div>
                        ${aiReasoningData.selectedTemplates.map((t, i) => {
                            const templateId = t.template_id || '';
                            const isUsed = usedTemplateIds.has(normalizeId(templateId));
                            const itemStyle = isUsed
                                ? 'border: 2px solid #22c55e; border-radius: 6px; padding: 6px 10px; background: #f0fdf4;'
                                : 'padding: 6px 10px; opacity: 0.6;';
                            const statusIcon = isUsed ? '✓' : '○';
                            const statusColor = isUsed ? '#15803d' : '#9ca3af';
                            return `
                            <div class="reasoning-item" style="${itemStyle}">
                                <span style="color: ${statusColor}; margin-right: 6px;">${statusIcon}</span>
                                <span class="reasoning-label">${templateId || 'Unbekannt'}:</span>
                                <span class="reasoning-value">${t.name || ''} (${t.chart_type || 'Unbekannt'})</span>
                            </div>
                        `}).join('')}
                    </div>
                `;
            }

            // 6. GENERIERTE CHARTS - Übersicht der erstellten Visualisierungen
            if (aiReasoningData.chartConfigs.length > 0) {
                const templateReasons = reasoning.templateReasons || [];

                html += `
                    <div class="reasoning-section">
                        <div class="reasoning-section-title">Generierte Charts (${aiReasoningData.chartConfigs.length})</div>
                        ${aiReasoningData.chartConfigs.map((c, i) => {
                            const reasonObj = templateReasons[i] || {};
                            const reasonText = reasonObj.reason || c._rankingReason || '';
                            // Ersetze "Beispiel" durch "Chart" im Titel
                            const cleanTitle = (c.title || 'Ohne Titel').replace(/Beispiel/g, 'Chart');
                            return `
                            <div class="reasoning-item reasoning-chart-item">
                                <span class="reasoning-chart-title">${i + 1}. ${cleanTitle}${reasonText ? ' - ' + reasonText : ''}</span>
                            </div>
                        `}).join('')}
                    </div>
                `;
            }

            // 7. GELADENE PROMPTS - Technische Details zur KI-Generierung
            if (PromptLoader.loadedPrompts && PromptLoader.loadedPrompts.length > 0) {
                const totalTokens = PromptLoader.loadedPrompts.reduce((sum, p) => sum + p.tokens, 0);
                const totalSize = PromptLoader.loadedPrompts.reduce((sum, p) => sum + p.size, 0);
                const totalRawSize = PromptLoader.loadedPrompts.reduce((sum, p) => sum + (p.rawSize || p.size), 0);
                const reduction = totalRawSize > totalSize ? Math.round((1 - totalSize/totalRawSize) * 100) : 0;

                html += `
                    <div class="reasoning-section" style="background: #f0fdf4; border-left: 3px solid #22c55e;">
                        <div class="reasoning-section-title" style="color: #15803d;">
                            Geladene Prompts (${PromptLoader.loadedPrompts.length})
                        </div>
                        ${PromptLoader.loadedPrompts.map(p => {
                            const wasExtracted = p.rawSize && p.rawSize !== p.size;
                            const reductionPct = wasExtracted ? Math.round((1 - p.size/p.rawSize) * 100) : 0;
                            return `
                            <div class="reasoning-item">
                                <span class="reasoning-label">${p.name}:</span>
                                <span class="reasoning-value">
                                    ${p.file}
                                    <span style="color: #6b7280; font-size: 11px;">
                                        (${(p.size / 1024).toFixed(1)} KB, ~${p.tokens.toLocaleString('de-DE')} Tokens${wasExtracted ? `, -${reductionPct}%` : ''})
                                    </span>
                                </span>
                            </div>
                        `}).join('')}
                        <div class="reasoning-item" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #d1fae5;">
                            <span class="reasoning-label">Gesamt:</span>
                            <span class="reasoning-value" style="font-weight: 600; color: ${totalTokens > 20000 ? '#dc2626' : '#15803d'};">
                                ${(totalSize / 1024).toFixed(1)} KB, ~${totalTokens.toLocaleString('de-DE')} Tokens
                                ${reduction > 0 ? ` (${reduction}% reduziert durch Extraktion)` : ''}
                                ${totalTokens > 20000 ? ' ⚠️ Überschreitet Rate-Limit!' : ''}
                            </span>
                        </div>
                    </div>
                `;
            }

            // 8. Fehler anzeigen (wenn vorhanden)
            if (aiReasoningData.errors && aiReasoningData.errors.length > 0) {
                html += `
                    <div class="reasoning-section" style="background: #fef2f2; border-left: 3px solid #ef4444;">
                        <div class="reasoning-section-title" style="color: #dc2626;">Fehler bei KI-Generierung</div>
                        ${aiReasoningData.errors.map(err => `
                            <div class="reasoning-item">
                                <span class="reasoning-label">${err.phase}${err.template ? ' (' + err.template + ')' : ''}:</span>
                                <span class="reasoning-value" style="color: #dc2626;">${err.error}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Timestamp
            if (aiReasoningData.timestamp) {
                html += `
                    <div class="reasoning-timestamp">
                        Generiert: ${new Date(aiReasoningData.timestamp).toLocaleString('de-DE')}
                    </div>
                `;
            }

            content.innerHTML = html;
        }

        // =====================================================
        // RENDERING
        // =====================================================

        function renderAllCharts() {
            const wrapper = document.getElementById('charts-wrapper');
            const selectedChartType = analysisResult?.parsed?.recommendation?.selectedChart ||
                              analysisResult?.parsed?.recommendation?.primaryChart || 'waterfall';

            // Alle Charts rendern (kein Limit mehr)
            let configsToRender = [...chartConfigs];

            // Hilfsfunktion: Bestimme den Chart-Typ einer Config
            function detectChartType(config) {
                // Prüfe ob ein expliziter Typ gesetzt wurde (z.B. durch KI-Generierung)
                if (config._chartType) {
                    // Normalisiere den Typ (stacked_bar -> stacked-bar)
                    return config._chartType.replace('_', '-');
                }
                if (config.chartType) return config.chartType;

                // Ansonsten anhand der Struktur erkennen
                if (config.bars && Array.isArray(config.bars)) return 'waterfall';
                if (config.periods && Array.isArray(config.periods)) return 'bar';
                if (config.categories && Array.isArray(config.categories)) return 'stacked-bar';

                console.warn('detectChartType: Konnte Typ nicht erkennen, verwende waterfall als Fallback', config);
                return 'waterfall'; // Fallback
            }

            // Validiere Configs - entferne ungültige
            configsToRender = configsToRender.filter(config => {
                if (!config) return false;
                const configType = detectChartType(config);
                console.log(`=== VALIDIERE CONFIG ===`);
                console.log(`Typ: ${configType}, Titel: "${config.title || 'KEIN TITEL'}"`);
                console.log(`Vorhande Felder:`, Object.keys(config));

                if (configType === 'waterfall') {
                    if (!config.bars || !Array.isArray(config.bars) || config.bars.length === 0) {
                        console.warn('❌ Ungültige Waterfall-Config (keine bars):', config);
                        return false;
                    }
                    console.log(`✅ Waterfall-Config gültig: ${config.bars.length} bars`);
                }

                if (configType === 'bar') {
                    // Bar-Charts brauchen BEIDE: periods UND categories mit values
                    const hasPeriods = config.periods && Array.isArray(config.periods) && config.periods.length > 0;
                    const hasCategories = config.categories && Array.isArray(config.categories) && config.categories.length > 0;
                    const hasValues = hasCategories && config.categories.every(c => c.values && Array.isArray(c.values) && c.values.length > 0);

                    console.log(`Bar-Config Check: periods=${hasPeriods}, categories=${hasCategories}, values=${hasValues}`);

                    if (!hasPeriods || !hasCategories) {
                        console.warn('❌ Ungültige Bar-Config:');
                        console.warn('  - periods:', config.periods);
                        console.warn('  - categories:', config.categories);
                        return false;
                    }
                    if (!hasValues) {
                        console.warn('❌ Bar-Config categories ohne values Array!');
                        return false;
                    }
                    console.log(`✅ Bar-Config gültig: ${config.periods.length} periods, ${config.categories.length} categories`);
                }

                if (configType === 'stacked-bar') {
                    // Stacked-Bar braucht categories UND segments mit values
                    const hasCategories = config.categories && Array.isArray(config.categories) && config.categories.length > 0;
                    const hasSegments = config.segments && Array.isArray(config.segments) && config.segments.length > 0;
                    const hasValues = hasSegments && config.segments.every(s => s.values && Array.isArray(s.values) && s.values.length > 0);

                    console.log(`Stacked-Bar Check: categories=${hasCategories}, segments=${hasSegments}, values=${hasValues}`);

                    if (!hasCategories || !hasSegments) {
                        console.warn('❌ Ungültige Stacked-Bar-Config:');
                        console.warn('  - categories:', config.categories);
                        console.warn('  - segments:', config.segments);
                        return false;
                    }
                    if (!hasValues) {
                        console.warn('❌ Stacked-Bar segments ohne values Array!');
                        return false;
                    }
                    console.log(`✅ Stacked-Bar gültig: ${config.categories.length} categories, ${config.segments.length} segments`);
                }

                console.log(`=== END VALIDIERE ===`);
                return true;
            });

            // Falls nach Validierung keine Configs übrig, verwende Demo-Daten
            if (configsToRender.length === 0) {
                console.log('Keine gültigen Configs - Fallback zu Demo-Daten');
                generateChartVariants(selectedChartType);
                configsToRender = [...chartConfigs];
            }

            // Initialisiere selectedChartsForExport mit allen Charts (standardmäßig ausgewählt)
            selectedChartsForExport.clear();
            configsToRender.forEach((_, index) => selectedChartsForExport.add(index));

            // Zeige Selection-Bar
            const selectionBar = document.getElementById('selectionBar');
            if (selectionBar) {
                selectionBar.style.display = 'flex';
                document.getElementById('totalCharts').textContent = configsToRender.length;
                updateSelectionCount();
            }

            wrapper.innerHTML = configsToRender.map((config, index) => `
                <div class="chart-wrapper">
                    <div class="chart-select-row">
                        <input type="checkbox" id="chartSelect${index}" ${selectedChartsForExport.has(index) ? 'checked' : ''} onchange="toggleChartSelection(${index})">
                        <label for="chartSelect${index}">Für Export auswählen</label>
                    </div>
                    <div class="chart-container ${selectedChartsForExport.has(index) ? 'selected' : ''}" id="chartContainer${index}">
                        <div class="chart-header">
                            <div class="chart-info">
                                <div class="chart-title">${config.title || `Beispiel ${index + 1}`}</div>
                                <div class="chart-subtitle">${config.subtitle || ''}</div>
                            </div>
                            <div class="chart-actions">
                                <button class="btn-download btn-pptx" onclick="downloadPPTX(${index})" title="PowerPoint Export">PPTX</button>
                                <button class="btn-download" onclick="downloadPNGHD(${index})" title="PNG in 4K Auflösung">PNG HD</button>
                                <button class="btn-download" onclick="downloadSVG(${index})" title="Vektor-Grafik">SVG</button>
                                <button class="btn-download" onclick="downloadPNG(${index})" title="Standard PNG">PNG</button>
                                <button class="btn-download" onclick="downloadHTML(${index})" title="Standalone HTML">HTML</button>
                            </div>
                        </div>
                        <svg id="chart${index}" viewBox="0 0 1200 500"></svg>
                    </div>
                </div>
            `).join('');

            // Rendere jeden Chart basierend auf dem gewählten Typ
            configsToRender.forEach((config, index) => {
                const chartType = selectedChartType.replace('_', '-');
                switch (chartType) {
                    case 'waterfall':
                        renderWaterfallChart(`chart${index}`, config);
                        break;
                    case 'bar':
                        renderBarChart(`chart${index}`, config);
                        break;
                    case 'stacked-bar':
                        renderStackedBarChart(`chart${index}`, config);
                        break;
                    default:
                        renderWaterfallChart(`chart${index}`, config);
                }
            });
        }

        // Chart-Auswahl Funktionen
        function toggleChartSelection(index) {
            if (selectedChartsForExport.has(index)) {
                selectedChartsForExport.delete(index);
            } else {
                selectedChartsForExport.add(index);
            }
            updateChartContainerStyle(index);
            updateSelectionCount();
        }

        function updateChartContainerStyle(index) {
            const container = document.getElementById(`chartContainer${index}`);
            if (container) {
                if (selectedChartsForExport.has(index)) {
                    container.classList.add('selected');
                } else {
                    container.classList.remove('selected');
                }
            }
        }

        function updateSelectionCount() {
            const countElement = document.getElementById('selectionCount');
            if (countElement) {
                countElement.textContent = selectedChartsForExport.size;
            }
        }

        function toggleAllCharts() {
            const checkboxes = document.querySelectorAll('[id^="chartSelect"]');
            checkboxes.forEach((cb, index) => {
                selectedChartsForExport.add(index);
                cb.checked = true;
                updateChartContainerStyle(index);
            });
            updateSelectionCount();
        }

        function deselectAllCharts() {
            const checkboxes = document.querySelectorAll('[id^="chartSelect"]');
            checkboxes.forEach((cb, index) => {
                selectedChartsForExport.delete(index);
                cb.checked = false;
                updateChartContainerStyle(index);
            });
            updateSelectionCount();
        }

        // =====================================================
        // WATERFALL CHART RENDERING
        // =====================================================

        function renderWaterfallChart(svgId, config) {
            const svg = document.getElementById(svgId);

            // Validierung: config und config.bars müssen existieren
            if (!config || !config.bars || !Array.isArray(config.bars) || config.bars.length === 0) {
                console.error('renderWaterfallChart: Ungültige config oder keine bars vorhanden', config);
                if (svg) {
                    svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#666" font-size="14">Keine Daten für Waterfall-Chart verfügbar</text>`;
                }
                return;
            }

            const colors = config.colors || DEFAULT_COLORS.waterfall;

            const width = 1200;  // Breitformat für Charts
            const height = 500;  // Kompaktere Höhe für Charts
            const margin = { top: 80, right: 40, bottom: 80, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const numBars = config.bars.length;

            // WICHTIG: FESTE Balkenbreite für Konsistenz zwischen allen Charts!
            const barWidth = 50;  // Feste Breite in Pixel - NICHT dynamisch berechnen!
            const minBarGap = 15;

            // Lücke zwischen Balken: gleichmäßig verteilt, aber mindestens minBarGap
            const barGap = Math.max(minBarGap, (chartWidth - numBars * barWidth) / (numBars + 1));

            function getBarX(index) {
                return margin.left + barGap + index * (barWidth + barGap);
            }

            // Kumulative Werte berechnen
            let cumulative = 0;
            const barData = [];

            config.bars.forEach((bar) => {
                // Sicherheitsprüfung: value als Zahl erzwingen
                const barValue = typeof bar.value === 'string' ? parseFloat(bar.value) : (bar.value || 0);

                if (bar.type === 'start') {
                    cumulative = barValue;
                    barData.push({ ...bar, cumulative: barValue, startY: 0, value: barValue });
                } else if (bar.type === 'increase') {
                    const startY = cumulative;
                    cumulative += barValue;
                    barData.push({ ...bar, cumulative, startY, value: barValue });
                } else if (bar.type === 'decrease') {
                    const startY = cumulative;
                    cumulative += barValue;
                    barData.push({ ...bar, cumulative, startY, value: barValue });
                } else if (bar.type === 'end') {
                    // Sicherheitsprüfung: value als Zahl erzwingen
                    let endValue;
                    if (bar.value !== undefined && bar.value !== null) {
                        endValue = typeof bar.value === 'string' ? parseFloat(bar.value) : bar.value;
                    } else {
                        endValue = cumulative;  // Automatisch berechnen
                    }
                    if (isNaN(endValue)) endValue = cumulative;
                    cumulative = endValue;
                    barData.push({ ...bar, cumulative: endValue, startY: 0, value: endValue });
                } else if (bar.type === 'compare') {
                    barData.push({ ...bar, cumulative: bar.value, startY: 0 });
                }
            });

            // Y-Skala berechnen
            const allValues = [];
            barData.forEach(bar => {
                if (bar.type === 'start' || bar.type === 'end' || bar.type === 'compare') {
                    allValues.push(bar.cumulative);
                    allValues.push(0);
                } else {
                    allValues.push(bar.startY);
                    allValues.push(bar.cumulative);
                }
            });

            const maxValue = Math.max(...allValues) * 1.2;
            const minValue = Math.min(0, ...allValues);

            function yScale(value) {
                return margin.top + chartHeight - ((value - minValue) / (maxValue - minValue)) * chartHeight;
            }

            const baselineY = yScale(0);

            let svgContent = '';

            // Achsenlinie
            svgContent += `<line x1="${margin.left}" y1="${baselineY}" x2="${width - margin.right}" y2="${baselineY}" stroke="#ccc" stroke-width="1"/>`;

            // Connector-Linien ZUERST
            barData.forEach((bar, index) => {
                if (index < barData.length - 1) {
                    const nextBar = barData[index + 1];
                    if (nextBar.type === 'compare') return;

                    let connectorY;
                    if (bar.type === 'start' || bar.type === 'end') {
                        connectorY = yScale(bar.cumulative);
                    } else if (bar.type === 'increase' || bar.type === 'decrease') {
                        connectorY = yScale(bar.cumulative);
                    }

                    if (connectorY !== undefined) {
                        const fromX = getBarX(index) + barWidth;
                        const toX = getBarX(index + 1);
                        svgContent += `<line class="connector-line" x1="${fromX}" y1="${connectorY}" x2="${toX}" y2="${connectorY}" stroke="${colors.connector}" stroke-dasharray="4,3"/>`;
                    }
                }
            });

            // Balken zeichnen
            barData.forEach((bar, index) => {
                const barX = getBarX(index);
                let barY, barHeight, fillColor;

                if (bar.type === 'start') {
                    // Start-Balken: von 0 bis zum Wert (kann auch negativ sein)
                    if (bar.cumulative >= 0) {
                        barY = yScale(bar.cumulative);
                        barHeight = baselineY - barY;
                    } else {
                        barY = baselineY;
                        barHeight = yScale(bar.cumulative) - baselineY;
                    }
                    fillColor = colors.start;
                } else if (bar.type === 'end') {
                    // End-Balken: von 0 bis zum Wert (kann auch negativ sein!)
                    if (bar.cumulative >= 0) {
                        barY = yScale(bar.cumulative);
                        barHeight = baselineY - barY;
                    } else {
                        // NEGATIVER END-WERT: Balken geht unter die Nulllinie
                        barY = baselineY;
                        barHeight = yScale(bar.cumulative) - baselineY;
                    }
                    fillColor = colors.end;
                } else if (bar.type === 'compare') {
                    // Compare-Balken: von 0 bis zum Wert
                    if (bar.cumulative >= 0) {
                        barY = yScale(bar.cumulative);
                        barHeight = baselineY - barY;
                    } else {
                        barY = baselineY;
                        barHeight = yScale(bar.cumulative) - baselineY;
                    }
                    fillColor = colors.compare;
                } else if (bar.type === 'increase') {
                    barY = yScale(bar.cumulative);
                    barHeight = yScale(bar.startY) - barY;
                    fillColor = colors.positive;
                } else if (bar.type === 'decrease') {
                    barY = yScale(bar.startY);
                    barHeight = yScale(bar.cumulative) - barY;
                    fillColor = colors.negative;
                }

                // Prüfe ob Skalenbruch für diesen Balken nötig ist
                const needsScaleBreak = config.scaleBreak && config.scaleBreak.enabled &&
                    (config.scaleBreak.barIndex === index ||
                     (bar.type === 'increase' || bar.type === 'decrease') && Math.abs(bar.value) > maxValue * 0.4);

                // Balken (behandle sowohl \n als auch \\n in Labels)
                const cleanLabel = (bar.label || '').replace(/\\n/g, '\n').replace(/\n/g, ' ');

                if (needsScaleBreak && barHeight > 60) {
                    // SKALENBRUCH: Balken in zwei Teile mit Zickzack in der Mitte
                    const breakY = barY + barHeight * 0.4;  // Bruch bei 40% von oben
                    const breakGap = 16;
                    const zigzagAmplitude = 4;

                    // Oberer Teil
                    svgContent += `<rect class="bar" x="${barX}" y="${barY}" width="${barWidth}" height="${breakY - barY - breakGap/2}" fill="${fillColor}" rx="2"/>`;

                    // Unterer Teil
                    svgContent += `<rect class="bar" x="${barX}" y="${breakY + breakGap/2}" width="${barWidth}" height="${barY + barHeight - breakY - breakGap/2}" fill="${fillColor}" rx="2"/>`;

                    // Zickzack-Linien (weiß hinterlegt)
                    const segW = barWidth / 3;
                    const zigzagPath1 = 'M ' + barX + ' ' + (breakY - breakGap/2 + 2) + ' L ' + (barX + segW) + ' ' + (breakY - breakGap/2 + 2 - zigzagAmplitude) + ' L ' + (barX + 2*segW) + ' ' + (breakY - breakGap/2 + 2 + zigzagAmplitude) + ' L ' + (barX + barWidth) + ' ' + (breakY - breakGap/2 + 2);
                    const zigzagPath2 = 'M ' + barX + ' ' + (breakY + breakGap/2 - 2) + ' L ' + (barX + segW) + ' ' + (breakY + breakGap/2 - 2 - zigzagAmplitude) + ' L ' + (barX + 2*segW) + ' ' + (breakY + breakGap/2 - 2 + zigzagAmplitude) + ' L ' + (barX + barWidth) + ' ' + (breakY + breakGap/2 - 2);

                    svgContent += '<rect x="' + (barX - 2) + '" y="' + (breakY - breakGap/2 - 2) + '" width="' + (barWidth + 4) + '" height="' + (breakGap + 4) + '" fill="white"/>';
                    svgContent += '<path d="' + zigzagPath1 + '" stroke="#666" stroke-width="1.5" fill="none"/>';
                    svgContent += '<path d="' + zigzagPath2 + '" stroke="#666" stroke-width="1.5" fill="none"/>';
                } else {
                    // Normaler Balken
                    svgContent += `<rect class="bar" x="${barX}" y="${barY}" width="${barWidth}" height="${barHeight}" fill="${fillColor}" rx="2" data-value="${bar.value}" data-label="${cleanLabel}"/>`;
                }

                // Wert-Label
                const minHeightForInsideLabel = 25;
                const barCenterX = barX + barWidth / 2;

                if ((bar.type === 'increase' || bar.type === 'decrease') && barHeight >= minHeightForInsideLabel) {
                    // Label IM Balken (für große Increase/Decrease-Balken)
                    const labelY = barY + barHeight / 2;
                    svgContent += `<text class="value-label-inside" x="${barCenterX}" y="${labelY}">${bar.displayValue}</text>`;
                } else if ((bar.type === 'start' || bar.type === 'end' || bar.type === 'compare') && bar.cumulative < 0) {
                    // NEGATIVER Start/End/Compare-Balken: Label ÜBER der Nulllinie (nicht unter dem Balken!)
                    // So vermeiden wir Überlappung mit X-Achsen-Labels
                    svgContent += `<text class="value-label" x="${barCenterX}" y="${baselineY - 8}" fill="#1a1a1a">${bar.displayValue}</text>`;
                } else {
                    // POSITIVES Wert-Label: ÜBER dem Balken
                    svgContent += `<text class="value-label" x="${barCenterX}" y="${barY - 8}" fill="#1a1a1a">${bar.displayValue}</text>`;
                }

                // X-Achsen-Label (behandle sowohl \n als auch \\n aus API-Antworten)
                const labelStr = (bar.label || '').replace(/\\n/g, '\n');
                const lines = labelStr.split('\n');
                let labelText = `<text class="axis-label" x="${barCenterX}" y="${baselineY + 20}" fill="#333">`;
                lines.forEach((line, i) => {
                    labelText += `<tspan x="${barCenterX}" dy="${i === 0 ? 0 : 14}">${line}</tspan>`;
                });
                labelText += '</text>';
                svgContent += labelText;
            });

            // Bracket-Annotation
            if (config.bracket && config.bracket.show) {
                const startBar = barData[config.bracket.fromIndex];
                const endBar = barData[config.bracket.toIndex];

                if (startBar && endBar) {
                    const startX = getBarX(config.bracket.fromIndex) + barWidth / 2;
                    const endX = getBarX(config.bracket.toIndex) + barWidth / 2;
                    const centerX = (startX + endX) / 2;

                    // KRITISCH: Finde den HÖCHSTEN Punkt (niedrigster Y-Wert) aller Balken
                    // zwischen Start und End, damit das Bracket darüber liegt!
                    let highestBarY = Infinity;
                    for (let i = config.bracket.fromIndex; i <= config.bracket.toIndex; i++) {
                        const bar = barData[i];
                        let barTopY;

                        if (bar.type === 'start' || bar.type === 'end' || bar.type === 'compare') {
                            barTopY = yScale(bar.cumulative);
                        } else if (bar.type === 'increase') {
                            barTopY = yScale(bar.cumulative);  // Oberkante nach Erhöhung
                        } else if (bar.type === 'decrease') {
                            barTopY = yScale(bar.startY);  // Oberkante ist der Start-Wert
                        }

                        if (barTopY < highestBarY) {
                            highestBarY = barTopY;
                        }
                    }

                    // Sicherer Abstand: Bracket über dem höchsten Balken + Label-Höhe + Puffer
                    // WICHTIG: Genug Abstand, damit keine Überlappung mit Wert-Labels UND Category-Brackets!
                    const valueLabelHeight = 25;  // Höhe des Wert-Labels
                    let bracketGap = 30;          // Mindestabstand zwischen Elementen

                    // WENN Category-Brackets vorhanden sind, brauchen wir MEHR Platz!
                    // Category-Brackets nehmen ca. 45px ein (Bubble 16px + Description 10px + Abstände)
                    if (config.categoryBrackets && config.categoryBrackets.length > 0) {
                        bracketGap = 75;  // Viel mehr Platz für Category-Brackets
                    }

                    // Bracket-Y ist über dem höchsten Punkt mit ausreichend Abstand
                    const bracketY = Math.min(
                        highestBarY - valueLabelHeight - bracketGap - 20,
                        margin.top + 10  // Nicht zu weit oben
                    );

                    // Vertikale Linien starten von der Bracket-Höhe
                    // und enden OBERHALB der Wert-Labels (mit Sicherheitsabstand)
                    const startBarY = yScale(startBar.cumulative);
                    const endBarY = yScale(endBar.cumulative);

                    // Prüfe ob am Start- oder End-Balken ein Category-Bracket ist
                    // NUR dann größeren Offset verwenden, sonst direkt über dem Wert-Label enden
                    const hasStartCategoryBracket = config.categoryBrackets?.some(cb => cb.barIndex === config.bracket.fromIndex);
                    const hasEndCategoryBracket = config.categoryBrackets?.some(cb => cb.barIndex === config.bracket.toIndex);

                    // Offset nur dort erhöhen, wo tatsächlich ein Category-Bracket ist
                    const startCategoryOffset = hasStartCategoryBracket ? 50 : 12;
                    const endCategoryOffset = hasEndCategoryBracket ? 50 : 12;

                    // Start-Linie endet oberhalb des Wert-Labels (oder Category-Brackets wenn vorhanden)
                    const startLabelY = startBarY - valueLabelHeight - startCategoryOffset;
                    // End-Pfeil endet oberhalb des Wert-Labels (oder Category-Brackets wenn vorhanden)
                    const endLabelY = endBarY - valueLabelHeight - endCategoryOffset;

                    const bubbleWidth = 90;  // Breiter für längere Labels
                    const bubbleHeight = 24;

                    // Linke vertikale Linie
                    svgContent += `<line class="bracket-line" x1="${startX}" y1="${startLabelY}" x2="${startX}" y2="${bracketY}" stroke="${colors.connector}"/>`;

                    // Horizontale gestrichelte Linie links
                    svgContent += `<line class="bracket-line-dashed" x1="${startX}" y1="${bracketY}" x2="${centerX - bubbleWidth/2 - 5}" y2="${bracketY}" stroke="${colors.connector}" stroke-dasharray="4,3"/>`;

                    // Bubble
                    svgContent += `<ellipse class="bracket-bubble" cx="${centerX}" cy="${bracketY}" rx="${bubbleWidth/2}" ry="${bubbleHeight/2}" stroke="${colors.connector}" fill="white"/>`;
                    svgContent += `<text class="bracket-label" x="${centerX}" y="${bracketY + 1}" fill="#1a1a1a">${config.bracket.label}</text>`;

                    // Horizontale gestrichelte Linie rechts
                    svgContent += `<line class="bracket-line-dashed" x1="${centerX + bubbleWidth/2 + 5}" y1="${bracketY}" x2="${endX}" y2="${bracketY}" stroke="${colors.connector}" stroke-dasharray="4,3"/>`;

                    // Rechte vertikale Linie + Pfeil
                    // WICHTIG: Pfeilspitze endet OBERHALB des Wert-Labels!
                    const arrowTipY = endLabelY;
                    svgContent += `<line class="bracket-line" x1="${endX}" y1="${bracketY}" x2="${endX}" y2="${arrowTipY + 8}" stroke="${colors.connector}"/>`;
                    svgContent += `<polygon class="arrow-head" points="${endX},${arrowTipY} ${endX-5},${arrowTipY - 8} ${endX+5},${arrowTipY - 8}" fill="${colors.connector}"/>`;
                }
            }

            // =====================================================
            // CATEGORY-BRACKETS: Prozentuale Anteile über einzelnen Balken
            // Zeigt z.B.: "62,3% der Gesamtkosten" oder "51,2% vom Umsatz"
            // Darstellung: Beschreibung + Bubble DIREKT über dem Wert-Label
            // WICHTIG: Muss UNTER dem Haupt-Bracket bleiben (wenn vorhanden)!
            // =====================================================
            if (config.categoryBrackets && config.categoryBrackets.length > 0) {
                // Bubble-Größe (einheitlich für alle)
                const catBubbleHeight = 16;

                config.categoryBrackets.forEach((cb) => {
                    const bar = barData[cb.barIndex];
                    if (bar) {
                        const barX = getBarX(cb.barIndex);
                        const barCenterX = barX + barWidth / 2;

                        // Position: oberhalb des Balkens
                        let barTopY;
                        if (bar.type === 'start' || bar.type === 'end' || bar.type === 'compare') {
                            barTopY = yScale(bar.cumulative);
                        } else if (bar.type === 'increase') {
                            barTopY = yScale(bar.cumulative);
                        } else if (bar.type === 'decrease') {
                            barTopY = yScale(bar.startY);
                        }

                        // Wert-Label ist ca. 8px über Balkenkante
                        // Category-Bracket kommt DIREKT über dem Wert-Label
                        // Layout von unten nach oben:
                        // 1. Balkenkante (barTopY)
                        // 2. Wert-Label (barTopY - 8)
                        // 3. Category-Bubble (barTopY - 8 - 18 = barTopY - 26)
                        // 4. Description Text (barTopY - 26 - 8 - 5 = barTopY - 39)

                        const valueLabelY = barTopY - 8;  // Wert-Label Position
                        const bubbleY = valueLabelY - 18 - catBubbleHeight/2;  // Bubble über Wert-Label

                        // Bubble-Größe dynamisch basierend auf Label-Länge
                        const labelText = cb.label || '';
                        const bubbleWidth = Math.max(40, labelText.length * 7 + 14);

                        // Beschreibung ÜBER der Bubble (wenn vorhanden)
                        if (cb.description) {
                            svgContent += `<text class="category-bracket-desc" x="${barCenterX}" y="${bubbleY - catBubbleHeight/2 - 3}"
                                text-anchor="middle" font-size="9" fill="#666">${cb.description}</text>`;
                        }

                        // Runde Bubble
                        svgContent += `<ellipse class="category-bracket-bubble"
                            cx="${barCenterX}" cy="${bubbleY}"
                            rx="${bubbleWidth/2}" ry="${catBubbleHeight/2}"
                            stroke="#666" stroke-width="1" fill="white"/>`;

                        // Label in der Bubble (zentriert)
                        svgContent += `<text class="category-bracket-label" x="${barCenterX}" y="${bubbleY + 1}"
                            text-anchor="middle" dominant-baseline="middle" font-size="10" font-weight="600" fill="#333">${cb.label}</text>`;
                    }
                });
            }

            // =====================================================
            // COMPARE-BRACKETS: Prozentuale Abweichungen zwischen End/Compare-Balken
            // Zeigt z.B.: "FC vs. BUD: +5,3%", "FC vs. VJ: +38,2%"
            // =====================================================
            if (config.compareBrackets && config.compareBrackets.length > 0) {
                // Basis-Y-Position: unterhalb der X-Achsen-Labels
                const compareBracketBaseY = baselineY + 60;
                const compareBracketSpacing = 25;  // Abstand zwischen mehreren Brackets

                config.compareBrackets.forEach((cb, cbIndex) => {
                    const fromBar = barData[cb.fromIndex];
                    const toBar = barData[cb.toIndex];

                    if (fromBar && toBar) {
                        const fromX = getBarX(cb.fromIndex) + barWidth / 2;
                        const toX = getBarX(cb.toIndex) + barWidth / 2;
                        const centerX = (fromX + toX) / 2;
                        const bracketY = compareBracketBaseY + cbIndex * compareBracketSpacing;

                        // Gestrichelte Linie zwischen den Balken
                        svgContent += `<line class="compare-bracket-line" x1="${fromX}" y1="${bracketY}" x2="${toX}" y2="${bracketY}" stroke="#666" stroke-width="1" stroke-dasharray="3,2"/>`;

                        // Kleine vertikale Striche an den Enden
                        svgContent += `<line x1="${fromX}" y1="${bracketY - 4}" x2="${fromX}" y2="${bracketY + 4}" stroke="#666" stroke-width="1"/>`;
                        svgContent += `<line x1="${toX}" y1="${bracketY - 4}" x2="${toX}" y2="${bracketY + 4}" stroke="#666" stroke-width="1"/>`;

                        // Label in der Mitte (mit weißem Hintergrund für Lesbarkeit)
                        const labelText = cb.description ? `${cb.label}` : cb.label;
                        const labelWidth = Math.max(50, labelText.length * 7);

                        // Weißer Hintergrund für das Label
                        svgContent += `<rect x="${centerX - labelWidth/2 - 4}" y="${bracketY - 8}" width="${labelWidth + 8}" height="16" fill="white" rx="2"/>`;

                        // Label-Text
                        svgContent += `<text class="compare-bracket-label" x="${centerX}" y="${bracketY + 4}" text-anchor="middle" font-size="11" font-weight="500" fill="#333">${labelText}</text>`;

                        // Optional: Beschreibung unter dem Label
                        if (cb.description) {
                            svgContent += `<text class="compare-bracket-desc" x="${centerX}" y="${bracketY + 16}" text-anchor="middle" font-size="9" fill="#666">${cb.description}</text>`;
                        }
                    }
                });
            }

            svg.innerHTML = svgContent;
            renderedCharts[svgId] = svgContent;

            // Tooltip
            setupTooltip(svgId);
        }

        // =====================================================
        // BAR CHART RENDERING
        // =====================================================

        // Hilfsfunktion: Automatische Farbabstufung für IST-Perioden (Grautöne)
        function applyAutoGradientColors(periods) {
            // Zähle IST-Perioden
            const istIndices = [];
            periods.forEach((p, idx) => {
                const type = (p.type || '').toUpperCase();
                if (!['PLAN', 'BUD', 'BUDGET', 'FORECAST', 'FC', 'PROJ'].includes(type)) {
                    istIndices.push(idx);
                }
            });

            // Wenn mehr als 2 IST-Perioden und keine individuelle Farbabstufung erkennbar
            if (istIndices.length >= 3) {
                const firstIstColor = periods[istIndices[0]].color;
                const allSameColor = istIndices.every(idx => periods[idx].color === firstIstColor);

                if (allSameColor) {
                    // Automatische Graustufen-Abstufung: hell → dunkel
                    const grayScale = ['#E0E0E0', '#CCCCCC', '#B0B0B0', '#999999', '#808080', '#666666', '#4D4D4D', '#333333'];

                    istIndices.forEach((periodIdx, i) => {
                        const colorIdx = Math.min(Math.floor(i / istIndices.length * grayScale.length), grayScale.length - 1);
                        periods[periodIdx].color = grayScale[colorIdx];
                    });
                }
            }

            return periods;
        }

        function renderBarChart(svgId, config) {
            const svg = document.getElementById(svgId);

            // Validierung: Prüfe ob benötigte Felder vorhanden sind
            if (!config.categories || !Array.isArray(config.categories) || config.categories.length === 0) {
                console.error('renderBarChart: Keine categories in config', config);
                if (svg) {
                    svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#666" font-size="14">Keine Daten für Bar-Chart verfügbar (fehlende categories)</text>`;
                }
                return;
            }
            if (!config.periods || !Array.isArray(config.periods) || config.periods.length === 0) {
                console.error('renderBarChart: Keine periods in config', config);
                if (svg) {
                    svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#666" font-size="14">Keine Daten für Bar-Chart verfügbar (fehlende periods)</text>`;
                }
                return;
            }

            // Automatische Farbabstufung anwenden (falls nicht bereits definiert)
            config.periods = applyAutoGradientColors(config.periods);

            const width = 1200;  // Breitformat für Charts
            const height = 500;  // Kompaktere Höhe für Charts
            const numCategories = config.categories.length;

            // Bei mehreren Kategorien: mehr Platz oben für Kategorie-Überschriften
            const margin = {
                top: numCategories > 1 ? 100 : 80,
                right: 60,
                bottom: 80,
                left: 60
            };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const numPeriods = config.periods.length;
            const groupWidth = chartWidth / numCategories;

            // WICHTIG: FESTE Balkenbreite für Konsistenz zwischen allen Charts!
            const barWidth = 35;  // Feste Breite in Pixel - NICHT dynamisch berechnen!
            const barGap = 6;     // Fester Abstand zwischen Balken einer Gruppe

            const maxValue = Math.max(...config.categories.flatMap(c => c.values));
            const scale = chartHeight / (maxValue * 1.3);

            let svgContent = '';

            config.categories.forEach((category, catIndex) => {
                const groupCenterX = margin.left + groupWidth * catIndex + groupWidth / 2;
                const totalBarsWidth = numPeriods * barWidth + (numPeriods - 1) * barGap;
                const barsStartX = groupCenterX - totalBarsWidth / 2;

                const barPositions = [];

                category.values.forEach((value, periodIndex) => {
                    const barHeight = value * scale;
                    const barX = barsStartX + periodIndex * (barWidth + barGap);
                    const barY = margin.top + chartHeight - barHeight;
                    const color = config.periods[periodIndex].color;
                    const periodType = (config.periods[periodIndex].type || '').toUpperCase();

                    // Prüfe ob Forecast/Plan/Budget → gestrichelter Rand
                    const isForecast = ['PLAN', 'BUD', 'BUDGET', 'FORECAST', 'FC', 'PROJ'].includes(periodType);

                    barPositions.push({ x: barX, y: barY, width: barWidth, height: barHeight, value });

                    if (isForecast) {
                        // Forecast-Balken: gestrichelter Rand (wie im Think-Cell Beispiel)
                        svgContent += `<rect class="bar" x="${barX}" y="${barY}" width="${barWidth}" height="${barHeight}" fill="${color}" fill-opacity="0.3" rx="2" data-category="${category.name}" data-period="${config.periods[periodIndex].label}" data-value="${value}"/>`;
                        svgContent += `<rect class="bar" x="${barX}" y="${barY}" width="${barWidth}" height="${barHeight}" fill="none" stroke="${color}" stroke-width="2" stroke-dasharray="4,2" rx="2"/>`;
                    } else {
                        // Normale Balken: solid
                        svgContent += `<rect class="bar" x="${barX}" y="${barY}" width="${barWidth}" height="${barHeight}" fill="${color}" rx="2" data-category="${category.name}" data-period="${config.periods[periodIndex].label}" data-value="${value}"/>`;
                    }

                    const labelX = barX + barWidth / 2;
                    svgContent += `<text x="${labelX}" y="${barY - 8}" class="value-label" fill="#1a1a1a">${value.toLocaleString('de-DE')}</text>`;

                    // X-Achsen-Label: Intelligent aufteilen
                    const periodLabel = config.periods[periodIndex].label;
                    const labelY = margin.top + chartHeight + 20;

                    // Versuche Jahr und Typ zu extrahieren (z.B. "2026 PLAN", "2026PLAN", "2026 BUD")
                    const yearMatch = periodLabel.match(/^(\d{4})\s*(.*)$/);

                    if (yearMatch && yearMatch[2]) {
                        // Label hat Jahr + Zusatz (z.B. "2026 PLAN" oder "2026PLAN")
                        const year = yearMatch[1];
                        const typePart = yearMatch[2].trim();

                        // Prüfe ob vorheriges Label das gleiche Jahr hat
                        const prevLabel = periodIndex > 0 ? config.periods[periodIndex - 1].label : '';
                        const prevYearMatch = prevLabel.match(/^(\d{4})/);
                        const prevYear = prevYearMatch ? prevYearMatch[1] : '';
                        const skipYear = (prevYear === year);

                        svgContent += `<text x="${labelX}" y="${labelY}" class="axis-label" fill="#666" text-anchor="middle" font-size="9">`;
                        if (skipYear) {
                            // Nur den Typ anzeigen (PLAN, BUDGET, etc.) - kein Jahr
                            svgContent += `<tspan x="${labelX}" dy="0">${typePart}</tspan>`;
                        } else {
                            // Jahr und Typ auf zwei Zeilen
                            svgContent += `<tspan x="${labelX}" dy="0">${year}</tspan>`;
                            svgContent += `<tspan x="${labelX}" dy="10">${typePart}</tspan>`;
                        }
                        svgContent += `</text>`;
                    } else {
                        // Einfaches Label ohne Jahr+Typ Struktur
                        svgContent += `<text x="${labelX}" y="${labelY}" class="axis-label" fill="#666" text-anchor="middle">${periodLabel}</text>`;
                    }
                });

                // Brackets - SELEKTIV: Nur zwischen bestimmten Balken anzeigen
                // Option 1: config.brackets[] Array mit {fromIndex, toIndex} definiert → nur diese Brackets
                // Option 2: config.showAllBrackets = true → alle Brackets (Standard: false bei > 4 Perioden)
                // Option 3: Automatik: Bei <= 4 Perioden alle, bei > 4 nur erster→letzter IST + letzter IST→erster Forecast

                let highestBracketY = margin.top;

                // Bestimme welche Brackets gezeigt werden sollen
                let bracketsToShow = [];

                if (config.brackets && Array.isArray(config.brackets)) {
                    // Explizit definierte Brackets
                    bracketsToShow = config.brackets;
                } else if (config.showAllBrackets === true || numPeriods <= 4) {
                    // Alle Brackets zeigen (bei wenigen Perioden oder explizit gewünscht)
                    for (let i = 0; i < barPositions.length - 1; i++) {
                        bracketsToShow.push({ fromIndex: i, toIndex: i + 1 });
                    }
                } else {
                    // Automatische Auswahl: Nur strategische Brackets
                    // 1. Erster → Letzter IST-Wert
                    // 2. Letzter IST → Erster Forecast (falls vorhanden)
                    const istIndices = [];
                    const forecastIndices = [];

                    config.periods.forEach((p, idx) => {
                        const type = (p.type || '').toUpperCase();
                        if (['PLAN', 'BUD', 'BUDGET', 'FORECAST', 'FC', 'PROJ'].includes(type)) {
                            forecastIndices.push(idx);
                        } else {
                            istIndices.push(idx);
                        }
                    });

                    // Bracket vom ersten zum letzten IST-Wert
                    if (istIndices.length >= 2) {
                        bracketsToShow.push({ fromIndex: istIndices[0], toIndex: istIndices[istIndices.length - 1] });
                    }

                    // Bracket vom letzten IST zum ersten Forecast
                    if (istIndices.length > 0 && forecastIndices.length > 0) {
                        bracketsToShow.push({ fromIndex: istIndices[istIndices.length - 1], toIndex: forecastIndices[0] });
                    }

                    // Falls nur Forecasts: Erster → Letzter
                    if (istIndices.length === 0 && forecastIndices.length >= 2) {
                        bracketsToShow.push({ fromIndex: forecastIndices[0], toIndex: forecastIndices[forecastIndices.length - 1] });
                    }
                }

                // Brackets rendern
                bracketsToShow.forEach(bracket => {
                    const fromIdx = bracket.fromIndex;
                    const toIdx = bracket.toIndex;

                    if (fromIdx < 0 || toIdx >= barPositions.length || fromIdx >= toIdx) return;

                    const bar1 = barPositions[fromIdx];
                    const bar2 = barPositions[toIdx];

                    const change = ((bar2.value - bar1.value) / bar1.value * 100).toFixed(0);
                    const changeText = change >= 0 ? `+${change}%` : `${change}%`;

                    const labelHeight = 15;
                    const labelGap = 8;
                    const labelTop1 = bar1.y - labelGap - labelHeight;
                    const labelTop2 = bar2.y - labelGap - labelHeight;
                    const higherLabelTop = Math.min(labelTop1, labelTop2);

                    const bubbleHeight = 18;
                    const bubbleY = higherLabelTop - 8 - bubbleHeight;
                    const bubbleCenterY = bubbleY + bubbleHeight / 2;

                    if (bubbleY < highestBracketY) {
                        highestBracketY = bubbleY;
                    }

                    const x1 = bar1.x + bar1.width / 2;
                    const x2 = bar2.x + bar2.width / 2;
                    const bubbleCenterX = (x1 + x2) / 2;

                    // Dynamische Bubble-Breite basierend auf Text
                    const bubbleWidth = Math.max(38, changeText.length * 7 + 16);

                    // Linke vertikale Linie (von Label1 zur Bubble-Höhe)
                    svgContent += `<line class="bracket-line" x1="${x1}" y1="${labelTop1}" x2="${x1}" y2="${bubbleCenterY}" stroke="#333"/>`;
                    // Horizontale Linie links zur Bubble
                    svgContent += `<line class="bracket-line" x1="${x1}" y1="${bubbleCenterY}" x2="${bubbleCenterX - bubbleWidth/2}" y2="${bubbleCenterY}" stroke="#333"/>`;
                    // Bubble
                    svgContent += `<rect class="bracket-bubble" x="${bubbleCenterX - bubbleWidth/2}" y="${bubbleY}" width="${bubbleWidth}" height="${bubbleHeight}" rx="9" stroke="#333"/>`;
                    svgContent += `<text x="${bubbleCenterX}" y="${bubbleCenterY}" class="change-label">${changeText}</text>`;
                    // Horizontale Linie rechts von Bubble
                    svgContent += `<line class="bracket-line" x1="${bubbleCenterX + bubbleWidth/2}" y1="${bubbleCenterY}" x2="${x2}" y2="${bubbleCenterY}" stroke="#333"/>`;

                    // Rechte vertikale Linie + Pfeil
                    // labelTop2 ist die Oberkante des Ziel-Labels
                    // bubbleCenterY ist die horizontale Bracket-Linie

                    // Bestimme ob Pfeil nach oben oder unten zeigt
                    const goingDown = bubbleCenterY < labelTop2;  // Bubble ist höher → Pfeil geht nach unten

                    if (goingDown) {
                        // Pfeil zeigt nach UNTEN (Bubble ist oberhalb des Ziels)
                        const lineEndY = labelTop2 - 6;
                        const arrowTipY = labelTop2 - 2;
                        svgContent += `<line class="bracket-line" x1="${x2}" y1="${bubbleCenterY}" x2="${x2}" y2="${lineEndY}" stroke="#333"/>`;
                        // Dreieck: Basis oben, Spitze unten
                        svgContent += `<polygon class="arrow-head" points="${x2-4},${lineEndY} ${x2+4},${lineEndY} ${x2},${arrowTipY}"/>`;
                    } else {
                        // Pfeil zeigt nach OBEN (Zielbalken ist höher, Label ist oberhalb der Bubble)
                        const lineEndY = labelTop2 + 6;
                        const arrowTipY = labelTop2 + 2;
                        svgContent += `<line class="bracket-line" x1="${x2}" y1="${bubbleCenterY}" x2="${x2}" y2="${lineEndY}" stroke="#333"/>`;
                        // Dreieck: Basis unten, Spitze oben
                        svgContent += `<polygon class="arrow-head" points="${x2-4},${lineEndY} ${x2+4},${lineEndY} ${x2},${arrowTipY}"/>`;
                    }
                });

                // KATEGORIE-ÜBERSCHRIFT (bei mehreren Kategorien)
                if (numCategories > 1 && category.name) {
                    // Position: OBERHALB der Brackets mit Abstand
                    const categoryTitleY = Math.min(highestBracketY - 15, margin.top - 25);

                    svgContent += `<text x="${groupCenterX}" y="${categoryTitleY}"
                        text-anchor="middle" font-weight="bold" font-size="14px" fill="#1a1a1a">${category.name}</text>`;

                    // Optional: Untertitel
                    if (category.subtitle) {
                        svgContent += `<text x="${groupCenterX}" y="${categoryTitleY + 14}"
                            text-anchor="middle" font-size="11px" fill="#666">${category.subtitle}</text>`;
                    }
                }
            });

            // Legende - NUR anzeigen wenn es unterschiedliche Typen gibt (IST, PLAN, BUD, etc.)
            // NICHT die gleichen Labels wie unter den Balken wiederholen!
            const periodTypes = [...new Set(config.periods.map(p => p.type || 'default'))];
            const hasDistinctTypes = periodTypes.length > 1 || (periodTypes.length === 1 && periodTypes[0] !== 'default');

            if (hasDistinctTypes) {
                // Gruppiere Perioden nach Typ für kompakte Legende
                const typeGroups = {};
                config.periods.forEach(period => {
                    const type = period.type || 'Werte';
                    if (!typeGroups[type]) {
                        typeGroups[type] = { color: period.color, label: type };
                    }
                });

                const legendY = height - 30;
                const legendItems = Object.values(typeGroups);
                const legendStartX = width / 2 - (legendItems.length * 90) / 2;

                legendItems.forEach((item, index) => {
                    const x = legendStartX + index * 90;
                    svgContent += `<rect x="${x}" y="${legendY}" width="16" height="16" fill="${item.color}" rx="2"/>`;
                    svgContent += `<text x="${x + 22}" y="${legendY + 12}" class="legend-text">${item.label}</text>`;
                });
            }
            // Wenn alle Perioden den gleichen Typ haben oder kein Typ definiert ist,
            // zeigen wir KEINE Legende an - die X-Achsen-Labels reichen aus!

            svg.innerHTML = svgContent;
            renderedCharts[svgId] = svgContent;
            setupTooltip(svgId);
        }

        // =====================================================
        // STACKED BAR CHART RENDERING
        // =====================================================

        function renderStackedBarChart(svgId, config) {
            const svg = document.getElementById(svgId);
            const options = config.options || {};

            // Validierung: Prüfe ob benötigte Felder vorhanden sind
            if (!config.categories || !Array.isArray(config.categories) || config.categories.length === 0) {
                console.error('renderStackedBarChart: Keine categories in config', config);
                if (svg) {
                    svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#666" font-size="14">Keine Daten für Stacked-Bar-Chart verfügbar (fehlende categories)</text>`;
                }
                return;
            }
            if (!config.segments || !Array.isArray(config.segments) || config.segments.length === 0) {
                console.error('renderStackedBarChart: Keine segments in config', config);
                if (svg) {
                    svg.innerHTML = `<text x="50%" y="50%" text-anchor="middle" fill="#666" font-size="14">Keine Daten für Stacked-Bar-Chart verfügbar (fehlende segments)</text>`;
                }
                return;
            }

            const width = 1200;
            const height = 500;
            const margin = { top: 80, right: 40, bottom: 100, left: 40 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const numCategories = config.categories.length;

            // WICHTIG: FESTE Balkenbreite für Konsistenz zwischen allen Charts!
            const barWidth = 60;  // Feste Breite in Pixel - NICHT dynamisch berechnen!
            const minBarGap = 20;

            // Lücke zwischen Balken: gleichmäßig verteilt, aber mindestens minBarGap
            const barGap = Math.max(minBarGap, (chartWidth - (numCategories * barWidth)) / (numCategories + 1));

            const categoryTotals = config.categories.map((_, catIndex) =>
                config.segments.reduce((sum, seg) => sum + seg.values[catIndex], 0)
            );
            const maxTotal = options.normalized ? 100 : Math.max(...categoryTotals);
            const chartBottom = margin.top + chartHeight;

            // Track bar positions for brackets
            const barPositions = [];

            // Generate hatch patterns for each segment color
            let defsContent = '<defs>';
            config.segments.forEach((segment, segIndex) => {
                const color = segment.color;
                defsContent += `
                    <pattern id="hatch-${svgId}-${segIndex}" patternUnits="userSpaceOnUse" width="6" height="6" patternTransform="rotate(45)">
                        <rect width="6" height="6" fill="${color}" fill-opacity="0.7"/>
                        <line x1="0" y1="0" x2="0" y2="6" stroke="white" stroke-width="1.5" stroke-opacity="0.4"/>
                    </pattern>
                `;
            });
            defsContent += '</defs>';

            let svgContent = defsContent;

            config.categories.forEach((category, catIndex) => {
                const barX = margin.left + barGap + catIndex * (barWidth + barGap);
                const barCenterX = barX + barWidth / 2;
                const categoryTotal = categoryTotals[catIndex];

                let currentY = chartBottom;
                let barTopY = chartBottom;

                // Check if this category should be hatched (historical data)
                const isHatched = category.hatched === true;

                config.segments.forEach((segment, segIndex) => {
                    const value = segment.values[catIndex];
                    const displayValue = options.normalized ? (value / categoryTotal * 100) : value;
                    const segmentHeight = (displayValue / maxTotal) * chartHeight;
                    const segmentY = currentY - segmentHeight;

                    const isTopSegment = segIndex === config.segments.length - 1;
                    const roundedCorners = isTopSegment ? 'rx="3" ry="3"' : '';

                    // Use hatched pattern for historical data, solid for current/plan
                    const fillAttr = isHatched
                        ? `fill="url(#hatch-${svgId}-${segIndex})"`
                        : `fill="${segment.color}"`;

                    svgContent += `<rect class="stacked-bar" x="${barX}" y="${segmentY}" width="${barWidth}" height="${segmentHeight}" ${fillAttr} ${roundedCorners} data-category="${catIndex}" data-segment="${segIndex}" data-value="${value}" data-segment-name="${segment.name}"/>`;

                    // Segment label inside bar (if enough space)
                    if (options.showValues && segmentHeight >= 25) {
                        const textColor = getContrastColor(segment.color);
                        const labelY = segmentY + segmentHeight / 2;
                        const displayText = options.showPercentages
                            ? `${((value / categoryTotal) * 100).toFixed(0)}%`
                            : value.toLocaleString('de-DE');

                        svgContent += `<text class="segment-label" x="${barCenterX}" y="${labelY}" fill="${textColor}">${displayText}</text>`;
                    }

                    currentY = segmentY;
                    barTopY = segmentY;
                });

                // Store bar position for brackets
                barPositions.push({
                    centerX: barCenterX,
                    topY: barTopY,
                    total: categoryTotal
                });

                // Total label above bar
                if (options.showTotals) {
                    const totalDisplay = options.normalized ? '100%' : categoryTotal.toLocaleString('de-DE');
                    svgContent += `<text class="total-label" x="${barCenterX}" y="${barTopY - 10}">${totalDisplay}</text>`;
                }

                // X-axis label (main label)
                svgContent += `<text x="${barCenterX}" y="${chartBottom + 20}" text-anchor="middle" class="axis-label" font-weight="bold" fill="#333">${category.label}</text>`;

                // X-axis sublabel (e.g., year or type indicator like "(Plan)")
                if (category.sublabel) {
                    svgContent += `<text x="${barCenterX}" y="${chartBottom + 36}" text-anchor="middle" class="axis-sublabel" font-size="10" fill="#666">${category.sublabel}</text>`;
                }
            });

            // Render brackets between bars
            if (options.showBrackets || options.brackets) {
                const bracketFormat = options.bracketFormat || 'both';
                let bracketsToRender = [];

                if (options.brackets && Array.isArray(options.brackets)) {
                    // Manual brackets
                    bracketsToRender = options.brackets;
                } else if (options.showBrackets) {
                    // Auto brackets between consecutive bars
                    for (let i = 0; i < numCategories - 1; i++) {
                        bracketsToRender.push({ fromCategory: i, toCategory: i + 1 });
                    }
                }

                bracketsToRender.forEach(bracket => {
                    const fromIdx = bracket.fromCategory;
                    const toIdx = bracket.toCategory;
                    const bar1 = barPositions[fromIdx];
                    const bar2 = barPositions[toIdx];

                    const absoluteChange = bar2.total - bar1.total;
                    const percentChange = ((absoluteChange / bar1.total) * 100).toFixed(0);

                    let changeText;
                    switch (bracketFormat) {
                        case 'absolute':
                            changeText = absoluteChange >= 0
                                ? `+${absoluteChange.toLocaleString('de-DE')}`
                                : absoluteChange.toLocaleString('de-DE');
                            break;
                        case 'percent':
                            changeText = percentChange >= 0 ? `+${percentChange}%` : `${percentChange}%`;
                            break;
                        default: // 'both'
                            const absText = absoluteChange >= 0
                                ? `+${absoluteChange.toLocaleString('de-DE')}`
                                : absoluteChange.toLocaleString('de-DE');
                            const pctText = percentChange >= 0 ? `(+${percentChange}%)` : `(${percentChange}%)`;
                            changeText = `${absText} ${pctText}`;
                    }

                    // Bracket positioning
                    const x1 = bar1.centerX;
                    const x2 = bar2.centerX;
                    const midX = (x1 + x2) / 2;

                    const totalLabelHeight = 15;
                    const totalLabelGap = 10;
                    const labelTop1 = bar1.topY - totalLabelGap - totalLabelHeight;
                    const labelTop2 = bar2.topY - totalLabelGap - totalLabelHeight;

                    const higherLabelTop = Math.min(labelTop1, labelTop2);
                    const bubbleHeight = 20;
                    const bubbleY = higherLabelTop - 12 - bubbleHeight;
                    const bubbleCenterY = bubbleY + bubbleHeight / 2;

                    const bubbleWidth = Math.max(changeText.length * 7 + 20, 60);

                    // Bubble background
                    svgContent += `<rect class="bracket-bubble" x="${midX - bubbleWidth/2}" y="${bubbleY}" width="${bubbleWidth}" height="${bubbleHeight}" rx="10" fill="white" stroke="#333" stroke-width="1.5"/>`;

                    // Bubble text
                    svgContent += `<text class="change-label" x="${midX}" y="${bubbleCenterY + 1}" text-anchor="middle" dominant-baseline="middle" font-size="10" font-weight="bold" fill="#333">${changeText}</text>`;

                    // Left horizontal line
                    svgContent += `<line class="bracket-line" x1="${x1}" y1="${bubbleCenterY}" x2="${midX - bubbleWidth/2}" y2="${bubbleCenterY}" stroke="#333" stroke-width="1.5"/>`;

                    // Right horizontal line
                    svgContent += `<line class="bracket-line" x1="${midX + bubbleWidth/2}" y1="${bubbleCenterY}" x2="${x2}" y2="${bubbleCenterY}" stroke="#333" stroke-width="1.5"/>`;

                    // Left vertical line
                    svgContent += `<line class="bracket-line" x1="${x1}" y1="${labelTop1}" x2="${x1}" y2="${bubbleCenterY}" stroke="#333" stroke-width="1.5"/>`;

                    // Right vertical line
                    svgContent += `<line class="bracket-line" x1="${x2}" y1="${bubbleCenterY}" x2="${x2}" y2="${labelTop2}" stroke="#333" stroke-width="1.5"/>`;

                    // Arrow head at bottom of right line
                    const arrowSize = 5;
                    svgContent += `<polygon class="arrow-head" points="${x2},${labelTop2} ${x2-arrowSize},${labelTop2-arrowSize*1.5} ${x2+arrowSize},${labelTop2-arrowSize*1.5}" fill="#333"/>`;
                });
            }

            // Legend
            if (options.showLegend) {
                const legendY = height - 30;
                const legendItemWidth = 120;
                const totalLegendWidth = config.segments.length * legendItemWidth;
                let legendX = (width - totalLegendWidth) / 2;

                config.segments.forEach((segment) => {
                    svgContent += `<rect x="${legendX}" y="${legendY}" width="12" height="12" fill="${segment.color}" rx="2"/>`;
                    svgContent += `<text class="legend-text" x="${legendX + 18}" y="${legendY + 10}">${segment.name}</text>`;
                    legendX += legendItemWidth;
                });
            }

            svg.innerHTML = svgContent;
            renderedCharts[svgId] = svgContent;
            setupTooltip(svgId);
        }

        // =====================================================
        // HILFSFUNKTIONEN
        // =====================================================

        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? '#333333' : '#FFFFFF';
        }

        function setupTooltip(svgId) {
            const svg = document.getElementById(svgId);
            const tooltip = document.getElementById('tooltip');

            svg.querySelectorAll('.bar, .stacked-bar, .data-point').forEach(el => {
                el.addEventListener('mouseenter', (e) => {
                    const label = e.target.dataset.label || e.target.dataset.segmentName || e.target.dataset.series || '';
                    const value = e.target.dataset.value || '';
                    tooltip.textContent = `${label}: ${value}`;
                    tooltip.classList.add('visible');
                });

                el.addEventListener('mousemove', (e) => {
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY - 10) + 'px';
                });

                el.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // =====================================================
        // DOWNLOAD-FUNKTIONEN
        // =====================================================

        // Embedded CSS Styles für SVG-Export (damit Styles auch ohne Browser funktionieren)
        function getEmbeddedSVGStyles() {
            return `
                <style>
                    /* Schriftarten */
                    text { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; }

                    /* Bar Styles */
                    .bar { transition: opacity 0.2s ease; }
                    .stacked-bar { cursor: pointer; }

                    /* Connector Lines */
                    .connector-line { stroke-width: 1; }

                    /* Labels */
                    .value-label { font-size: 12px; font-weight: bold; text-anchor: middle; }
                    .value-label-inside { font-size: 11px; font-weight: bold; fill: white; text-anchor: middle; dominant-baseline: middle; }
                    .axis-label { font-size: 11px; text-anchor: middle; }
                    .segment-label { font-size: 11px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; }
                    .total-label { font-size: 13px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; }

                    /* Brackets */
                    .bracket-line { stroke-width: 1.5; fill: none; }
                    .bracket-line-dashed { stroke-width: 1; fill: none; }
                    .bracket-bubble { fill: white; stroke-width: 1.5; }
                    .bracket-label { font-size: 12px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; }
                    .change-label { font-size: 10px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: middle; }
                    .arrow-head { fill: #333; }

                    .data-point { cursor: pointer; }

                    /* Legend */
                    .legend-text { font-size: 11px; fill: #333; }
                </style>
            `;
        }

        function downloadSVG(index) {
            const svgId = `chart${index}`;
            const svg = document.getElementById(svgId);
            const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';

            const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
${getEmbeddedSVGStyles()}
${svg.innerHTML}
</svg>`;

            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            downloadBlob(blob, `chart-${index + 1}.svg`);
        }

        function downloadPNG(index) {
            const svgId = `chart${index}`;
            const svg = document.getElementById(svgId);
            const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';
            const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);

            // Erstelle SVG mit eingebetteten Styles für korrektes Rendering
            const svgWithStyles = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
${getEmbeddedSVGStyles()}
${svg.innerHTML}
</svg>`;

            const canvas = document.createElement('canvas');
            // Höhere Auflösung für bessere Qualität (2x)
            const scale = 2;
            canvas.width = vbWidth * scale;
            canvas.height = vbHeight * scale;
            const ctx = canvas.getContext('2d');

            const svgBlob = new Blob([svgWithStyles], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = function() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                URL.revokeObjectURL(url);

                canvas.toBlob(function(blob) {
                    downloadBlob(blob, `chart-${index + 1}.png`);
                }, 'image/png');
            };
            img.src = url;
        }

        function downloadHTML(index) {
            const config = chartConfigs[index];
            const svg = document.getElementById('chart' + index);
            const svgContent = svg.outerHTML;
            const title = config.title || 'Chart';
            const subtitle = config.subtitle || '';

            // String-Konkatenation statt Template-Literals um Browser-Parsing-Probleme zu vermeiden
            const parts = [];
            parts.push('<!DOCTYPE html>');
            parts.push('<html lang="de">');
            parts.push('<head>');
            parts.push('<meta charset="UTF-8">');
            parts.push('<title>' + title + '<\/title>');
            parts.push('<style>');
            // Page Styles
            parts.push('body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif; background: #f5f5f5; padding: 40px; margin: 0; }');
            parts.push('.chart-container { background: white; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.08); padding: 30px; max-width: 1400px; margin: 0 auto; }');
            parts.push('.chart-title { font-size: 18px; font-weight: 600; margin-bottom: 5px; color: #1a1a1a; }');
            parts.push('.chart-subtitle { font-size: 13px; color: #666; margin-bottom: 20px; }');
            parts.push('svg { width: 100%; height: auto; display: block; }');
            // SVG Element Styles
            parts.push('text { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif; }');
            parts.push('.bar { transition: opacity 0.2s ease; }');
            parts.push('.bar:hover { opacity: 0.8; cursor: pointer; }');
            parts.push('.stacked-bar { cursor: pointer; transition: opacity 0.2s ease; }');
            parts.push('.stacked-bar:hover { opacity: 0.85; }');
            parts.push('.connector-line { stroke-width: 1; }');
            parts.push('.value-label { font-size: 12px; font-weight: bold; text-anchor: middle; }');
            parts.push('.value-label-inside { font-size: 11px; font-weight: bold; fill: white; text-anchor: middle; dominant-baseline: middle; }');
            parts.push('.axis-label { font-size: 11px; text-anchor: middle; }');
            parts.push('.segment-label { font-size: 11px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; pointer-events: none; }');
            parts.push('.total-label { font-size: 13px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; }');
            parts.push('.bracket-line { stroke-width: 1.5; fill: none; }');
            parts.push('.bracket-line-dashed { stroke-width: 1; fill: none; }');
            parts.push('.bracket-bubble { fill: white; stroke-width: 1.5; }');
            parts.push('.bracket-label { font-size: 12px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; }');
            parts.push('.change-label { font-size: 10px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: middle; }');
            parts.push('.arrow-head { fill: #333; }');
            parts.push('.data-point { cursor: pointer; transition: r 0.2s ease; }');
            parts.push('.data-point:hover { r: 10 !important; }');
            parts.push('.legend-text { font-size: 11px; fill: #333; }');
            parts.push('<\/style>');
            parts.push('<\/head>');
            parts.push('<body>');
            parts.push('<div class="chart-container">');
            parts.push('<div class="chart-title">' + title + '<\/div>');
            parts.push('<div class="chart-subtitle">' + subtitle + '<\/div>');
            parts.push(svgContent);
            parts.push('<\/div>');
            parts.push('<\/body>');
            parts.push('<\/html>');

            const htmlContent = parts.join('\n');
            const blob = new Blob([htmlContent], { type: 'text/html' });
            downloadBlob(blob, 'chart-' + (index + 1) + '.html');
        }

        async function downloadSelectedAsZIP() {
            if (selectedChartsForExport.size === 0) {
                alert('Bitte wählen Sie mindestens einen Chart für den Export aus.');
                return;
            }

            const zip = new JSZip();

            const selectedIndices = Array.from(selectedChartsForExport).sort((a, b) => a - b);
            selectedIndices.forEach(function(index, i) {
                const svg = document.getElementById('chart' + index);
                if (!svg) return;

                const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';
                const svgParts = [];
                svgParts.push('<?xml version="1.0" encoding="UTF-8"?>');
                svgParts.push('<svg xmlns="http://www.w3.org/2000/svg" viewBox="' + viewBox + '">');
                svgParts.push(getEmbeddedSVGStyles());
                svgParts.push(svg.innerHTML);
                svgParts.push('<\/svg>');
                zip.file('chart-' + (i + 1) + '.svg', svgParts.join('\n'));
            });

            const blob = await zip.generateAsync({ type: 'blob' });
            downloadBlob(blob, 'selected-charts.zip');
        }

        // Legacy-Funktion für Kompatibilität
        async function downloadAllAsZIP() {
            // Alle Charts auswählen und dann exportieren
            chartConfigs.forEach((_, index) => selectedChartsForExport.add(index));
            await downloadSelectedAsZIP();
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // =====================================================
        // POWERPOINT EXPORT (PPTX)
        // =====================================================
        async function downloadPPTX(index) {
            const config = chartConfigs[index];
            const svg = document.getElementById('chart' + index);
            const title = config.title || 'Chart';
            const subtitle = config.subtitle || '';

            // Hole das tatsächliche SVG-Seitenverhältnis
            const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';
            const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
            const aspectRatio = vbWidth / vbHeight;

            // Konvertiere SVG zu Base64 PNG für PowerPoint
            const pngBase64 = await svgToPngBase64(svg, 4); // 4x Auflösung

            // Erstelle PowerPoint
            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';
            pptx.title = title;
            pptx.author = 'Chart Generator';

            // Füge Folie hinzu
            const slide = pptx.addSlide();

            // Titel hinzufügen
            slide.addText(title, {
                x: 0.5,
                y: 0.3,
                w: '90%',
                fontSize: 24,
                bold: true,
                color: '1a1a1a'
            });

            // Untertitel hinzufügen
            if (subtitle) {
                slide.addText(subtitle, {
                    x: 0.5,
                    y: 0.7,
                    w: '90%',
                    fontSize: 14,
                    color: '666666'
                });
            }

            // Berechne Bildgröße basierend auf SVG-Seitenverhältnis
            // Folie ist 10" x 5.625" (16:9), verfügbarer Bereich ca. 9" x 4.5"
            const maxWidth = 9;
            const maxHeight = 4.3;
            let imgWidth, imgHeight;

            if (aspectRatio > maxWidth / maxHeight) {
                // Breiter als verfügbarer Bereich - an Breite anpassen
                imgWidth = maxWidth;
                imgHeight = maxWidth / aspectRatio;
            } else {
                // Höher als verfügbarer Bereich - an Höhe anpassen
                imgHeight = maxHeight;
                imgWidth = maxHeight * aspectRatio;
            }

            // Zentriere das Bild horizontal
            const imgX = (10 - imgWidth) / 2;

            // Chart als Bild hinzufügen (mit korrektem Seitenverhältnis)
            slide.addImage({
                data: pngBase64,
                x: imgX,
                y: 1.2,
                w: imgWidth,
                h: imgHeight
            });

            // Download
            pptx.writeFile({ fileName: 'chart-' + (index + 1) + '.pptx' });
        }

        // Hilfsfunktion: SVG zu PNG Base64
        function svgToPngBase64(svg, scale = 2) {
            return new Promise((resolve, reject) => {
                const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';
                const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);

                // SVG mit eingebetteten Styles
                const svgWithStyles = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
${getEmbeddedSVGStyles()}
${svg.innerHTML}
</svg>`;

                const canvas = document.createElement('canvas');
                canvas.width = vbWidth * scale;
                canvas.height = vbHeight * scale;
                const ctx = canvas.getContext('2d');

                const svgBlob = new Blob([svgWithStyles], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = function() {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(url);

                    // Als Base64 zurückgeben
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        // PNG Export mit wählbarer Auflösung (für HD-Export)
        function downloadPNGHD(index) {
            const svgId = `chart${index}`;
            const svg = document.getElementById(svgId);
            const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';
            const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);

            // SVG mit eingebetteten Styles
            const svgWithStyles = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
${getEmbeddedSVGStyles()}
${svg.innerHTML}
</svg>`;

            const canvas = document.createElement('canvas');
            // 4x Auflösung für HD-Qualität
            const scale = 4;
            canvas.width = vbWidth * scale;
            canvas.height = vbHeight * scale;
            const ctx = canvas.getContext('2d');

            const svgBlob = new Blob([svgWithStyles], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = function() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                URL.revokeObjectURL(url);

                canvas.toBlob(function(blob) {
                    downloadBlob(blob, `chart-${index + 1}-HD.png`);
                }, 'image/png');
            };
            img.src = url;
        }

        // Ausgewählte Charts als PPTX (eine Folie pro Chart)
        async function downloadSelectedAsPPTX() {
            if (selectedChartsForExport.size === 0) {
                alert('Bitte wählen Sie mindestens einen Chart für den Export aus.');
                return;
            }

            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';
            pptx.title = 'Chart Collection';
            pptx.author = 'Chart Generator';

            const selectedIndices = Array.from(selectedChartsForExport).sort((a, b) => a - b);

            for (const index of selectedIndices) {
                const config = chartConfigs[index];
                const svg = document.getElementById('chart' + index);
                if (!svg || !config) continue;

                const title = config.title || 'Chart ' + (index + 1);
                const subtitle = config.subtitle || '';

                // Hole das tatsächliche SVG-Seitenverhältnis
                const viewBox = svg.getAttribute('viewBox') || '0 0 1280 720';
                const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
                const aspectRatio = vbWidth / vbHeight;

                // Konvertiere zu PNG
                const pngBase64 = await svgToPngBase64(svg, 4);

                // Neue Folie
                const slide = pptx.addSlide();

                // Titel
                slide.addText(title, {
                    x: 0.5,
                    y: 0.3,
                    w: '90%',
                    fontSize: 24,
                    bold: true,
                    color: '1a1a1a'
                });

                // Untertitel
                if (subtitle) {
                    slide.addText(subtitle, {
                        x: 0.5,
                        y: 0.7,
                        w: '90%',
                        fontSize: 14,
                        color: '666666'
                    });
                }

                // Berechne Bildgröße basierend auf SVG-Seitenverhältnis
                const maxWidth = 9;
                const maxHeight = 4.3;
                let imgWidth, imgHeight;

                if (aspectRatio > maxWidth / maxHeight) {
                    imgWidth = maxWidth;
                    imgHeight = maxWidth / aspectRatio;
                } else {
                    imgHeight = maxHeight;
                    imgWidth = maxHeight * aspectRatio;
                }

                // Zentriere das Bild horizontal
                const imgX = (10 - imgWidth) / 2;

                // Chart mit korrektem Seitenverhältnis
                slide.addImage({
                    data: pngBase64,
                    x: imgX,
                    y: 1.2,
                    w: imgWidth,
                    h: imgHeight
                });
            }

            // Download
            pptx.writeFile({ fileName: 'selected-charts.pptx' });
        }

        // Legacy-Funktion für Kompatibilität
        async function downloadAllAsPPTX() {
            // Alle Charts auswählen und dann exportieren
            chartConfigs.forEach((_, index) => selectedChartsForExport.add(index));
            await downloadSelectedAsPPTX();
        }
    </script>
</body>
</html>
